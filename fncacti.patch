diff -crB pcacti_xml/arbiter.cc FN-CACTI/arbiter.cc
*** pcacti_xml/arbiter.cc	2014-07-03 09:47:02.000000000 +0200
--- FN-CACTI/arbiter.cc	2023-04-05 13:30:02.687438000 +0200
***************
*** 98,107 ****
  Arbiter::compute_power() {
    power.readOp.dynamic =  (R*arb_req()*Vdd*Vdd/2 + R*arb_pri()*Vdd*Vdd/2 + 
        arb_grant()*Vdd*Vdd + arb_int()*0.5*Vdd*Vdd);
!   double nor1_leak = deviceType->Vdd*cmos_Ileak(g_tp.min_w_nmos_*NTn1*2, min_w_pmos * PTn1*2, false); 
!   double nor2_leak = deviceType->Vdd*cmos_Ileak(g_tp.min_w_nmos_*NTn2*R, min_w_pmos * PTn2*R, false); 
!   double not_leak = deviceType->Vdd*cmos_Ileak(g_tp.min_w_nmos_*NTi, min_w_pmos * PTi, false); 
!   power.readOp.leakage = nor1_leak + nor2_leak + not_leak; //FIXME include priority table leakage
  }
  
  double //wire cap with triple spacing
--- 98,111 ----
  Arbiter::compute_power() {
    power.readOp.dynamic =  (R*arb_req()*Vdd*Vdd/2 + R*arb_pri()*Vdd*Vdd/2 + 
        arb_grant()*Vdd*Vdd + arb_int()*0.5*Vdd*Vdd);
! //  double nor1_leak = deviceType->Vdd*cmos_Ileak(g_tp.min_w_nmos_*NTn1*2, min_w_pmos * PTn1*2, false);
! //  double nor2_leak = deviceType->Vdd*cmos_Ileak(g_tp.min_w_nmos_*NTn2*R, min_w_pmos * PTn2*R, false);
! //  double not_leak = deviceType->Vdd*cmos_Ileak(g_tp.min_w_nmos_*NTi, min_w_pmos * PTi, false);
! //  power.readOp.leakage = nor1_leak + nor2_leak + not_leak; //FIXME include priority table leakage
!   double nor1_leak = cmos_Isub_leakage(g_tp.min_w_nmos_*NTn1*2, min_w_pmos * PTn1*2, 2, nor);
!   double nor2_leak = cmos_Isub_leakage(g_tp.min_w_nmos_*NTn2*R, min_w_pmos * PTn2*R, 2, nor);
!   double not_leak = cmos_Isub_leakage(g_tp.min_w_nmos_*NTi, min_w_pmos * PTi, 1, inv);
!   power.readOp.leakage = (nor1_leak + nor2_leak + not_leak)*Vdd; //FIXME include priority table leakage
  }
  
  double //wire cap with triple spacing
diff -crB pcacti_xml/bank.cc FN-CACTI/bank.cc
*** pcacti_xml/bank.cc	2014-07-03 09:50:14.000000000 +0200
--- FN-CACTI/bank.cc	2023-04-05 13:30:17.655209000 +0200
***************
*** 46,92 ****
  Bank::Bank(const DynamicParameter & dyn_p):
    dp(dyn_p), mat(dp),
    num_addr_b_mat(dyn_p.number_addr_bits_mat),
!   num_mats_hor_dir(dyn_p.num_mats_h_dir), num_mats_ver_dir(dyn_p.num_mats_v_dir)
  {
    int RWP;
    int ERP;
    int EWP;
  
    if (dp.use_inp_params)
    {
      RWP  = dp.num_rw_ports;
      ERP  = dp.num_rd_ports;
      EWP  = dp.num_wr_ports;
    }
    else
    {
      RWP  = g_ip->num_rw_ports;
      ERP  = g_ip->num_rd_ports;
      EWP  = g_ip->num_wr_ports;
    }
  
    int total_addrbits = (dp.number_addr_bits_mat + dp.number_subbanks_decode)*(RWP+ERP+EWP);
!   int datainbits     = dp.num_di_b_bank_per_port * (RWP + ERP);
!   int dataoutbits    = dp.num_do_b_bank_per_port * (RWP + EWP);
! 
!   if (g_ip->fast_access && dp.is_tag == false)
!   {
!     dataoutbits *= g_ip->data_assoc;
!   }
  
    htree_in_add   = new Htree2 (g_ip->wt,(double) mat.area.w, (double)mat.area.h, 
!       total_addrbits, datainbits, dataoutbits, num_mats_ver_dir*2, num_mats_hor_dir*2, Add_htree);
    htree_in_data  = new Htree2 (g_ip->wt,(double) mat.area.w, (double)mat.area.h,
!       total_addrbits, datainbits, dataoutbits, num_mats_ver_dir*2, num_mats_hor_dir*2, Data_in_htree);
    htree_out_data = new Htree2 (g_ip->wt,(double) mat.area.w, (double)mat.area.h, 
!       total_addrbits, datainbits, dataoutbits, num_mats_ver_dir*2, num_mats_hor_dir*2, Data_out_htree);
! 
    area.w = htree_in_data->area.w;
    area.h = htree_in_data->area.h;
! 
!   num_addr_b_row_dec = (g_ip->fully_assoc == true) ? 0 : _log2(mat.subarray.num_rows);
!   num_addr_b_routed_to_mat_for_act = num_addr_b_row_dec;
!   num_addr_b_routed_to_mat_for_rd_or_wr = num_addr_b_mat - num_addr_b_row_dec;
  }
  
  
--- 46,131 ----
  Bank::Bank(const DynamicParameter & dyn_p):
    dp(dyn_p), mat(dp),
    num_addr_b_mat(dyn_p.number_addr_bits_mat),
!   num_mats_hor_dir(dyn_p.num_mats_h_dir), num_mats_ver_dir(dyn_p.num_mats_v_dir),
!   array_leakage(0),
!   wl_leakage(0),
!   cl_leakage(0)
  {
    int RWP;
    int ERP;
    int EWP;
+   int SCHP;
  
    if (dp.use_inp_params)
    {
      RWP  = dp.num_rw_ports;
      ERP  = dp.num_rd_ports;
      EWP  = dp.num_wr_ports;
+     SCHP = dp.num_search_ports;
    }
    else
    {
      RWP  = g_ip->num_rw_ports;
      ERP  = g_ip->num_rd_ports;
      EWP  = g_ip->num_wr_ports;
+     SCHP = g_ip->num_search_ports;
    }
  
    int total_addrbits = (dp.number_addr_bits_mat + dp.number_subbanks_decode)*(RWP+ERP+EWP);
!   int datainbits     = dp.num_di_b_bank_per_port * (RWP + EWP);
!   int dataoutbits    = dp.num_do_b_bank_per_port * (RWP + ERP);
!   int searchinbits;
!   int searchoutbits;
! 
!   if (dp.fully_assoc || dp.pure_cam)
!    {
!  	  datainbits   = dp.num_di_b_bank_per_port * (RWP + EWP);
!  	  dataoutbits  = dp.num_do_b_bank_per_port * (RWP + ERP);
!  	  searchinbits    = dp.num_si_b_bank_per_port * SCHP;
!  	  searchoutbits   = dp.num_so_b_bank_per_port * SCHP;
!    }
! 
!    if (!(dp.fully_assoc || dp.pure_cam))
!    {
!      if (g_ip->fast_access && dp.is_tag == false)
!      {
!          dataoutbits *= g_ip->data_assoc;
!      }
  
    htree_in_add   = new Htree2 (g_ip->wt,(double) mat.area.w, (double)mat.area.h, 
!       total_addrbits, datainbits, 0, dataoutbits, 0, num_mats_ver_dir*2, num_mats_hor_dir*2, Add_htree);
    htree_in_data  = new Htree2 (g_ip->wt,(double) mat.area.w, (double)mat.area.h,
!       total_addrbits, datainbits, 0, dataoutbits, 0, num_mats_ver_dir*2, num_mats_hor_dir*2, Data_in_htree);
    htree_out_data = new Htree2 (g_ip->wt,(double) mat.area.w, (double)mat.area.h, 
!       total_addrbits, datainbits, 0, dataoutbits, 0, num_mats_ver_dir*2, num_mats_hor_dir*2, Data_out_htree);
! /*
!   cout << "wt " << g_ip->wt << "a.w: " << mat.area.w << ", a.h: " << mat.area.h <<
! 		  "addr_b: " << total_addrbits << "di_bank: " << datainbits << "do_bank: " << dataoutbits <<
! 		  ", num_mats_ver_dir: " << num_mats_ver_dir << ", num_mats_hor_dir " << num_mats_hor_dir << endl;
! */
    area.w = htree_in_data->area.w;
    area.h = htree_in_data->area.h;
!   }
!   else
!    {
! 	   htree_in_add   = new Htree2 (g_ip->wt,(double) mat.area.w, (double)mat.area.h,
! 			  total_addrbits, datainbits, searchinbits,dataoutbits,searchoutbits, num_mats_ver_dir*2, num_mats_hor_dir*2, Add_htree);
! 	  htree_in_data  = new Htree2 (g_ip->wt,(double) mat.area.w, (double)mat.area.h,
! 			  total_addrbits, datainbits,searchinbits, dataoutbits, searchoutbits, num_mats_ver_dir*2, num_mats_hor_dir*2, Data_in_htree);
! 	  htree_out_data = new Htree2 (g_ip->wt,(double) mat.area.w, (double)mat.area.h,
! 			  total_addrbits, datainbits,searchinbits, dataoutbits, searchoutbits,num_mats_ver_dir*2, num_mats_hor_dir*2, Data_out_htree);
! 	  htree_in_search  = new Htree2 (g_ip->wt,(double) mat.area.w, (double)mat.area.h,
! 			  total_addrbits, datainbits,searchinbits, dataoutbits, searchoutbits, num_mats_ver_dir*2, num_mats_hor_dir*2, Data_in_htree,true, true);
! 	  htree_out_search = new Htree2 (g_ip->wt,(double) mat.area.w, (double)mat.area.h,
! 	  			  total_addrbits, datainbits,searchinbits, dataoutbits, searchoutbits,num_mats_ver_dir*2, num_mats_hor_dir*2, Data_out_htree,true);
! 
! 	  area.w = htree_in_data->area.w;
! 	  area.h = htree_in_data->area.h;
!    }
! //  num_addr_b_row_dec = (g_ip->fully_assoc == true) ? 0 : _log2(mat.subarray.num_rows);
!    num_addr_b_row_dec = _log2(mat.subarray.num_rows);
!    num_addr_b_routed_to_mat_for_act = num_addr_b_row_dec;
!    num_addr_b_routed_to_mat_for_rd_or_wr = num_addr_b_mat - num_addr_b_row_dec;
  }
  
  
***************
*** 96,101 ****
--- 135,145 ----
    delete htree_in_add;
    delete htree_out_data;
    delete htree_in_data;
+   if (dp.fully_assoc || dp.pure_cam)
+    {
+  	  delete htree_in_search;
+  	  delete htree_out_search;
+    }
  }
  
  
***************
*** 106,124 ****
  }
  
  
- 
  void Bank::compute_power_energy()
  {
    mat.compute_power_energy();
  
!   power.readOp.dynamic += mat.power.readOp.dynamic * dp.num_act_mats_hor_dir;
!   power.readOp.leakage += mat.power.readOp.leakage * dp.num_mats;
  
!   power.readOp.dynamic += htree_in_add->power.readOp.dynamic;
!   power.readOp.dynamic += htree_out_data->power.readOp.dynamic;
  
!   power.readOp.leakage += htree_in_add->power.readOp.leakage;
!   power.readOp.leakage += htree_in_data->power.readOp.leakage;
!   power.readOp.leakage += htree_out_data->power.readOp.leakage;
  }
- 
--- 149,208 ----
  }
  
  
  void Bank::compute_power_energy()
  {
    mat.compute_power_energy();
  
!   if (!(dp.fully_assoc || dp.pure_cam))
!    {
! //  cout << "Leakage initial : " <<  power.readOp.leakage << endl;
! 	  power.readOp.dynamic += mat.power.readOp.dynamic * dp.num_act_mats_hor_dir;
! 	  power.readOp.leakage += mat.power.readOp.leakage * dp.num_mats;
! 
! 	  power.readOp.dynamic += htree_in_add->power.readOp.dynamic;
! 	  power.readOp.dynamic += htree_out_data->power.readOp.dynamic;
! 
! 	  array_leakage  += mat.array_leakage*dp.num_mats;
! 	  wl_leakage     += mat.wl_leakage*dp.num_mats;
! 	  cl_leakage     += mat.cl_leakage*dp.num_mats;
! 
! 	  power.readOp.leakage += htree_in_add->power.readOp.leakage;
! 	  power.readOp.leakage += htree_in_data->power.readOp.leakage;
! 	  power.readOp.leakage += htree_out_data->power.readOp.leakage;
! /*
!   if(dp.is_tag)
! 	  cout << "bank.cc tag: Leakage MAT : " << mat.power.readOp.leakage * dp.num_mats << ",\t IN TREE ADD : " << htree_in_add->power.readOp.leakage <<
! 		  ",\t\t\t IN TREE DATA : " << htree_in_data->power.readOp.leakage << ",\t\t\t OUT TREE DATA : "<< htree_out_data->power.readOp.leakage
! 		  << ", total bank leakage : " << power.readOp.leakage << endl;
!   if(!dp.is_tag)
! 	  cout << "bank.cc dat: Leakage MAT : " << mat.power.readOp.leakage * dp.num_mats << ",\t IN TREE ADD : " << htree_in_add->power.readOp.leakage <<
! 	  		  ",\t IN TREE DATA : " << htree_in_data->power.readOp.leakage << ", OUT TREE DATA : "<< htree_out_data->power.readOp.leakage
! 			  << ", total bank leakage : " << power.readOp.leakage << endl;
! */
!    }
!   else
!    {
  
!  	  power.readOp.dynamic += mat.power.readOp.dynamic ;//for fa and cam num_act_mats_hor_dir is 1 for plain r/w
!  	  power.readOp.leakage += mat.power.readOp.leakage * dp.num_mats;
  
!  	  power.searchOp.dynamic += mat.power.searchOp.dynamic * dp.num_mats;
!  	  power.searchOp.dynamic += mat.power_bl_precharge_eq_drv.searchOp.dynamic +
!  	  	                        mat.power_sa.searchOp.dynamic +
!  	  	                        mat.power_bitline.searchOp.dynamic +
!  	  	                        mat.power_subarray_out_drv.searchOp.dynamic+
!  	  	                        mat.ml_to_ram_wl_drv->power.readOp.dynamic;
! 
!  	  power.readOp.dynamic += htree_in_add->power.readOp.dynamic;
!  	  power.readOp.dynamic += htree_out_data->power.readOp.dynamic;
! 
!  	  power.searchOp.dynamic += htree_in_search->power.searchOp.dynamic;
!  	  power.searchOp.dynamic += htree_out_search->power.searchOp.dynamic;
! 
!  	  power.readOp.leakage += htree_in_add->power.readOp.leakage;
!  	  power.readOp.leakage += htree_in_data->power.readOp.leakage;
!  	  power.readOp.leakage += htree_out_data->power.readOp.leakage;
!  	  power.readOp.leakage += htree_in_search->power.readOp.leakage;
!  	  power.readOp.leakage += htree_out_search->power.readOp.leakage;
!    }
  }
diff -crB pcacti_xml/bank.h FN-CACTI/bank.h
*** pcacti_xml/bank.h	2014-07-03 09:47:54.000000000 +0200
--- FN-CACTI/bank.h	2023-04-05 13:14:03.546100000 +0200
***************
*** 61,66 ****
--- 61,68 ----
      Htree2 *htree_in_add;
      Htree2 *htree_in_data;
      Htree2 *htree_out_data;
+     Htree2 *htree_in_search;
+     Htree2 *htree_out_search;
      
      int  num_addr_b_mat;
      int  num_mats_hor_dir;
***************
*** 69,74 ****
--- 71,80 ----
      int  num_addr_b_row_dec;
      int  num_addr_b_routed_to_mat_for_act;
      int  num_addr_b_routed_to_mat_for_rd_or_wr;
+ 
+     double  array_leakage;
+     double  wl_leakage;
+     double  cl_leakage;
  };
  
  
diff -crB pcacti_xml/basic_circuit.cc FN-CACTI/basic_circuit.cc
*** pcacti_xml/basic_circuit.cc	2014-07-03 09:47:22.000000000 +0200
--- FN-CACTI/basic_circuit.cc	2023-04-05 13:37:46.972327000 +0200
***************
*** 92,97 ****
--- 92,111 ----
    return p;
  }
  
+ int factorial(int n, int m)
+ {
+ 	int fa = m, i;
+ 	for (i=m+1; i<=n; i++)
+ 		fa *=i;
+ 	return fa;
+ }
+ 
+ int combination(int n, int m)
+ {
+   int ret;
+   ret = factorial(n, m+1) / factorial(n - m);
+   return ret;
+ }
  
  /*----------------------------------------------------------------------*/
  
***************
*** 132,143 ****
  
    /***** Alireza - BEGIN *****/
    double Cg;
!   if ( g_ip->is_finfet ) {
!     double W_min = 2 * dt->H_fin;
      int N_fin = (int) (ceil(width / W_min));
!     Cg = (dt->C_g_ideal + dt->C_overlap + 3*dt->C_fringe)*W_min*N_fin + dt->l_phy*Cpolywire;
    } else {
!     Cg = (dt->C_g_ideal + dt->C_overlap + 3*dt->C_fringe)*width + dt->l_phy*Cpolywire;
    }
    return Cg;
    /****** Alireza - END ******/
--- 146,160 ----
  
    /***** Alireza - BEGIN *****/
    double Cg;
! //  cout << "Cpolywire : " <<Cpolywire << endl; //Cpolywire = 0 always
! // Divya Changing begin
!     if ( g_ip->is_finfet) {
!     double W_min = 2 * dt->H_fin + dt->W_fin; //2 * dt->H_fin;(original) //Divya changed
      int N_fin = (int) (ceil(width / W_min));
! //    Cg = (dt->C_g_ideal + dt->C_overlap + 3*dt->C_fringe)*W_min*N_fin + dt->l_phy*Cpolywire;
!     Cg = (dt->C_g_ideal)*W_min*N_fin; //Divya changed
    } else {
!   Cg = (dt->C_g_ideal + dt->C_overlap + 3*dt->C_fringe)*width + dt->l_phy*Cpolywire;
    }
    return Cg;
    /****** Alireza - END ******/
***************
*** 175,186 ****
  
    /***** Alireza - BEGIN *****/
    double Cg;
    if ( g_ip->is_finfet ) {
!     double W_min = 2 * dt->H_fin;
      int N_fin = (int) (ceil(width / W_min));
!     Cg = (dt->C_g_ideal + dt->C_overlap + 3*dt->C_fringe)*W_min*N_fin + dt->l_phy*Cpolywire;
    } else {
!     Cg = (dt->C_g_ideal + dt->C_overlap + 3*dt->C_fringe)*width + dt->l_phy*Cpolywire;
    }
    return Cg;
    /****** Alireza - END ******/
--- 192,207 ----
  
    /***** Alireza - BEGIN *****/
    double Cg;
+   // Divya Changing begin
+   //  As W_fin != 2*H_fin.  We have width given, no need to derive from H_fin.
    if ( g_ip->is_finfet ) {
!     double W_min = 2 * dt->H_fin + dt->W_fin; //dt->W_fin; //2 * dt->H_fin;(original) //Divya changed
      int N_fin = (int) (ceil(width / W_min));
!  //   	cout << "gate_C_pass :: width " << width << ", W_min : " << W_min << ", N_fin : " << N_fin << endl;
! //   	Cg = (dt->C_g_ideal + dt->C_overlap + 3*dt->C_fringe)*W_min*N_fin + dt->l_phy*Cpolywire;
!     Cg = (dt->C_g_ideal)*W_min*N_fin; //Divya changed
    } else {
!   Cg = (dt->C_g_ideal + dt->C_overlap + 3*dt->C_fringe)*width + dt->l_phy*Cpolywire;
    }
    return Cg;
    /****** Alireza - END ******/
***************
*** 248,277 ****
    int N_fin = 1;
    int N_fin_in_each_fold = 1;
    int num_folded_tr;
!   if ( g_ip->is_finfet ) {
!     double W_min = 2 * dt->H_fin;
      N_fin = (int) (ceil(width / W_min));
      int N_fin_max = (int) (floor(w_folded_tr / dt->P_fin)); // + 1;
! 	 if ( N_fin_max == 0 ) { cout << "ERROR: divide by zero in drain_C_ function!\n"; exit(0); }
  	 num_folded_tr = (int) (ceil((double)N_fin / N_fin_max));
  	 N_fin_in_each_fold = (int) (ceil((double)N_fin / num_folded_tr));
    } else {
!     num_folded_tr = (int) (ceil(width / w_folded_tr));
!     ///if (num_folded_tr < 2) { w_folded_tr = width; } // originally in cacti
!     w_folded_tr = width / (double)num_folded_tr;
    }
    /****** Alireza - END ******/
   
    double spacing_poly_contact_poly = g_tp.w_poly_contact + 2 * g_tp.spacing_poly_to_contact;
    double total_drain_w = spacing_poly_contact_poly +  // only for drain
                           (stack - 1) * g_tp.spacing_poly_to_poly;
! 								 
    /***** Alireza - BEGIN *****/
    double drain_h_for_sidewall;
!   if ( g_ip->is_finfet ) {
      drain_h_for_sidewall = dt->T_si;
    } else {
!     drain_h_for_sidewall = w_folded_tr;
    }
    /****** Alireza - END ******/
    
--- 269,309 ----
    int N_fin = 1;
    int N_fin_in_each_fold = 1;
    int num_folded_tr;
!   // Divya Changing begin
!    // As W_fin != 2*H_fin.  We have width given, no need to derive from H_fin.
!    if ( g_ip->is_finfet ) {
!     double W_min = 2 * dt->H_fin + dt->W_fin; //dt->W_fin;	//2 * dt->H_fin;(original) //Divya changed
      N_fin = (int) (ceil(width / W_min));
+ 
      int N_fin_max = (int) (floor(w_folded_tr / dt->P_fin)); // + 1;
! 	 if ( N_fin_max == 0 ) {
! //		 cout << "next_arg_thresh_folding_width_or_height_cell: " << next_arg_thresh_folding_width_or_height_cell << endl;
! //		 cout << "ERROR: divide by zero in drain_C_ function!\n";
! //		 cout << "width: " << width << ", W_min: " << W_min << ", N_fin: " << N_fin
! //				 << ", w_folded_tr: " << w_folded_tr << ", P_fin: " << dt->P_fin << ", folddimension: " << fold_dimension << endl;
! 		 N_fin_max = 1;	//divya adding 22-11-2021
! //		 exit(0); //divya removing 22-11-2021
! 	 }
  	 num_folded_tr = (int) (ceil((double)N_fin / N_fin_max));
  	 N_fin_in_each_fold = (int) (ceil((double)N_fin / num_folded_tr));
+ //	 cout << "width : " << width << ", W_min : " << W_min << ", N_fin : " << N_fin << ", N_fin_max : " << N_fin_max << endl;
    } else {
!   num_folded_tr = (int) (ceil(width / w_folded_tr));
!     if (num_folded_tr < 2) { w_folded_tr = width; } // originally in cacti
!     w_folded_tr = width / (double)num_folded_tr;	// not there in original cacti
    }
    /****** Alireza - END ******/
   
    double spacing_poly_contact_poly = g_tp.w_poly_contact + 2 * g_tp.spacing_poly_to_contact;
    double total_drain_w = spacing_poly_contact_poly +  // only for drain
                           (stack - 1) * g_tp.spacing_poly_to_poly;
! 
    /***** Alireza - BEGIN *****/
    double drain_h_for_sidewall;
!    if ( g_ip->is_finfet ) {
      drain_h_for_sidewall = dt->T_si;
    } else {
!   drain_h_for_sidewall = w_folded_tr;
    }
    /****** Alireza - END ******/
    
***************
*** 294,304 ****
    double drain_C_area;
    double drain_C_sidewall;
    double drain_C_wrt_gate;
!   if ( g_ip->is_finfet ) {
      drain_C_area     = c_junc_area * total_drain_w * dt->T_si * N_fin_in_each_fold;
      drain_C_sidewall = c_junc_sidewall * (drain_h_for_sidewall + 2 * total_drain_w) * N_fin_in_each_fold;
      drain_C_wrt_gate = 0;//(c_fringe + c_overlap) * N_fin * 2 * dt->H_fin; // According to BSIM-CMG, this capacitance is zero for FinFETs.
    } else {
      drain_C_area     = c_junc_area * total_drain_w * w_folded_tr;
      drain_C_sidewall = c_junc_sidewall * (drain_h_for_sidewall + 2 * total_drain_w);
      drain_C_wrt_gate = (c_fringe + c_overlap) * total_drain_height_for_cap_wrt_gate;
--- 326,338 ----
    double drain_C_area;
    double drain_C_sidewall;
    double drain_C_wrt_gate;
!   // Divya Changing begin
!    if ( g_ip->is_finfet ) {
      drain_C_area     = c_junc_area * total_drain_w * dt->T_si * N_fin_in_each_fold;
      drain_C_sidewall = c_junc_sidewall * (drain_h_for_sidewall + 2 * total_drain_w) * N_fin_in_each_fold;
      drain_C_wrt_gate = 0;//(c_fringe + c_overlap) * N_fin * 2 * dt->H_fin; // According to BSIM-CMG, this capacitance is zero for FinFETs.
    } else {
+  //Divya end
      drain_C_area     = c_junc_area * total_drain_w * w_folded_tr;
      drain_C_sidewall = c_junc_sidewall * (drain_h_for_sidewall + 2 * total_drain_w);
      drain_C_wrt_gate = (c_fringe + c_overlap) * total_drain_height_for_cap_wrt_gate;
***************
*** 339,351 ****
    double restrans = (nchannel) ? dt->R_nch_on : dt->R_pch_on;
    
    /***** Alireza - BEGIN *****/
!   if ( g_ip->is_finfet ) {
!     // Alireza: "width = ceil(width/w_min) * w_min" for finfets in order to capture oversized width
!     double W_min = 2 * dt->H_fin;
      double width_eff = ceil(width / W_min) * W_min; // effective width = Nfin * Wmin
      return (stack * restrans / width_eff);
    } else {
!     return (stack * restrans / width);
    }
    /****** Alireza - END ******/
  }
--- 373,384 ----
    double restrans = (nchannel) ? dt->R_nch_on : dt->R_pch_on;
    
    /***** Alireza - BEGIN *****/
!     if ( g_ip->is_finfet ) {
!     double W_min = 2 * dt->H_fin + dt->W_fin; //dt->W_fin; //2 * dt->H_fin;(original) //Divya changed
      double width_eff = ceil(width / W_min) * W_min; // effective width = Nfin * Wmin
      return (stack * restrans / width_eff);
    } else {
!   return (stack * restrans / width);
    }
    /****** Alireza - END ******/
  }
***************
*** 456,470 ****
    }
    
    /***** Alireza - BEGIN *****/
    if ( g_ip->is_finfet ) {
!     // Alireza: "nwidth = ceil(nwidth/w_min) * w_min" for finfets in order to capture oversized width
!     // Alireza: "pwidth = ceil(pwidth/w_min) * w_min" for finfets in order to capture oversized width
!     double W_min = 2 * dt->H_fin;
      double nWidth_eff = ceil(nWidth / W_min) * W_min; // effective nwidth = Nfin * Wmin
      double pWidth_eff = ceil(pWidth / W_min) * W_min; // effective pwidth = Nfin * Wmin
      return nWidth_eff*dt->I_off_n + pWidth_eff*dt->I_off_p;
    } else {
!     return nWidth*dt->I_off_n + pWidth*dt->I_off_p;
    }
    /****** Alireza - END ******/
  }
--- 489,502 ----
    }
    
    /***** Alireza - BEGIN *****/
+ //  Divya changing begin
    if ( g_ip->is_finfet ) {
!     double W_min = 2 * dt->H_fin + dt->W_fin; //dt->W_fin; //2 * dt->H_fin;(original) //Divya changed
      double nWidth_eff = ceil(nWidth / W_min) * W_min; // effective nwidth = Nfin * Wmin
      double pWidth_eff = ceil(pWidth / W_min) * W_min; // effective pwidth = Nfin * Wmin
      return nWidth_eff*dt->I_off_n + pWidth_eff*dt->I_off_p;
    } else {
!    return nWidth*dt->I_off_n + pWidth*dt->I_off_p;
    }
    /****** Alireza - END ******/
  }
***************
*** 493,504 ****
    
    /***** Alireza - BEGIN *****/
    if ( g_ip->is_finfet ) {
!     // Alireza: "nwidth = ceil(nwidth/w_min) * w_min" for finfets in order to capture oversized width
!     double W_min = 2 * dt->H_fin;
!     double nwidth_eff = ceil(nwidth / W_min) * W_min; // effective nwidth = Nfin * Wmin
      return nwidth_eff * dt->I_off_n;
    } else {
!     return nwidth * dt->I_off_n;
    }
    /****** Alireza - END ******/
  }
--- 525,535 ----
    
    /***** Alireza - BEGIN *****/
    if ( g_ip->is_finfet ) {
!     double W_min = 2 * dt->H_fin + dt->W_fin; //dt->W_fin; //2 * dt->H_fin;(original) //Divya chnaged
!     double nwidth_eff = ceil(nwidth/W_min) * W_min; // effective nwidth = Nfin * Wmin
      return nwidth_eff * dt->I_off_n;
    } else {
!   return nwidth * dt->I_off_n;
    }
    /****** Alireza - END ******/
  }
***************
*** 527,541 ****
  
    /***** Alireza - BEGIN *****/
    if ( g_ip->is_finfet ) {
!   // Alireza: "pwidth = ceil(pwidth/w_min) * w_min" for finfets in order to capture oversized width
!     double W_min = 2 * dt->H_fin;
      double pwidth_eff = ceil(pwidth / W_min) * W_min; // effective pwidth = Nfin * Wmin
      return pwidth_eff * dt->I_off_p;
    } else {
!     return pwidth * dt->I_off_p;
    }
    /****** Alireza - END ******/
  }
  
  
  
--- 558,690 ----
  
    /***** Alireza - BEGIN *****/
    if ( g_ip->is_finfet ) {
!     double W_min = 2 * dt->H_fin + dt->W_fin; //dt->W_fin; //2 * dt->H_fin;(original) //Divya changed
      double pwidth_eff = ceil(pwidth / W_min) * W_min; // effective pwidth = Nfin * Wmin
      return pwidth_eff * dt->I_off_p;
    } else {
!   return pwidth * dt->I_off_p;
    }
    /****** Alireza - END ******/
  }
  
+ //divya 19-11-2021 for mcpat
+ double cmos_Isub_leakage(
+     double nWidth,
+     double pWidth,
+     int    fanin,
+     enum Gate_type g_type,
+     bool _is_dram,
+     bool _is_cell,
+     bool _is_wl_tr,
+     bool _is_sleep_tx,
+     enum Half_net_topology topo)
+ {
+ 	assert (fanin>=1);
+ 	double nmos_leak = simplified_nmos_leakage(nWidth, _is_dram, _is_cell, _is_wl_tr);	//, _is_sleep_tx);
+ 	double pmos_leak = simplified_pmos_leakage(pWidth, _is_dram, _is_cell, _is_wl_tr);	//, _is_sleep_tx);
+     double Isub=0;
+     int    num_states;
+     int    num_off_tx;
+ 
+     num_states = int(pow(2.0, fanin));
+ 
+     switch (g_type)
+     {
+     case nmos:
+     	if (fanin==1)
+     	{
+     		Isub = nmos_leak/num_states;
+     	}
+     	else
+     	{
+     		if (topo==parallel)
+     		{
+     			Isub=nmos_leak*fanin/num_states; //only when all tx are off, leakage power is non-zero. The possibility of this state is 1/num_states
+     		}
+     		else
+     		{
+     			for (num_off_tx=1; num_off_tx<=fanin; num_off_tx++) //when num_off_tx ==0 there is no leakage power
+     			{
+     				//Isub += nmos_leak*pow(UNI_LEAK_STACK_FACTOR,(num_off_tx-1))*(factorial(fanin)/(factorial(fanin, num_off_tx)*factorial(num_off_tx)));
+     				Isub += nmos_leak*pow(UNI_LEAK_STACK_FACTOR,(num_off_tx-1))*combination(fanin, num_off_tx);
+     			}
+     			Isub /=num_states;
+     		}
+ 
+     	}
+     	break;
+     case pmos:
+     	if (fanin==1)
+     	{
+     		Isub = pmos_leak/num_states;
+     	}
+     	else
+     	{
+     		if (topo==parallel)
+     		{
+     			Isub=pmos_leak*fanin/num_states; //only when all tx are off, leakage power is non-zero. The possibility of this state is 1/num_states
+     		}
+     		else
+     		{
+     			for (num_off_tx=1; num_off_tx<=fanin; num_off_tx++) //when num_off_tx ==0 there is no leakage power
+     			{
+     				//Isub += pmos_leak*pow(UNI_LEAK_STACK_FACTOR,(num_off_tx-1))*(factorial(fanin)/(factorial(fanin, num_off_tx)*factorial(num_off_tx)));
+     				Isub += pmos_leak*pow(UNI_LEAK_STACK_FACTOR,(num_off_tx-1))*combination(fanin, num_off_tx);
+     			}
+     			Isub /=num_states;
+     		}
+ 
+     	}
+     	break;
+     case inv:
+     	Isub = (nmos_leak + pmos_leak)/2;
+     	break;
+     case nand:
+     	Isub += fanin*pmos_leak;//the pullup network
+     	for (num_off_tx=1; num_off_tx<=fanin; num_off_tx++) // the pulldown network
+     	{
+     		//Isub += nmos_leak*pow(UNI_LEAK_STACK_FACTOR,(num_off_tx-1))*(factorial(fanin)/(factorial(fanin, num_off_tx)*factorial(num_off_tx)));
+             Isub += nmos_leak*pow(UNI_LEAK_STACK_FACTOR,(num_off_tx-1))*combination(fanin, num_off_tx);
+     	}
+     	Isub /=num_states;
+     	break;
+     case nor:
+     	for (num_off_tx=1; num_off_tx<=fanin; num_off_tx++) // the pullup network
+     	{
+     		//Isub += pmos_leak*pow(UNI_LEAK_STACK_FACTOR,(num_off_tx-1))*(factorial(fanin)/(factorial(fanin, num_off_tx)*factorial(num_off_tx)));
+     		Isub += pmos_leak*pow(UNI_LEAK_STACK_FACTOR,(num_off_tx-1))*combination(fanin, num_off_tx);
+     	}
+     	Isub += fanin*nmos_leak;//the pulldown network
+     	Isub /=num_states;
+     	break;
+     case tri:
+     	Isub += (nmos_leak + pmos_leak)/2;//enabled
+     	Isub += nmos_leak*UNI_LEAK_STACK_FACTOR; //disabled upper bound of leakage power
+     	Isub /=2;
+     	break;
+     case tg:
+     	Isub = (nmos_leak + pmos_leak)/2;
+     	break;
+     default:
+     	assert(0);
+     	break;
+ 	  }
+ 
+     return Isub;
+ }
  
+ //divya 19-11-2021
+ double cmos_Ig_leakage(
+     double nWidth,
+     double pWidth,
+     int    fanin,
+     enum Gate_type g_type,
+     bool _is_dram,
+     bool _is_cell,
+     bool _is_wl_tr,
+     bool _is_sleep_tx,
+     enum Half_net_topology topo)
+ {
+ 	return 0;
+ }
  
diff -crB pcacti_xml/basic_circuit.h FN-CACTI/basic_circuit.h
*** pcacti_xml/basic_circuit.h	2014-07-03 09:49:48.000000000 +0200
--- FN-CACTI/basic_circuit.h	2023-04-05 13:30:05.251399000 +0200
***************
*** 45,54 ****
--- 45,57 ----
  #include "const.h"
  #include "cacti_interface.h"
  
+ #define UNI_LEAK_STACK_FACTOR 0.43
  
  int powers (int base, int n);
  bool is_pow2(int64_t val);
  uint32_t _log2(uint64_t num);
+ int factorial(int n, int m = 1);
+ int combination(int n, int m);
  
  //#define DBG
  #ifdef DBG
***************
*** 72,77 ****
--- 75,82 ----
      Add_htree,
      Data_in_htree,
      Data_out_htree,
+     Search_in_htree,
+     Search_out_htree,
  };
  
  
***************
*** 148,151 ****
--- 153,208 ----
      bool _is_cell = false,
      bool _is_wl_tr = false);
  
+ //divya 19-11-2021
+ //set power point product mask; strictly speaking this is not real point product
+ inline void set_pppm(
+ 	double * pppv,
+ 	double a=1,
+     double b=1,
+     double c=1,
+     double d=1
+     ){
+ 		pppv[0]= a;
+ 		pppv[1]= b;
+ 		pppv[2]= c;
+ 		pppv[3]= d;
+ }
+ 
+ enum Gate_type {
+     nmos,
+     pmos,
+ 	inv,
+     nand,
+     nor,
+     tri,
+     tg
+ };
+ 
+ enum Half_net_topology {
+     parallel,
+     series
+ };
+ 
+ double cmos_Isub_leakage(
+     double nWidth,
+     double pWidth,
+     int    fanin,
+     enum Gate_type g_type,
+     bool _is_dram = false,
+     bool _is_cell = false,
+     bool _is_wl_tr = false,
+     bool _is_sleep_tx = false,
+     enum Half_net_topology topo = series);
+ 
+ double cmos_Ig_leakage(
+     double nWidth,
+     double pWidth,
+     int    fanin,
+     enum Gate_type g_type,
+     bool _is_dram = false,
+     bool _is_cell = false,
+     bool _is_wl_tr = false,
+     bool _is_sleep_tx = false,
+     enum Half_net_topology topo = series);
+ 
  #endif
Only in pcacti_xml: cache.cfg
diff -crB pcacti_xml/cacti_interface.cc FN-CACTI/cacti_interface.cc
*** pcacti_xml/cacti_interface.cc	2014-07-03 09:47:54.000000000 +0200
--- FN-CACTI/cacti_interface.cc	2023-04-05 13:30:15.147247000 +0200
***************
*** 77,82 ****
--- 77,83 ----
    pdn.Ioff = Ioffs[2];
    iso.Ioff = Ioffs[3];
    rac.Ioff = Ioffs[4];
+  // cout << "accoff  : " << acc.Ioff << ", pupOff : " << pup.Ioff << ", pdnoff : " << pdn.Ioff << endl;
  }
  
  void SRAMCellParameters::getNfins(int (&n)[5]) {
***************
*** 147,173 ****
    return width;
  }
  
! double SRAMCellParameters::getPleakAccTx(double vdd, double hfin) {
    if ( PleakAT_given ) {
      return Pleak_acctx;
    } else {
      if (g_ip->is_finfet) {
!       return ((acc.Nfin*acc.Ioff) * 2 * hfin * vdd);
!     } else {
!       double Iport = cmos_Ileak(g_tp.sram.cell_a_w, 0,  false, true); 
        return (Iport * vdd);
      }
    }
  }
  
! double SRAMCellParameters::getPleakCCInv(double vdd, double hfin) {
    if ( PleakCC_given ) {
      return Pleak_ccinv;
    } else {
      if (g_ip->is_finfet) {
!       return (((pup.Nfin*pup.Ioff)+(pdn.Nfin*pdn.Ioff)) * 2 * hfin * vdd);
      } else {
!       double Icell = cmos_Ileak(g_tp.sram.cell_nmos_w, g_tp.sram.cell_pmos_w, false, true);
        return (Icell * vdd);
      }
    }
--- 148,181 ----
    return width;
  }
  
! // double SRAMCellParameters::getPleakAccTx(double vdd, double hfin)
! double SRAMCellParameters::getPleakAccTx(double vdd, double hfin, double wfin) {
    if ( PleakAT_given ) {
      return Pleak_acctx;
    } else {
      if (g_ip->is_finfet) {
!  //     return ((acc.Nfin*acc.Ioff) * 2 * hfin * vdd);
!  		return ((acc.Nfin*acc.Ioff) * (2 * hfin + wfin) * vdd);
!      } else {
! //      double Iport = cmos_Ileak(g_tp.sram.cell_a_w, 0,  false, true);
!     	 double Iport     = cmos_Isub_leakage(g_tp.cam.cell_a_w, 0,  1, nmos, false, true);//TODO: how much is the idle time? just by *2?
        return (Iport * vdd);
      }
    }
  }
  
! 
! // double SRAMCellParameters::getPleakCCInv(double vdd, double hfin)
! double SRAMCellParameters::getPleakCCInv(double vdd, double hfin, double wfin) {
    if ( PleakCC_given ) {
      return Pleak_ccinv;
    } else {
      if (g_ip->is_finfet) {
!  //     return (((pup.Nfin*pup.Ioff)+(pdn.Nfin*pdn.Ioff)) * 2 * hfin * vdd);
!  		return (((pup.Nfin*pup.Ioff)+(pdn.Nfin*pdn.Ioff)) * (2 * hfin + wfin) * vdd);
      } else {
! //      double Icell = cmos_Ileak(g_tp.sram.cell_nmos_w, g_tp.sram.cell_pmos_w, false, true);
!     	double Icell     = cmos_Isub_leakage(g_tp.cam.cell_nmos_w, g_tp.cam.cell_pmos_w, 1, inv, false, true)*2;
        return (Icell * vdd);
      }
    }
***************
*** 207,219 ****
  
  void uca_org_t::find_delay()
  {
!   mem_array * data_arr = data_array2;
!   mem_array * tag_arr  = tag_array2;
  
    // check whether it is a regular cache or scratch ram
!   if (g_ip->is_cache == false)
    {
!     access_time = data_arr->access_time;
    }
    // Both tag and data lookup happen in parallel
    // and the entire set is sent over the data array h-tree without
--- 215,228 ----
  
  void uca_org_t::find_delay()
  {
!   mem_array & data_arr = data_array2;
!   mem_array & tag_arr  = tag_array2;
  
    // check whether it is a regular cache or scratch ram
! //  if (g_ip->is_cache == false)
!   if (g_ip->pure_ram|| g_ip->pure_cam || g_ip->fully_assoc)
    {
!     access_time = data_arr.access_time;
    }
    // Both tag and data lookup happen in parallel
    // and the entire set is sent over the data array h-tree without
***************
*** 221,243 ****
    // power overhead Nav
    else if (g_ip->fast_access == true)
    {
!     access_time = MAX(tag_arr->access_time, data_arr->access_time);
    }
    // Tag is accessed first. On a hit, way-select signal along with the
    // address is sent to read/write the appropriate block in the data
    // array
    else if (g_ip->is_seq_acc == true)
    {
!     access_time = tag_arr->access_time + data_arr->access_time;
    }
    // Normal access: tag array access and data array access happen in parallel.
    // But, the data array will wait for the way-select and transfer only the
    // appropriate block over the h-tree.
    else
    {
!     access_time = MAX(tag_arr->access_time + data_arr->delay_senseamp_mux_decoder,
!                       data_arr->delay_before_subarray_output_driver) +
!                   data_arr->delay_from_subarray_output_driver_to_output;
    }
  }
  
--- 230,252 ----
    // power overhead Nav
    else if (g_ip->fast_access == true)
    {
!     access_time = MAX(tag_arr.access_time, data_arr.access_time);
    }
    // Tag is accessed first. On a hit, way-select signal along with the
    // address is sent to read/write the appropriate block in the data
    // array
    else if (g_ip->is_seq_acc == true)
    {
!     access_time = tag_arr.access_time + data_arr.access_time;
    }
    // Normal access: tag array access and data array access happen in parallel.
    // But, the data array will wait for the way-select and transfer only the
    // appropriate block over the h-tree.
    else
    {
!     access_time = MAX(tag_arr.access_time + data_arr.delay_senseamp_mux_decoder,
!                       data_arr.delay_before_subarray_output_driver) +
!                   data_arr.delay_from_subarray_output_driver_to_output;
    }
  }
  
***************
*** 245,286 ****
  
  void uca_org_t::find_energy()
  {
!   if (g_ip->is_cache) 
!     power = data_array2->power + tag_array2->power;
    else 
!     power = data_array2->power;
  }
  
  
  
  void uca_org_t::find_area()
  {
!   if (g_ip->is_cache == false)
    {
!     cache_ht  = data_array2->height;
!     cache_len = data_array2->width;
    }
    else
    {
!     cache_ht  = MAX(tag_array2->height, data_array2->height);
!     cache_len = tag_array2->width + data_array2->width;
    }
    area = cache_ht * cache_len;
  }
  
! 
  
  void uca_org_t::find_cyc()
  {
!   if (g_ip->is_cache == false)
    {
!     cycle_time = data_array2->cycle_time;
    }
    else
    {
!     cycle_time = MAX(tag_array2->cycle_time, 
!                     data_array2->cycle_time);
    }
  }
  
  
--- 254,351 ----
  
  void uca_org_t::find_energy()
  {
! //  if (g_ip->is_cache)
!   if (!(g_ip->pure_ram|| g_ip->pure_cam || g_ip->fully_assoc))//(g_ip->is_cache)
! 	power = data_array2.power + tag_array2.power;
    else 
!     power = data_array2.power;
  }
  
  
  
  void uca_org_t::find_area()
  {
! //  if (g_ip->is_cache == false)
!   if (g_ip->pure_ram|| g_ip->pure_cam || g_ip->fully_assoc)//(g_ip->is_cache == false)
    {
!     cache_ht  = data_array2.height;
!     cache_len = data_array2.width;
    }
    else
    {
!     cache_ht  = MAX(tag_array2.height, data_array2.height);
!     cache_len = tag_array2.width + data_array2.width;
    }
    area = cache_ht * cache_len;
  }
  
! void uca_org_t::adjust_area()
! {
!   double area_adjust;
!   if (g_ip->pure_ram|| g_ip->pure_cam || g_ip->fully_assoc)
!   {
!     if (data_array2.area_efficiency/100.0<0.2)
!     {
!     	//area_adjust = sqrt(area/(area*(data_array2.area_efficiency/100.0)/0.2));
!     	area_adjust = sqrt(0.2/(data_array2.area_efficiency/100.0));
!     	cache_ht  = cache_ht/area_adjust;
!     	cache_len = cache_len/area_adjust;
!     }
!   }
!   area = cache_ht * cache_len;
! }
  
  void uca_org_t::find_cyc()
  {
! //  if (g_ip->is_cache == false)
!   if ((g_ip->pure_ram|| g_ip->pure_cam || g_ip->fully_assoc))//(g_ip->is_cache == false)
    {
!     cycle_time = data_array2.cycle_time;
    }
    else
    {
!     cycle_time = MAX(tag_array2.cycle_time,
!                     data_array2.cycle_time);
    }
  }
  
+ //Divya added 11-11-2020
+ uca_org_t :: uca_org_t()
+ //:tag_array2(0),
+  //data_array2(0)
+ {
+ 	uca_q = vector<uca_org_t * >(0);
+ }
+ 
+ void uca_org_t :: cleanup()
+ {
+ 	//	uca_org_t * it_uca_org;
+ /*	if (data_array2!=0){
+ 		delete data_array2;
+ 		data_array2 =0;
+ 	}
  
+ 	if (tag_array2!=0){
+ 		delete tag_array2;
+ 		tag_array2 =0;
+ 	}
+ */
+ 	std::vector<uca_org_t * >::size_type sz = uca_q.size();
+ 	for (int i=sz-1; i>=0; i--)
+ 	{
+ /*		if (uca_q[i]->data_array2!=0)
+ 		{
+ 			delete uca_q[i]->data_array2;
+ 			uca_q[i]->data_array2 =0;
+ 		}
+ 		if (uca_q[i]->tag_array2!=0){
+ 			delete uca_q[i]->tag_array2;
+ 			uca_q[i]->tag_array2 =0;
+ 		}
+ */
+ 		delete uca_q[i];
+ 		uca_q[i] =0;
+ 		uca_q.pop_back();
+ 	}
+ }
+ //Divya end
diff -crB pcacti_xml/cacti_interface.h FN-CACTI/cacti_interface.h
*** pcacti_xml/cacti_interface.h	2014-07-03 09:50:22.000000000 +0200
--- FN-CACTI/cacti_interface.h	2023-04-06 08:32:17.336855379 +0200
***************
*** 51,59 ****
  using namespace std;
  
  
! class min_values_t;
! class mem_array;
  class uca_org_t;
  
  
  class powerComponents
--- 51,60 ----
  using namespace std;
  
  
! //class min_values_t;
  class uca_org_t;
+ class nuca_org_t;
+ class mem_array;
  
  
  class powerComponents
***************
*** 61,68 ****
    public:
      double dynamic;
      double leakage;
      
!     powerComponents() : dynamic(0), leakage(0) { }
      powerComponents(const powerComponents & obj) { *this = obj; }
      powerComponents & operator=(const powerComponents & rhs)
      {
--- 62,76 ----
    public:
      double dynamic;
      double leakage;
+     //divya: below will be dummy variables for mcpat interface
+     double gate_leakage;
+     double short_circuit;
+     double longer_channel_leakage;
+     double power_gated_leakage;
      
! //    powerComponents() : dynamic(0), leakage(0) { }
!     powerComponents() : dynamic(0), leakage(0), gate_leakage(0), short_circuit(0),
!     		longer_channel_leakage(0), power_gated_leakage(0) { }
      powerComponents(const powerComponents & obj) { *this = obj; }
      powerComponents & operator=(const powerComponents & rhs)
      {
***************
*** 70,78 ****
        leakage = rhs.leakage;
        return *this;
      }
!     void reset() { dynamic = 0; leakage = 0; }
      
      friend powerComponents operator+(const powerComponents & x, const powerComponents & y);
  };
  
  
--- 78,89 ----
        leakage = rhs.leakage;
        return *this;
      }
! //    void reset() { dynamic = 0; leakage = 0; }
!     void reset() { dynamic = 0; leakage = 0; gate_leakage = 0; short_circuit = 0;
!     longer_channel_leakage = 0; power_gated_leakage = 0;}
      
      friend powerComponents operator+(const powerComponents & x, const powerComponents & y);
+     friend powerComponents operator*(const powerComponents & x, double const * const y);
  };
  
  
***************
*** 82,92 ****
    public:
      powerComponents readOp;
      powerComponents writeOp;
      
!     powerDef() : readOp(), writeOp() { }
!     void reset() { readOp.reset(); writeOp.reset(); }
      
      friend powerDef operator+(const powerDef & x, const powerDef & y);
  };
  
  
--- 93,105 ----
    public:
      powerComponents readOp;
      powerComponents writeOp;
+     powerComponents searchOp;//Sheng: for CAM and FA
      
!     powerDef() : readOp(), writeOp(), searchOp() { }
!     void reset() { readOp.reset(); writeOp.reset();  searchOp.reset();}
      
      friend powerDef operator+(const powerDef & x, const powerDef & y);
+     friend powerDef operator*(const powerDef & x, double const * const y);
  };
  
  
***************
*** 143,151 ****
      void setDGcontrol(bool b) { dg_control = b; }
      bool getDGcontrol() { return dg_control; }
      void setPleakAccTx(double d) { Pleak_acctx = d; PleakAT_given = true; }
!     double getPleakAccTx(double vdd, double hfin);
      void setPleakCCInv(double d) { Pleak_ccinv = d; PleakCC_given = true; }
!     double getPleakCCInv(double vdd, double hfin);
  	 void setTransistorParams(int Nfins[5], double gate_lengths[5], double I_offs[5]);
      void getNfins(int (&n)[5]);
      double calc_height(double lambda_um);
--- 156,168 ----
      void setDGcontrol(bool b) { dg_control = b; }
      bool getDGcontrol() { return dg_control; }
      void setPleakAccTx(double d) { Pleak_acctx = d; PleakAT_given = true; }
!     
!  //   double getPleakAccTx(double vdd, double wfin); //Divya chnaged hfin -> wfin
!  	double getPleakAccTx(double vdd, double hfin, double wfin);
      void setPleakCCInv(double d) { Pleak_ccinv = d; PleakCC_given = true; }
!  //   double getPleakCCInv(double vdd, double wfin); //Divya chnaged hfin -> wfin
! 	 double getPleakCCInv(double vdd, double hfin, double wfin);
! 	 
  	 void setTransistorParams(int Nfins[5], double gate_lengths[5], double I_offs[5]);
      void getNfins(int (&n)[5]);
      double calc_height(double lambda_um);
***************
*** 158,170 ****
  class InputParameter
  {
    public:
      void parse_cfg(const string & infile);
      bool error_checking();  // return false if the input parameters are problematic
      void display_ip();
  
!     bool is_finfet;  // Alireza: False -> CMOS transistors, True -> FinFET transistors.
!     bool is_near_threshold;  // Alireza: False -> Super-threshold Vdd, True -> Near-threshold Vdd.
      bool is_itrs2012;  // Alireza2: source data for interconnects: False -> Ron Ho's PhD Thesis 2003, True -> ITRS 2012 Data
      SRAMCellParameters sram_cell_design; // Alireza2
  
      unsigned int cache_sz;  // in bytes
--- 175,202 ----
  class InputParameter
  {
    public:
+ 	InputParameter();
      void parse_cfg(const string & infile);
      bool error_checking();  // return false if the input parameters are problematic
      void display_ip();
  
!     long first; // used to know where the interesting data is
! 
!     bool is_finfet;  // Alireza: False -> CMOS transistors, True -> FinFET transistors. Divya: FinFet true and NCfet false for finfets
!     bool is_ncfet;	//Divya: True -> NCFET [finfet = 1 and ncfet = 1
! 
!     double vdd;	//Divya added
      bool is_itrs2012;  // Alireza2: source data for interconnects: False -> Ron Ho's PhD Thesis 2003, True -> ITRS 2012 Data
+     bool is_asap7; //Divya added data for interconnects from ASAP7 PDK
+ //    bool is_dvs; //Divya added 15-11-2020
+ 
+     int Nfins[5]; //Divya added 26-11-2020
+    	double Lphys[5]; //Divya added 26-11-2020
+ 
+ //   	bool visited; //Divya added 13-7-2022
+ //   	char golden_file_path[1000]; //Divya added 15-7-2022
+ 
+ //    double dvs_start, dvs_end; //Divya added 15-11-2020
      SRAMCellParameters sram_cell_design; // Alireza2
  
      unsigned int cache_sz;  // in bytes
***************
*** 181,193 ****
--- 213,231 ----
      unsigned int obj_func_cycle_t;
      
      double   F_sz_nm;          // feature size in nm
+     double	 wire_F_sz_nm;		// wire feature size in nm //Divya added
      double   F_sz_um;          // feature size in um
+     double	 wire_F_sz_um;		// wire feature size in um //Divya added
      unsigned int num_rw_ports;
      unsigned int num_rd_ports;
      unsigned int num_wr_ports;
      unsigned int num_se_rd_ports;  // number of single ended read ports
+     unsigned int num_search_ports;  // number of search ports for CAM
+ 
      bool     is_main_mem;
      bool     is_cache;
+     bool     pure_ram;
+     bool     pure_cam;
      bool     rpters_in_htree;  // if there are repeaters in htree segment
      unsigned int ver_htree_wires_over_array;
      unsigned int broadcast_addr_din_over_ver_htrees;
***************
*** 212,217 ****
--- 250,257 ----
      bool print_input_args;
      unsigned int nuca_cache_sz; // TODO
      int ndbl, ndwl, nspd, ndsam1, ndsam2, ndcm;
+     int ntbl, ntwl, ntspd, ntsam1, ntsam2, ntcm; //Divya adding tag array params
+ 
      bool force_cache_config;
  
      int cache_level; 
***************
*** 240,245 ****
--- 280,297 ----
      unsigned int nsets;  // == number_of_sets
      int print_detail;
  
+     bool     add_ecc_b_;
+ 
+     //Divya 17-11-2021 for McPAT
+     bool power_gating;
+     double throughput;
+     double latency;
+     int pipeline_stages;
+     int per_stage_vector;
+ 
+     long last; // used to know where the interesting data is
+     std::vector<double> dvs_voltage;
+ 
      // ------------ MAJID BEGIN -----------------
      char xml_path [100];
      char data_array_cell_tech_file[1000];
***************
*** 248,254 ****
      char tag_array_peri_tech_file[1000];
      // ------------ MAJID END -------------------
  
-     bool     add_ecc_b_;
  };
  
  
--- 300,305 ----
***************
*** 346,438 ****
    double precharge_energy;
  } results_mem_array;
    
!   
! class uca_org_t
  {
    public:
!     mem_array * tag_array2;
!     mem_array * data_array2;
!     double access_time;
!     double cycle_time;
!     double area;
!     double area_efficiency;
!     powerDef power;
!     double leak_power_with_sleep_transistors_in_mats;
!     double cache_ht;
!     double cache_len;
!     char file_n[100];
!     double vdd_periph_global;
!     bool valid;
!     results_mem_array tag_array;
!     results_mem_array data_array;
! 
!     void find_delay();
!     void find_energy();
!     void find_area();
!     void find_cyc();
  };
  
  
- uca_org_t cacti_interface(const string & infile_name);
- 
- 
- uca_org_t cacti_interface(
-     int cache_size,
-     int line_size,
-     int associativity,
-     int rw_ports,
-     int excl_read_ports,
-     int excl_write_ports,
-     int single_ended_read_ports,
-     int banks,
-     double tech_node,
-     int page_sz,
-     int burst_length,
-     int pre_width,
-     int output_width,
-     int specific_tag,
-     int tag_width,
-     int access_mode, //0 normal, 1 seq, 2 fast
-     int cache, //scratch ram or cache
-     int main_mem,
-     int obj_func_delay,
-     int obj_func_dynamic_power,
-     int obj_func_leakage_power,
-     int obj_func_area,
-     int obj_func_cycle_time,
-     int dev_func_delay,
-     int dev_func_dynamic_power,
-     int dev_func_leakage_power,
-     int dev_func_area,
-     int dev_func_cycle_time,
-     int ed_ed2_none, // 0 - ED, 1 - ED^2, 2 - use weight and deviate
-     int temp,
-     int wt, //0 - default(search across everything), 1 - global, 2 - 5% delay penalty, 3 - 10%, 4 - 20 %, 5 - 30%, 6 - low-swing 
-     int data_arr_ram_cell_tech_flavor_in, 
-     int data_arr_peri_global_tech_flavor_in, 
-     int tag_arr_ram_cell_tech_flavor_in,
-     int tag_arr_peri_global_tech_flavor_in,
-     int interconnect_projection_type_in, // 0 - aggressive, 1 - normal
-     int wire_inside_mat_type_in, 
-     int wire_outside_mat_type_in, 
-     int is_nuca, // 0 - UCA, 1 - NUCA
-     int core_count,
-     int cache_level, // 0 - L2, 1 - L3
-     int nuca_bank_count,
-     int nuca_obj_func_delay,
-     int nuca_obj_func_dynamic_power,
-     int nuca_obj_func_leakage_power,
-     int nuca_obj_func_area,
-     int nuca_obj_func_cycle_time,
-     int nuca_dev_func_delay,
-     int nuca_dev_func_dynamic_power,
-     int nuca_dev_func_leakage_power,
-     int nuca_dev_func_area,
-     int nuca_dev_func_cycle_time,
-     int REPEATERS_IN_HTREE_SEGMENTS_in,//TODO for now only wires with repeaters are supported
-     int p_input); 
- 
- 
  class mem_array
  {
    public:
--- 397,420 ----
    double precharge_energy;
  } results_mem_array;
    
! class min_values_t
  {
    public:
!     double min_delay;
!     double min_dyn;
!     double min_leakage;
!     double min_area;
!     double min_cyc;
! 
!     min_values_t() : min_delay(BIGNUM), min_dyn(BIGNUM), min_leakage(BIGNUM), min_area(BIGNUM), min_cyc(BIGNUM) { }
! 
!     void update_min_values(const min_values_t * val);
!     void update_min_values(const uca_org_t & res);
!     void update_min_values(const nuca_org_t * res);
!     void update_min_values(const mem_array * res);
  };
  
  
  class mem_array
  {
    public:
***************
*** 467,473 ****
           delay_sense_amp,
           delay_subarray_output_driver,
           delay_dout_htree,
!          delay_comparator;
  
    double all_banks_height,
           all_banks_width,
--- 449,456 ----
           delay_sense_amp,
           delay_subarray_output_driver,
           delay_dout_htree,
!          delay_comparator,
!          delay_matchlines;
  
    double all_banks_height,
           all_banks_width,
***************
*** 477,482 ****
--- 460,467 ----
    powerDef power_addr_input_htree;
    powerDef power_data_input_htree;
    powerDef power_data_output_htree;
+   powerDef power_htree_in_search;
+   powerDef power_htree_out_search;
    powerDef power_row_predecoder_drivers;
    powerDef power_row_predecoder_blocks;
    powerDef power_row_decoders;
***************
*** 496,516 ****
    powerDef power_dataout_vertical_htree;
    powerDef power_comparators;
  
!   min_values_t *arr_min;
    enum Wire_type wt;
  
    // dram stats
!   double activate_energy, read_energy, write_energy, precharge_energy, 
    refresh_power, leak_power_subbank_closed_page, leak_power_subbank_open_page,
    leak_power_request_and_reply_networks;
  
    double precharge_delay;
  
    // Alireza - Begin
    double leak_power_bank;
    double leak_power_mat;
    double leak_power_sram_cell; // Leakage power of an SRAM cell.
!   double leak_power_mem_array; // Leakage power of the memory array 
    // Pleak_mem_array = num_rows * num_cols * num_subarrays_per_mat * Pleak_sram_cell.
    int subarray_num_rows, subarray_num_cols, num_subarrays_per_mat;
    // Alireza - End
--- 481,513 ----
    powerDef power_dataout_vertical_htree;
    powerDef power_comparators;
  
!   powerDef power_cam_bitline_precharge_eq_drv;
!   powerDef power_searchline;
!   powerDef power_searchline_precharge;
!   powerDef power_matchlines;
!   powerDef power_matchline_precharge;
!   powerDef power_matchline_to_wordline_drv;
! 
!   min_values_t arr_min;
    enum Wire_type wt;
  
    // dram stats
!   double activate_energy, read_energy, write_energy, precharge_energy,
    refresh_power, leak_power_subbank_closed_page, leak_power_subbank_open_page,
    leak_power_request_and_reply_networks;
  
    double precharge_delay;
  
+    //Power-gating stats
+    double  array_leakage;
+    double  wl_leakage;
+    double  cl_leakage;
+ 
    // Alireza - Begin
    double leak_power_bank;
    double leak_power_mat;
    double leak_power_sram_cell; // Leakage power of an SRAM cell.
!   double leak_power_mem_array; // Leakage power of the memory array
    // Pleak_mem_array = num_rows * num_cols * num_subarrays_per_mat * Pleak_sram_cell.
    int subarray_num_rows, subarray_num_cols, num_subarrays_per_mat;
    // Alireza - End
***************
*** 519,522 ****
--- 516,670 ----
  };
  
  
+ class uca_org_t
+ {
+   public:
+     mem_array tag_array2;
+     mem_array data_array2;
+     double access_time;
+     double cycle_time;
+     double area;
+     double area_efficiency;
+     powerDef power;
+     double leak_power_with_sleep_transistors_in_mats;
+     double cache_ht;
+     double cache_len;
+     char file_n[100];
+     double vdd_periph_global;
+     bool valid;
+     results_mem_array tag_array;
+     results_mem_array data_array;
+ //Divya added 11-11-2020
+     std::vector<uca_org_t * > uca_q;//for results share the same settings (g_ip and dyn_p) but with different tech settings such as DVFS
+     uca_org_t();
+     void cleanup();
+ //Divya end
+     void find_delay();
+     void find_energy();
+     void find_area();
+     void find_cyc();
+     void adjust_area();//for McPAT only to adjust routing overhead
+ 
+ };
+ 
+ void reconfigure(InputParameter *local_interface, uca_org_t *fin_res);
+ 
+ uca_org_t cacti_interface(const string & infile_name);
+ //McPAT's plain interface, please keep !!!
+ uca_org_t cacti_interface(InputParameter * const local_interface);
+ //McPAT's plain interface, please keep !!!
+ uca_org_t init_interface(InputParameter * const local_interface);
+ //McPAT's plain interface, please keep !!!
+ uca_org_t cacti_interface(
+ 	    int cache_size,
+ 	    int line_size,
+ 	    int associativity,
+ 	    int rw_ports,
+ 	    int excl_read_ports,
+ 	    int excl_write_ports,
+ 	    int single_ended_read_ports,
+ 	    int search_ports,
+ 	    int banks,
+ 	    double tech_node,
+ 	    int output_width,
+ 	    int specific_tag,
+ 	    int tag_width,
+ 	    int access_mode,
+ 	    int cache,
+ 	    int main_mem,
+ 	    int obj_func_delay,
+ 	    int obj_func_dynamic_power,
+ 	    int obj_func_leakage_power,
+ 	    int obj_func_cycle_time,
+ 	    int obj_func_area,
+ 	    int dev_func_delay,
+ 	    int dev_func_dynamic_power,
+ 	    int dev_func_leakage_power,
+ 	    int dev_func_area,
+ 	    int dev_func_cycle_time,
+ 	    int ed_ed2_none, // 0 - ED, 1 - ED^2, 2 - use weight and deviate
+ 	    int temp,
+ 	    int wt, //0 - default(search across everything), 1 - global, 2 - 5% delay penalty, 3 - 10%, 4 - 20 %, 5 - 30%, 6 - low-swing
+ 	    int data_arr_ram_cell_tech_flavor_in,
+ 	    int data_arr_peri_global_tech_flavor_in,
+ 	    int tag_arr_ram_cell_tech_flavor_in,
+ 	    int tag_arr_peri_global_tech_flavor_in,
+ 	    int interconnect_projection_type_in,
+ 	    int wire_inside_mat_type_in,
+ 	    int wire_outside_mat_type_in,
+ 	    int REPEATERS_IN_HTREE_SEGMENTS_in,
+ 	    int VERTICAL_HTREE_WIRES_OVER_THE_ARRAY_in,
+ 	    int BROADCAST_ADDR_DATAIN_OVER_VERTICAL_HTREES_in,
+ 	    int PAGE_SIZE_BITS_in,
+ 	    int BURST_LENGTH_in,
+ 	    int INTERNAL_PREFETCH_WIDTH_in,
+ 	    int force_wiretype,
+ 	    int wiretype,
+ 	    int force_config,
+ 	    int ndwl,
+ 	    int ndbl,
+ 	    int nspd,
+ 	    int ndcm,
+ 	    int ndsam1,
+ 	    int ndsam2,
+ 	    int ecc);
+ 
+ //Naveen's interface
+ uca_org_t cacti_interface(
+     int cache_size,
+     int line_size,
+     int associativity,
+     int rw_ports,
+     int excl_read_ports,
+     int excl_write_ports,
+     int single_ended_read_ports,
+     int banks,
+     double tech_node,
+     int page_sz,
+     int burst_length,
+     int pre_width,
+     int output_width,
+     int specific_tag,
+     int tag_width,
+     int access_mode, //0 normal, 1 seq, 2 fast
+     int cache, //scratch ram or cache
+     int main_mem,
+     int obj_func_delay,
+     int obj_func_dynamic_power,
+     int obj_func_leakage_power,
+     int obj_func_area,
+     int obj_func_cycle_time,
+     int dev_func_delay,
+     int dev_func_dynamic_power,
+     int dev_func_leakage_power,
+     int dev_func_area,
+     int dev_func_cycle_time,
+     int ed_ed2_none, // 0 - ED, 1 - ED^2, 2 - use weight and deviate
+     int temp,
+     int wt, //0 - default(search across everything), 1 - global, 2 - 5% delay penalty, 3 - 10%, 4 - 20 %, 5 - 30%, 6 - low-swing 
+     int data_arr_ram_cell_tech_flavor_in, 
+     int data_arr_peri_global_tech_flavor_in, 
+     int tag_arr_ram_cell_tech_flavor_in,
+     int tag_arr_peri_global_tech_flavor_in,
+     int interconnect_projection_type_in, // 0 - aggressive, 1 - normal
+     int wire_inside_mat_type_in, 
+     int wire_outside_mat_type_in, 
+     int is_nuca, // 0 - UCA, 1 - NUCA
+     int core_count,
+     int cache_level, // 0 - L2, 1 - L3
+     int nuca_bank_count,
+     int nuca_obj_func_delay,
+     int nuca_obj_func_dynamic_power,
+     int nuca_obj_func_leakage_power,
+     int nuca_obj_func_area,
+     int nuca_obj_func_cycle_time,
+     int nuca_dev_func_delay,
+     int nuca_dev_func_dynamic_power,
+     int nuca_dev_func_leakage_power,
+     int nuca_dev_func_area,
+     int nuca_dev_func_cycle_time,
+     int REPEATERS_IN_HTREE_SEGMENTS_in,//TODO for now only wires with repeaters are supported
+     int p_input); 
+ 
+ 
  #endif
diff -crB pcacti_xml/cacti.mk FN-CACTI/cacti.mk
*** pcacti_xml/cacti.mk	2014-07-03 09:50:28.000000000 +0200
--- FN-CACTI/cacti.mk	2023-04-05 13:30:06.579378000 +0200
***************
*** 4,10 ****
  .SUFFIXES: .cc .o
  
  ifndef NTHREADS
!   NTHREADS = 16
  endif
  
  
--- 4,10 ----
  .SUFFIXES: .cc .o
  
  ifndef NTHREADS
!   NTHREADS = 1
  endif
  
  
***************
*** 13,19 ****
  
  ifeq ($(TAG),dbg)
    DBG = -Wall 
!   OPT = -ggdb -g -O0 -DNTHREADS=1
  else
    DBG = 
    OPT = -O3 -msse2 -mfpmath=sse -DNTHREADS=$(NTHREADS)
--- 13,19 ----
  
  ifeq ($(TAG),dbg)
    DBG = -Wall 
!   OPT = -ggdb -g -O0 -DNTHREADS=1  -gstabs+
  else
    DBG = 
    OPT = -O3 -msse2 -mfpmath=sse -DNTHREADS=$(NTHREADS)
***************
*** 24,30 ****
  CXX = g++ -m32
  CC  = gcc -m32
  
! SRCS  = xmlParser.cc area.cc bank.cc mat.cc main.cc Ucache.cc io.cc technology.cc basic_circuit.cc parameter.cc \
  		decoder.cc component.cc uca.cc subarray.cc wire.cc htree2.cc \
  		cacti_interface.cc router.cc nuca.cc crossbar.cc arbiter.cc 
  
--- 24,30 ----
  CXX = g++ -m32
  CC  = gcc -m32
  
! SRCS  = area.cc bank.cc mat.cc main.cc Ucache.cc io.cc technology.cc basic_circuit.cc parameter.cc \
  		decoder.cc component.cc uca.cc subarray.cc wire.cc htree2.cc \
  		cacti_interface.cc router.cc nuca.cc crossbar.cc arbiter.cc 
  
diff -crB pcacti_xml/component.cc FN-CACTI/component.cc
*** pcacti_xml/component.cc	2014-07-03 09:48:48.000000000 +0200
--- FN-CACTI/component.cc	2023-04-05 13:29:38.051815000 +0200
***************
*** 69,88 ****
  { // Alireza: this function computes the diff. width, so we should not consider poly width,
    // because there is no diff. underneath the poly.
    ///double w_poly = g_ip->F_sz_um;
!   double spacing_poly_contact_poly = g_tp.w_poly_contact + 2 * g_tp.spacing_poly_to_contact;
!   double total_diff_w = 2 * spacing_poly_contact_poly +  // for both source and drain
!                         ///num_stacked_in * w_poly +
!                         (num_stacked_in - 1) * g_tp.spacing_poly_to_poly;
  
!   if (num_folded_tr > 1)
!   {
!     ///total_diff_w += (num_folded_tr - 2) * 2 * spacing_poly_contact_poly +
!     total_diff_w += (num_folded_tr - 1) * spacing_poly_contact_poly +
!                     ///(num_folded_tr - 1) * num_stacked_in * w_poly +
!                     (num_folded_tr - 1) * (num_stacked_in - 1) * g_tp.spacing_poly_to_poly;
!   }
! 
!   return total_diff_w;
  }
  
  
--- 69,106 ----
  { // Alireza: this function computes the diff. width, so we should not consider poly width,
    // because there is no diff. underneath the poly.
    ///double w_poly = g_ip->F_sz_um;
! 		if(g_ip->is_finfet) {
! 	  double spacing_poly_contact_poly = g_tp.w_poly_contact + 2 * g_tp.spacing_poly_to_contact;
! 	  double total_diff_w = 2 * spacing_poly_contact_poly +  // for both source and drain
! 							///num_stacked_in * w_poly +
! 							(num_stacked_in - 1) * g_tp.spacing_poly_to_poly;
! 
! 	  if (num_folded_tr > 1)
! 	  {
! 		///total_diff_w += (num_folded_tr - 2) * 2 * spacing_poly_contact_poly +
! 		total_diff_w += (num_folded_tr - 1) * spacing_poly_contact_poly +
! 						///(num_folded_tr - 1) * num_stacked_in * w_poly +
! 						(num_folded_tr - 1) * (num_stacked_in - 1) * g_tp.spacing_poly_to_poly;
! 	  }
! 
! 	  return total_diff_w;
! 	}
! 	else {
! 		  double w_poly = g_ip->F_sz_um;
! 		  double spacing_poly_to_poly = g_tp.w_poly_contact + 2 * g_tp.spacing_poly_to_contact;
! 		  double total_diff_w = 2 * spacing_poly_to_poly +  // for both source and drain
! 		                        num_stacked_in * w_poly +
! 		                        (num_stacked_in - 1) * g_tp.spacing_poly_to_poly;
! 
! 		  if (num_folded_tr > 1)
! 		  {
! 		    total_diff_w += (num_folded_tr - 2) * 2 * spacing_poly_to_poly +
! 		                    (num_folded_tr - 1) * num_stacked_in * w_poly +
! 		                    (num_folded_tr - 1) * (num_stacked_in - 1) * g_tp.spacing_poly_to_poly;
! 		  }
  
! 		  return total_diff_w;
! 	}
  }
  
  
***************
*** 114,125 ****
  
    w_folded_pmos  = (h_tr_region - g_tp.MIN_GAP_BET_P_AND_N_DIFFS) * ratio_p_to_n;
    w_folded_nmos  = (h_tr_region - g_tp.MIN_GAP_BET_P_AND_N_DIFFS) * (1 - ratio_p_to_n);
    assert(w_folded_pmos > 0);
  
    /***** Alireza - BEGIN *****/
!   if ( g_ip->is_finfet ) {
      const TechnologyParameter::DeviceType * dt = &g_tp.peri_global;
!     double W_min = 2 * dt->H_fin;
      int N_fin_pmos = (int) (ceil(w_pmos / W_min));
      int N_fin_max_pmos = (int) (floor(w_folded_pmos / dt->P_fin)); // + 1;
      if ( N_fin_max_pmos == 0 ) { cout << "ERROR: divide by zero in compute_gate_area function!\n"; exit(0); }
--- 132,152 ----
  
    w_folded_pmos  = (h_tr_region - g_tp.MIN_GAP_BET_P_AND_N_DIFFS) * ratio_p_to_n;
    w_folded_nmos  = (h_tr_region - g_tp.MIN_GAP_BET_P_AND_N_DIFFS) * (1 - ratio_p_to_n);
+   if(w_folded_pmos < 0 || w_folded_pmos == 0)
+   { //divya 30-12-2020
+   	  cout << " ratio_p_to_n : " << ratio_p_to_n << " w_pmos : "<< w_pmos << ", w_nmos : " << w_nmos << endl;
+ 	  cout << "component.cc :: h_gate : " << h_gate << ",  2* g_tp.HPOWERRAIL" << 2* g_tp.HPOWERRAIL <<
+ 	  ", h_tr_region : " << h_tr_region << ", g_tp.MIN_GAP_BET_P_AND_N_DIFFS " <<
+ 	  g_tp.MIN_GAP_BET_P_AND_N_DIFFS << ", ratio_p_to_n : " << ratio_p_to_n << ", w_folded_pmos : " << w_folded_pmos << endl;
+   }
    assert(w_folded_pmos > 0);
  
    /***** Alireza - BEGIN *****/
! //Divya Changing begin
!   // As W_fin != 2*H_fin.  We have width given, no need to derive from H_fin.
!    if ( g_ip->is_finfet ) {
      const TechnologyParameter::DeviceType * dt = &g_tp.peri_global;
!     double W_min = 2 * dt->H_fin + dt->W_fin; //dt->W_fin;	//2 * dt->H_fin;(original) //Divya changed
      int N_fin_pmos = (int) (ceil(w_pmos / W_min));
      int N_fin_max_pmos = (int) (floor(w_folded_pmos / dt->P_fin)); // + 1;
      if ( N_fin_max_pmos == 0 ) { cout << "ERROR: divide by zero in compute_gate_area function!\n"; exit(0); }
***************
*** 159,173 ****
  
    /***** Alireza - BEGIN *****/
    double w_nmos_phys, w_pmos_phys;
    if ( g_ip->is_finfet ) {
      const TechnologyParameter::DeviceType * dt = &g_tp.peri_global;
!     double W_min = 2 * dt->H_fin;
      int N_fin_pmos = (int) (ceil(w_pmos / W_min));
      int N_fin_nmos = (int) (ceil(w_nmos / W_min));
      w_pmos_phys = N_fin_pmos * W_min;
      w_nmos_phys = N_fin_nmos * W_min;
    } else {
!     w_pmos_phys = w_pmos;
      w_nmos_phys = w_nmos;
    }
    /****** Alireza - END ******/
--- 188,204 ----
  
    /***** Alireza - BEGIN *****/
    double w_nmos_phys, w_pmos_phys;
+ //  Divya Changing begin
+   // As W_fin != 2*H_fin .  We have width given, no need to derive from H_fin.
    if ( g_ip->is_finfet ) {
      const TechnologyParameter::DeviceType * dt = &g_tp.peri_global;
!     double W_min = 2 * dt->H_fin + dt->W_fin; //dt->W_fin; //2 * dt->H_fin;(original) //Divya changed
      int N_fin_pmos = (int) (ceil(w_pmos / W_min));
      int N_fin_nmos = (int) (ceil(w_nmos / W_min));
      w_pmos_phys = N_fin_pmos * W_min;
      w_nmos_phys = N_fin_nmos * W_min;
    } else {
!      w_pmos_phys = w_pmos;
      w_nmos_phys = w_nmos;
    }
    /****** Alireza - END ******/
***************
*** 176,182 ****
    {
      //means that the height of the gate can 
      //be made smaller than the input height specified, so calculate the height of the gate.
!     gate.h = w_nmos + w_pmos + g_tp.MIN_GAP_BET_P_AND_N_DIFFS + 2 * g_tp.HPOWERRAIL;
    }
    else
    {
--- 207,214 ----
    {
      //means that the height of the gate can 
      //be made smaller than the input height specified, so calculate the height of the gate.
! //    gate.h = w_nmos + w_pmos + g_tp.MIN_GAP_BET_P_AND_N_DIFFS + 2 * g_tp.HPOWERRAIL;//ORIGINAL CACTI
! 	  gate.h = w_nmos_phys + w_pmos_phys + g_tp.MIN_GAP_BET_P_AND_N_DIFFS + 2 * g_tp.HPOWERRAIL; //divya changing this to match finfet width 16-8-2020
    }
    else
    {
***************
*** 198,212 ****
  
    /***** Alireza - BEGIN *****/
    int num_folded_tr;
    if ( g_ip->is_finfet ) {
      const TechnologyParameter::DeviceType * dt = &g_tp.peri_global; // for sense amplifier!
!     double W_min = 2 * dt->H_fin;
      int N_fin = (int) (ceil(input_width / W_min));
      int N_fin_max = (int) (floor(threshold_folding_width / dt->P_fin)); // + 1;
! 	 if ( N_fin_max == 0 ) { cout << "ERROR: divide by zero in compute_tr_width_after_folding function!\n"; exit(0); }
! 	 num_folded_tr = (int) (ceil((double)N_fin / N_fin_max));
    } else {
!     num_folded_tr = (int) (ceil(input_width / threshold_folding_width));
    }
    /****** Alireza - END ******/
    
--- 230,254 ----
  
    /***** Alireza - BEGIN *****/
    int num_folded_tr;
+   //Divya Changing begin
+    // As W_fin != 2*H_fin.  We have width given, no need to derive from H_fin.
    if ( g_ip->is_finfet ) {
      const TechnologyParameter::DeviceType * dt = &g_tp.peri_global; // for sense amplifier!
!     double W_min = 2 * dt->H_fin + dt->W_fin; //dt->W_fin; // 2 * dt->H_fin;(original) //Divya changed
      int N_fin = (int) (ceil(input_width / W_min));
      int N_fin_max = (int) (floor(threshold_folding_width / dt->P_fin)); // + 1;
! //	 if ( N_fin_max == 0 ) { cout << "ERROR: divide by zero in compute_tr_width_after_folding function!\n"; exit(0); }
! 	 if ( N_fin_max == 0 ) {
! //		 cout << "ERROR: divide by zero in compute_tr_width_after_folding function! threshold_folding_width : " << threshold_folding_width
! //		 << ", P_fin : " << dt->P_fin << "\n";
! 		 N_fin_max = 1;	//divya adding 22-11-2021
! //		 exit(0);	//divya removing 22-11-2021
! 	 }
! 
!     num_folded_tr = (int) (ceil((double)N_fin / N_fin_max));
! 
    } else {
!   num_folded_tr = (int) (ceil(input_width / threshold_folding_width));
    }
    /****** Alireza - END ******/
    
diff -crB pcacti_xml/component.h FN-CACTI/component.h
*** pcacti_xml/component.h	2014-07-03 09:48:12.000000000 +0200
--- FN-CACTI/component.h	2023-04-05 13:14:05.962063000 +0200
***************
*** 57,63 ****
      ~Component();
  
      Area area;
!     powerDef power;
      double delay;
      double cycle_time;
  
--- 57,63 ----
      ~Component();
  
      Area area;
!     powerDef power,rt_power;
      double delay;
      double cycle_time;
  
diff -crB pcacti_xml/const.h FN-CACTI/const.h
*** pcacti_xml/const.h	2014-07-03 09:47:48.000000000 +0200
--- FN-CACTI/const.h	2023-04-05 13:37:49.216293000 +0200
***************
*** 157,162 ****
--- 157,163 ----
  
  const int dram_cell_tech_flavor = 0; // 3; /// Alireza
  
+ //#define VBITSENSEMIN 0.08 //minimum bitline sense voltage is fixed to be 80 mV.
  
  #define fopt 4.0
  
***************
*** 266,269 ****
--- 267,274 ----
  #define W_G2G 2.0
  #define EPSILON_SiO2 3.97*8.85*1.0e-18
  
+ //divya 19-11-2021
+ const double pppm[4]      = {1,1,1,1};
+ const double pppm_lkg[4]  = {0,1,1,0};
+ 
  #endif
Only in FN-CACTI: .cproject
diff -crB pcacti_xml/crossbar.cc FN-CACTI/crossbar.cc
*** pcacti_xml/crossbar.cc	2014-07-03 09:47:42.000000000 +0200
--- FN-CACTI/crossbar.cc	2023-04-05 13:37:56.836176000 +0200
***************
*** 42,49 ****
  
  #include "crossbar.h"
  
! #define CB_ADJ 2 //height of the cell (layout) in crossbar
  // buffer is adjusted to get an aspect ratio close to one
  
  Crossbar::Crossbar(
      double n_inp_, 
--- 42,52 ----
  
  #include "crossbar.h"
  
! //#define CB_ADJ 2 //height of the cell (layout) in crossbar
  // buffer is adjusted to get an aspect ratio close to one
+ #define ASPECT_THRESHOLD .8
+ #define ADJ 1
+ 
  
  Crossbar::Crossbar(
      double n_inp_, 
***************
*** 54,69 ****
  {
    min_w_pmos = deviceType->n_to_p_eff_curr_drv_ratio*g_tp.min_w_nmos_;
    Vdd = dt->Vdd;
  }
  
  Crossbar::~Crossbar(){}
  
  double Crossbar::output_buffer()
  {
!   Wire winit(4, 4);
    double l_eff = n_inp*flit_size*g_tp.wire_outside_mat.pitch;
    Wire w1(g_ip->wt, l_eff); 
!   double s1 = w1.repeater_size;
    double pton_size = deviceType->n_to_p_eff_curr_drv_ratio; 
    // the model assumes input capacitance of the wire driver = input capacitance of nand + nor = input cap of the driver transistor
    TriS1 = s1*(1 + pton_size)/(2 + pton_size + 1 + 2*pton_size);
--- 57,74 ----
  {
    min_w_pmos = deviceType->n_to_p_eff_curr_drv_ratio*g_tp.min_w_nmos_;
    Vdd = dt->Vdd;
+   CB_ADJ = 1;
  }
  
  Crossbar::~Crossbar(){}
  
  double Crossbar::output_buffer()
  {
! //  Wire winit(4, 4);
    double l_eff = n_inp*flit_size*g_tp.wire_outside_mat.pitch;
    Wire w1(g_ip->wt, l_eff); 
! //  double s1 = w1.repeater_size;
!   double s1 = w1.repeater_size * (l_eff <w1.repeater_spacing?  l_eff *ADJ/w1.repeater_spacing : ADJ);
    double pton_size = deviceType->n_to_p_eff_curr_drv_ratio; 
    // the model assumes input capacitance of the wire driver = input capacitance of nand + nor = input cap of the driver transistor
    TriS1 = s1*(1 + pton_size)/(2 + pton_size + 1 + 2*pton_size);
***************
*** 98,103 ****
--- 103,109 ----
  
  void Crossbar::compute_power()
  {
+   Wire winit(4, 4);
    double tri_cap = output_buffer();
    assert(tri_cap > 0);
    //area of a tristate logic
***************
*** 115,125 ****
    area.h = g_tp.wire_outside_mat.pitch*n_inp*flit_size * CB_ADJ;
    Wire w2(g_ip->wt, area.h);
  
    power.readOp.dynamic = (w1.power.readOp.dynamic + w2.power.readOp.dynamic + (tri_inp_cap * n_out + tri_out_cap * n_inp + tri_ctr_cap + tri_int_cap) * Vdd*Vdd)*flit_size;
!   power.readOp.leakage =  n_inp * n_out * flit_size * deviceType->Vdd*(
!     cmos_Ileak(g_tp.min_w_nmos_*(TriS2*2 + TriS1*6), min_w_pmos*(TriS2*2 + TriS1*6), false) + 
      w1.power.readOp.leakage + w2.power.readOp.leakage);
!   Wire winit();
  }
  
  void Crossbar::print_crossbar()
--- 121,159 ----
    area.h = g_tp.wire_outside_mat.pitch*n_inp*flit_size * CB_ADJ;
    Wire w2(g_ip->wt, area.h);
  
+   double aspect_ratio_cb = (area.h/area.w)*(n_out/n_inp);
+   if (aspect_ratio_cb > 1) aspect_ratio_cb = 1/aspect_ratio_cb;
+ 
+   if (aspect_ratio_cb < ASPECT_THRESHOLD) {
+     if (n_out > 2 && n_inp > 2) {
+       CB_ADJ+=0.2;
+       //cout << "CB ADJ " << CB_ADJ << endl;
+       if (CB_ADJ < 4) {
+         this->compute_power();
+       }
+     }
+   }
+ 
    power.readOp.dynamic = (w1.power.readOp.dynamic + w2.power.readOp.dynamic + (tri_inp_cap * n_out + tri_out_cap * n_inp + tri_ctr_cap + tri_int_cap) * Vdd*Vdd)*flit_size;
! //  power.readOp.leakage =  n_inp * n_out * flit_size * deviceType->Vdd*(
! //    cmos_Ileak(g_tp.min_w_nmos_*(TriS2*2 + TriS1*6), min_w_pmos*(TriS2*2 + TriS1*6), false) +
! //    w1.power.readOp.leakage + w2.power.readOp.leakage);
! 
!   power.readOp.leakage      =  n_inp * n_out * flit_size * (
!     cmos_Isub_leakage(g_tp.min_w_nmos_*TriS2*2, min_w_pmos*TriS2*2, 1, inv) *Vdd+
! 	cmos_Isub_leakage(g_tp.min_w_nmos_*TriS1*3, min_w_pmos*TriS1*3, 2, nand)*Vdd+
! 	cmos_Isub_leakage(g_tp.min_w_nmos_*TriS1*3, min_w_pmos*TriS1*3, 2, nor) *Vdd+
      w1.power.readOp.leakage + w2.power.readOp.leakage);
! 
! //  Wire winit();
!   // delay calculation
!   double l_eff = n_inp*flit_size*g_tp.wire_outside_mat.pitch;
!   Wire wdriver(g_ip->wt, l_eff);
!   double res = g_tp.wire_outside_mat.R_per_um * (area.w+area.h) + tr_R_on(g_tp.min_w_nmos_*wdriver.repeater_size, NCH, 1);
!   double cap = g_tp.wire_outside_mat.C_per_um * (area.w + area.h) + n_out*tri_inp_cap + n_inp*tri_out_cap;
!   delay = horowitz(w1.signal_rise_time(), res*cap, deviceType->Vth/deviceType->Vdd, deviceType->Vth/deviceType->Vdd, RISE);
! 
!   Wire wreset();
  }
  
  void Crossbar::print_crossbar()
diff -crB pcacti_xml/crossbar.h FN-CACTI/crossbar.h
*** pcacti_xml/crossbar.h	2014-07-03 09:48:00.000000000 +0200
--- FN-CACTI/crossbar.h	2023-04-05 13:14:04.326088000 +0200
***************
*** 70,75 ****
--- 70,76 ----
      double tri_inp_cap, tri_out_cap, tri_ctr_cap, tri_int_cap;
  
    private:
+     double CB_ADJ;
      TechnologyParameter::DeviceType *deviceType;
      double TriS1, TriS2;
      double min_w_pmos, Vdd;
diff -crB pcacti_xml/decoder.cc FN-CACTI/decoder.cc
*** pcacti_xml/decoder.cc	2014-07-03 09:47:48.000000000 +0200
--- FN-CACTI/decoder.cc	2023-04-05 13:29:40.743774000 +0200
***************
*** 53,59 ****
      int    _num_dec_signals,
      bool   flag_way_select,
      double _C_ld_dec_out,
!     double _C_ld_dec_out_rd,
      double _R_wire_dec_out,
      bool   fully_assoc_,
      bool   is_dram_,
--- 53,59 ----
      int    _num_dec_signals,
      bool   flag_way_select,
      double _C_ld_dec_out,
! //    double _C_ld_dec_out_rd,
      double _R_wire_dec_out,
      bool   fully_assoc_,
      bool   is_dram_,
***************
*** 61,71 ****
      const  Area & cell_)
  :exist(false),
    C_ld_dec_out(_C_ld_dec_out),
!   C_ld_dec_out_rd(_C_ld_dec_out_rd),
    R_wire_dec_out(_R_wire_dec_out),
    num_gates(0), num_gates_rd(0), num_gates_min(2),
    delay(0), delay_rd(0),
!   power(), fully_assoc(fully_assoc_), is_dram(is_dram_),
    is_wl_tr(is_wl_tr_), cell(cell_)
  {
    for (int i = 0; i < MAX_NUMBER_GATES_STAGE; i++)
--- 61,72 ----
      const  Area & cell_)
  :exist(false),
    C_ld_dec_out(_C_ld_dec_out),
! //  C_ld_dec_out_rd(_C_ld_dec_out_rd),
    R_wire_dec_out(_R_wire_dec_out),
    num_gates(0), num_gates_rd(0), num_gates_min(2),
    delay(0), delay_rd(0),
!  // power(),
!   fully_assoc(fully_assoc_), is_dram(is_dram_),
    is_wl_tr(is_wl_tr_), cell(cell_)
  {
    for (int i = 0; i < MAX_NUMBER_GATES_STAGE; i++)
***************
*** 104,109 ****
--- 105,112 ----
      }
    }
  
+   assert(cell.h>0);
+   assert(cell.w>0);
    // the height of a row-decoder-driver cell is fixed to be 4 * cell.h;
    //area.h = 4 * cell.h;
    area.h = g_tp.h_dec * cell.h;
***************
*** 138,144 ****
        w_dec_p[0] = p_to_n_sz_ratio * g_tp.min_w_nmos_;
        g = gnand3;
      }
!     
      if (g_ip->sram_cell_design.getType()==std_8T && is_wl_tr) { // Alireza: this 'if-else', and the body of 'if' was added by me! 
        // row decoder for 8T SRAM cell has a DEMUX + WWL and RWL drivers
        w_nand_n = w_dec_n[0];
--- 141,147 ----
        w_dec_p[0] = p_to_n_sz_ratio * g_tp.min_w_nmos_;
        g = gnand3;
      }
! /*
      if (g_ip->sram_cell_design.getType()==std_8T && is_wl_tr) { // Alireza: this 'if-else', and the body of 'if' was added by me! 
        // row decoder for 8T SRAM cell has a DEMUX + WWL and RWL drivers
        w_nand_n = w_dec_n[0];
***************
*** 181,187 ****
            g_tp.max_w_nmos_dec);
        w_dec_n_rd[0] = w_nand_n; w_dec_p_rd[0] = w_nand_p; // returning the first gate to NAND gate for predecode calculation
      } else { // not the row decoder, or not using 8T SRAM cell
!       F = g * C_ld_dec_out / (gate_C(w_dec_n[0], 0, is_dram, false, is_wl_tr) +
                                gate_C(w_dec_p[0], 0, is_dram, false, is_wl_tr));
        num_gates = logical_effort(
            num_gates_min,
--- 184,191 ----
            g_tp.max_w_nmos_dec);
        w_dec_n_rd[0] = w_nand_n; w_dec_p_rd[0] = w_nand_p; // returning the first gate to NAND gate for predecode calculation
      } else { // not the row decoder, or not using 8T SRAM cell
! */
!     F = g * C_ld_dec_out / (gate_C(w_dec_n[0], 0, is_dram, false, is_wl_tr) +
                                gate_C(w_dec_p[0], 0, is_dram, false, is_wl_tr));
        num_gates = logical_effort(
            num_gates_min,
***************
*** 194,201 ****
            is_dram,
            is_wl_tr,
            g_tp.max_w_nmos_dec);
!     }
    }
  }
  
  
--- 198,210 ----
            is_dram,
            is_wl_tr,
            g_tp.max_w_nmos_dec);
! //    }
    }
+ /*  cout << "hdec: " << g_tp.h_dec << ", C_ld_dec_out: " << C_ld_dec_out <<
+ 		  ", (gate_C(w_dec_n[0], 0, is_dram, false, is_wl_tr): " << gate_C(w_dec_n[0], 0, is_dram, false, is_wl_tr) <<
+ 		", gate_C(w_dec_p[0], 0, is_dram, false, is_wl_tr): " << gate_C(w_dec_p[0], 0, is_dram, false, is_wl_tr) <<
+ 		", w_dec_n[0]: " << w_dec_n[0] << ", w_dec_p[0]: " << w_dec_p[0]
+ 		<< endl; */
  }
  
  
***************
*** 212,234 ****
      if (num_in_signals == 2)
      {
        cumulative_area = compute_gate_area(NAND, 2, w_dec_p[0], w_dec_n[0], area.h);  
!       cumulative_curr = cmos_Ileak(w_dec_n[0], w_dec_p[0], is_dram) * NAND2_LEAK_STACK_FACTOR;
      }
      else if (num_in_signals == 3)
      {
        cumulative_area = compute_gate_area(NAND, 3, w_dec_p[0], w_dec_n[0], area.h);
!       cumulative_curr = cmos_Ileak(w_dec_n[0], w_dec_p[0], is_dram) * NAND3_LEAK_STACK_FACTOR;
      }
  
      // Alireza: add area and leakage current of the WL (or WWL) driver
      for (int i = 1; i < num_gates; i++)
      {
        cumulative_area += compute_gate_area(INV, 1, w_dec_p[i], w_dec_n[i], area.h);
!       cumulative_curr += cmos_Ileak(w_dec_n[i], w_dec_p[i], is_dram) * INV_LEAK_STACK_FACTOR;
      }
      
!     // Alireza: add area and leakage current of the DEMUX (i.e., one NOR2 gate), and RWL driver
!     if (g_ip->sram_cell_design.getType()==std_8T && is_wl_tr) {
        double p_to_n_sz_ratio = pmos_to_nmos_sz_ratio(is_dram, is_wl_tr);
        double w_nor_n = g_tp.min_w_nmos_;
        double w_nor_p = 2 * p_to_n_sz_ratio * g_tp.min_w_nmos_;
--- 220,248 ----
      if (num_in_signals == 2)
      {
        cumulative_area = compute_gate_area(NAND, 2, w_dec_p[0], w_dec_n[0], area.h);  
! //      cumulative_curr = cmos_Ileak(w_dec_n[0], w_dec_p[0], is_dram) * NAND2_LEAK_STACK_FACTOR;
!       cumulative_curr = cmos_Isub_leakage(w_dec_n[0], w_dec_p[0], 2, nand,is_dram);
! //      cout << "cumulative_area1: " << cumulative_area << ", h: " << area.h << endl;
      }
      else if (num_in_signals == 3)
      {
        cumulative_area = compute_gate_area(NAND, 3, w_dec_p[0], w_dec_n[0], area.h);
! //      cumulative_curr = cmos_Ileak(w_dec_n[0], w_dec_p[0], is_dram) * NAND3_LEAK_STACK_FACTOR;
!       cumulative_curr = cmos_Isub_leakage(w_dec_n[0], w_dec_p[0], 3, nand, is_dram);;
! //      cout << "cumulative_area2: " << cumulative_area << ", h: " << area.h << endl;
      }
  
      // Alireza: add area and leakage current of the WL (or WWL) driver
      for (int i = 1; i < num_gates; i++)
      {
        cumulative_area += compute_gate_area(INV, 1, w_dec_p[i], w_dec_n[i], area.h);
! //      cumulative_curr += cmos_Ileak(w_dec_n[i], w_dec_p[i], is_dram) * INV_LEAK_STACK_FACTOR;
!       cumulative_curr += cmos_Isub_leakage(w_dec_n[i], w_dec_p[i], 1, inv, is_dram);
!  //     cout << "cumulative_area3: " << cumulative_area << ", h: " << area.h << endl;
      }
      
! /*    // Alireza: add area and leakage current of the DEMUX (i.e., one NOR2 gate), and RWL driver
!     if (g_ip->sram_cell_design.getType()==std_8T && is_wl_tr ) {
        double p_to_n_sz_ratio = pmos_to_nmos_sz_ratio(is_dram, is_wl_tr);
        double w_nor_n = g_tp.min_w_nmos_;
        double w_nor_p = 2 * p_to_n_sz_ratio * g_tp.min_w_nmos_;
***************
*** 239,247 ****
          cumulative_curr += cmos_Ileak(w_dec_n_rd[i], w_dec_p_rd[i], is_dram) * INV_LEAK_STACK_FACTOR;
        }
      }
!     
      power.readOp.leakage = cumulative_curr * g_tp.peri_global.Vdd;
      area.w = (cumulative_area / area.h);
    }
  }
  
--- 253,262 ----
          cumulative_curr += cmos_Ileak(w_dec_n_rd[i], w_dec_p_rd[i], is_dram) * INV_LEAK_STACK_FACTOR;
        }
      }
!  */
      power.readOp.leakage = cumulative_curr * g_tp.peri_global.Vdd;
      area.w = (cumulative_area / area.h);
+ //    cout << "cumulative_area: " << cumulative_area << ", h: " << area.h << endl;
    }
  }
  
***************
*** 276,303 ****
      
      // Alireza: add delay of the decoder (one NAND2, or one NAND3)
      rd = tr_R_on(w_dec_n[0], NCH, num_in_signals, is_dram, false, is_wl_tr);
!     if (g_ip->sram_cell_design.getType()==std_8T && is_wl_tr) { // Alireza
        // Alireza: for this case, load of the decoder is the DEMUX (a NOR gate)
        c_load = gate_C(w_nor_n + w_nor_p, 0.0, is_dram, false, is_wl_tr); // Alireza
      } else { // Alireza
!       c_load = gate_C(w_dec_n[1] + w_dec_p[1], 0.0, is_dram, false, is_wl_tr);
!     } // Alireza
      c_intrinsic = drain_C_(w_dec_p[0], PCH, 1, 1, area.h, is_dram, false, is_wl_tr) * num_in_signals + 
                    drain_C_(w_dec_n[0], NCH, num_in_signals, 1, area.h, is_dram, false, is_wl_tr);
      tf = rd * (c_intrinsic + c_load);
      this_delay = horowitz(inrisetime, tf, 0.5, 0.5, RISE);
      delay += this_delay;
      inrisetime = this_delay / (1.0 - 0.5);  
!     if (g_ip->sram_cell_design.getType()==std_8T && is_wl_tr) { // Alireza
        power.readOp.dynamic += (c_load + c_intrinsic) * Vdd * Vdd; // Alireza
        power.writeOp.dynamic += power.readOp.dynamic; // Alireza
        delay_rd += delay; // Alireza
      } else { // Alireza
!       power.readOp.dynamic += (c_load + c_intrinsic) * Vdd * Vdd;
!     } // Alireza
      
      // Alireza: add delay of DEMUX (one NOR2 gate)
!     if (g_ip->sram_cell_design.getType()==std_8T && is_wl_tr) { // Alireza: this 'if' is added by me!
        rd = tr_R_on(w_nor_n, NCH, 2, is_dram, false, is_wl_tr);
        c_load = gate_C(w_dec_n[1] + w_dec_p[1], 0.0, is_dram, false, is_wl_tr);
        c_intrinsic = drain_C_(w_nor_p, PCH, 2, 1, area.h, is_dram, false, is_wl_tr) + 
--- 291,318 ----
      
      // Alireza: add delay of the decoder (one NAND2, or one NAND3)
      rd = tr_R_on(w_dec_n[0], NCH, num_in_signals, is_dram, false, is_wl_tr);
! /*    if (g_ip->sram_cell_design.getType()==std_8T && is_wl_tr) { // Alireza
        // Alireza: for this case, load of the decoder is the DEMUX (a NOR gate)
        c_load = gate_C(w_nor_n + w_nor_p, 0.0, is_dram, false, is_wl_tr); // Alireza
      } else { // Alireza
! */      c_load = gate_C(w_dec_n[1] + w_dec_p[1], 0.0, is_dram, false, is_wl_tr);
! //    } // Alireza
      c_intrinsic = drain_C_(w_dec_p[0], PCH, 1, 1, area.h, is_dram, false, is_wl_tr) * num_in_signals + 
                    drain_C_(w_dec_n[0], NCH, num_in_signals, 1, area.h, is_dram, false, is_wl_tr);
      tf = rd * (c_intrinsic + c_load);
      this_delay = horowitz(inrisetime, tf, 0.5, 0.5, RISE);
      delay += this_delay;
      inrisetime = this_delay / (1.0 - 0.5);  
! /*    if (g_ip->sram_cell_design.getType()==std_8T && is_wl_tr) { // Alireza
        power.readOp.dynamic += (c_load + c_intrinsic) * Vdd * Vdd; // Alireza
        power.writeOp.dynamic += power.readOp.dynamic; // Alireza
        delay_rd += delay; // Alireza
      } else { // Alireza
! */      power.readOp.dynamic += (c_load + c_intrinsic) * Vdd * Vdd;
! //    } // Alireza
      
      // Alireza: add delay of DEMUX (one NOR2 gate)
! /*    if (g_ip->sram_cell_design.getType()==std_8T && is_wl_tr) { // Alireza: this 'if' is added by me!
        rd = tr_R_on(w_nor_n, NCH, 2, is_dram, false, is_wl_tr);
        c_load = gate_C(w_dec_n[1] + w_dec_p[1], 0.0, is_dram, false, is_wl_tr);
        c_intrinsic = drain_C_(w_nor_p, PCH, 2, 1, area.h, is_dram, false, is_wl_tr) + 
***************
*** 308,316 ****
        inrisetime = this_delay / (1.0 - 0.5);  
        power.writeOp.dynamic += (c_load + c_intrinsic) * Vdd * Vdd;
      }
!     
      // Alireza: add delay of WL (or WWL) driver
!     for (i = 1; i < num_gates - 1; ++i)
      {
        rd = tr_R_on(w_dec_n[i], NCH, 1, is_dram, false, is_wl_tr);
        c_load = gate_C(w_dec_p[i+1] + w_dec_n[i+1], 0.0, is_dram, false, is_wl_tr);
--- 323,332 ----
        inrisetime = this_delay / (1.0 - 0.5);  
        power.writeOp.dynamic += (c_load + c_intrinsic) * Vdd * Vdd;
      }
! */
      // Alireza: add delay of WL (or WWL) driver
! 
! 	for (i = 1; i < num_gates - 1; ++i)
      {
        rd = tr_R_on(w_dec_n[i], NCH, 1, is_dram, false, is_wl_tr);
        c_load = gate_C(w_dec_p[i+1] + w_dec_n[i+1], 0.0, is_dram, false, is_wl_tr);
***************
*** 320,330 ****
        this_delay = horowitz(inrisetime, tf, 0.5, 0.5, RISE);
        delay += this_delay;
        inrisetime = this_delay / (1.0 - 0.5);
!       if (g_ip->sram_cell_design.getType()==std_8T && is_wl_tr) { // Alireza
          power.writeOp.dynamic += (c_load + c_intrinsic) * Vdd * Vdd; // Alireza
        } else { // Alireza
!         power.readOp.dynamic += (c_load + c_intrinsic) * Vdd * Vdd;
!       } // Alireza
      }
  
      // add delay of final inverter that drives the wordline (WL, or WWL)
--- 336,346 ----
        this_delay = horowitz(inrisetime, tf, 0.5, 0.5, RISE);
        delay += this_delay;
        inrisetime = this_delay / (1.0 - 0.5);
! /*      if (g_ip->sram_cell_design.getType()==std_8T && is_wl_tr) { // Alireza
          power.writeOp.dynamic += (c_load + c_intrinsic) * Vdd * Vdd; // Alireza
        } else { // Alireza
! */        power.readOp.dynamic += (c_load + c_intrinsic) * Vdd * Vdd;
!  //     } // Alireza
      }
  
      // add delay of final inverter that drives the wordline (WL, or WWL)
***************
*** 337,351 ****
      this_delay = horowitz(inrisetime, tf, 0.5, 0.5, RISE);
      delay  += this_delay;
      ret_val = this_delay / (1.0 - 0.5);
!     if (g_ip->sram_cell_design.getType()==std_8T && is_wl_tr) { // Alireza
        power.writeOp.dynamic += c_load * Vpp * Vpp + c_intrinsic * Vdd * Vdd; // Alireza
      } else { // Alireza
!       power.readOp.dynamic += c_load * Vpp * Vpp + c_intrinsic * Vdd * Vdd;
!     } // Alireza
      
      
      // Alireza: add delay of RWL driver
!     if (g_ip->sram_cell_design.getType()==std_8T && is_wl_tr) { // Alireza: this 'if' is added by me!
        // add delay of DEMUX (one NOR2 gate)
        rd = tr_R_on(w_nor_n, NCH, 2, is_dram, false, is_wl_tr);
        c_load = gate_C(w_dec_n_rd[1] + w_dec_p_rd[1], 0.0, is_dram, false, is_wl_tr);
--- 353,367 ----
      this_delay = horowitz(inrisetime, tf, 0.5, 0.5, RISE);
      delay  += this_delay;
      ret_val = this_delay / (1.0 - 0.5);
! /*    if (g_ip->sram_cell_design.getType()==std_8T && is_wl_tr) { // Alireza
        power.writeOp.dynamic += c_load * Vpp * Vpp + c_intrinsic * Vdd * Vdd; // Alireza
      } else { // Alireza
! */      power.readOp.dynamic += c_load * Vpp * Vpp + c_intrinsic * Vdd * Vdd;
! //    } // Alireza
      
      
      // Alireza: add delay of RWL driver
! /*    if (g_ip->sram_cell_design.getType()==std_8T && is_wl_tr) { // Alireza: this 'if' is added by me!
        // add delay of DEMUX (one NOR2 gate)
        rd = tr_R_on(w_nor_n, NCH, 2, is_dram, false, is_wl_tr);
        c_load = gate_C(w_dec_n_rd[1] + w_dec_p_rd[1], 0.0, is_dram, false, is_wl_tr);
***************
*** 383,389 ****
        ret_val = this_delay / (1.0 - 0.5); // Alireza: for 8T SRAM cell return read wordline delay
        power.readOp.dynamic += c_load * Vpp * Vpp + c_intrinsic * Vdd * Vdd;
      }
!     
      return ret_val;
    }
    else
--- 399,405 ----
        ret_val = this_delay / (1.0 - 0.5); // Alireza: for 8T SRAM cell return read wordline delay
        power.readOp.dynamic += c_load * Vpp * Vpp + c_intrinsic * Vdd * Vdd;
      }
! */
      return ret_val;
    }
    else
***************
*** 392,397 ****
--- 408,441 ----
    }
  }
  
+ void Decoder::leakage_feedback(double temperature)
+ {
+   double cumulative_curr = 0;  // cumulative leakage current
+   double cumulative_curr_Ig = 0;  // cumulative leakage current
+ 
+   if (exist)
+   { // First check if this decoder exists
+     if (num_in_signals == 2)
+     {
+       cumulative_curr = cmos_Isub_leakage(w_dec_n[0], w_dec_p[0], 2, nand,is_dram);
+       cumulative_curr_Ig = cmos_Ig_leakage(w_dec_n[0], w_dec_p[0], 2, nand,is_dram);
+     }
+     else if (num_in_signals == 3)
+     {
+       cumulative_curr = cmos_Isub_leakage(w_dec_n[0], w_dec_p[0], 3, nand, is_dram);;
+       cumulative_curr_Ig = cmos_Ig_leakage(w_dec_n[0], w_dec_p[0], 3, nand, is_dram);
+     }
+ 
+     for (int i = 1; i < num_gates; i++)
+     {
+       cumulative_curr += cmos_Isub_leakage(w_dec_n[i], w_dec_p[i], 1, inv, is_dram);
+       cumulative_curr_Ig = cmos_Ig_leakage(w_dec_n[i], w_dec_p[i], 1, inv, is_dram);
+     }
+ 
+     power.readOp.leakage = cumulative_curr * g_tp.peri_global.Vdd;
+     power.readOp.gate_leakage = cumulative_curr_Ig * g_tp.peri_global.Vdd;
+   }
+ }
  
  
  PredecBlk::PredecBlk(
***************
*** 417,422 ****
--- 461,468 ----
    number_gates_L2(0),
    min_number_gates_L1(2),
    min_number_gates_L2(2),
+   num_L1_active_nand2_path(0),
+   num_L1_active_nand3_path(0),
    delay_nand2_path(0),
    delay_nand3_path(0),
    power_nand2_path(),
***************
*** 629,635 ****
      {
        w_L1_nand2_n[0] = 2 * g_tp.min_w_nmos_;
        w_L1_nand2_p[0] = p_to_n_sz_ratio * g_tp.min_w_nmos_;
!       F = C_ld_predec_blk_out / 
          (gate_C(w_L1_nand2_n[0], 0, is_dram_) +
           gate_C(w_L1_nand2_p[0], 0, is_dram_));
        number_gates_L1_nand2_path = logical_effort(
--- 675,681 ----
      {
        w_L1_nand2_n[0] = 2 * g_tp.min_w_nmos_;
        w_L1_nand2_p[0] = p_to_n_sz_ratio * g_tp.min_w_nmos_;
!       F = gnand2*C_ld_predec_blk_out /
          (gate_C(w_L1_nand2_n[0], 0, is_dram_) +
           gate_C(w_L1_nand2_p[0], 0, is_dram_));
        number_gates_L1_nand2_path = logical_effort(
***************
*** 647,653 ****
      {
        w_L1_nand3_n[0] = 3 * g_tp.min_w_nmos_;
        w_L1_nand3_p[0] = p_to_n_sz_ratio * g_tp.min_w_nmos_;
!       F = C_ld_predec_blk_out / 
          (gate_C(w_L1_nand3_n[0], 0, is_dram_) +
           gate_C(w_L1_nand3_p[0], 0, is_dram_));
        number_gates_L1_nand3_path = logical_effort(
--- 693,699 ----
      {
        w_L1_nand3_n[0] = 3 * g_tp.min_w_nmos_;
        w_L1_nand3_p[0] = p_to_n_sz_ratio * g_tp.min_w_nmos_;
!       F = gnand3*C_ld_predec_blk_out /
          (gate_C(w_L1_nand3_n[0], 0, is_dram_) +
           gate_C(w_L1_nand3_p[0], 0, is_dram_));
        number_gates_L1_nand3_path = logical_effort(
***************
*** 678,691 ****
  
      // First check whether a predecoder block is needed
      double tot_area_L1_nand2 = compute_gate_area(NAND, 2, w_L1_nand2_p[0], w_L1_nand2_n[0], g_tp.cell_h_def); 
!     double leak_L1_nand2 = cmos_Ileak(w_L1_nand2_n[0], w_L1_nand2_p[0], is_dram_) * NAND2_LEAK_STACK_FACTOR;
      if (number_inputs_L1_gate != 3) {
        tot_area_L1_nand3 = 0;
        leak_L1_nand3 = 0;
      }
      else {
        tot_area_L1_nand3 = compute_gate_area(NAND, 3, w_L1_nand3_p[0], w_L1_nand3_n[0], g_tp.cell_h_def);
!       leak_L1_nand3 = cmos_Ileak(w_L1_nand3_n[0], w_L1_nand3_p[0], is_dram_) * NAND3_LEAK_STACK_FACTOR;
      }
  
      switch (number_input_addr_bits)
--- 724,739 ----
  
      // First check whether a predecoder block is needed
      double tot_area_L1_nand2 = compute_gate_area(NAND, 2, w_L1_nand2_p[0], w_L1_nand2_n[0], g_tp.cell_h_def); 
! //    double leak_L1_nand2 = cmos_Ileak(w_L1_nand2_n[0], w_L1_nand2_p[0], is_dram_) * NAND2_LEAK_STACK_FACTOR;
!     double leak_L1_nand2      = cmos_Isub_leakage(w_L1_nand2_n[0], w_L1_nand2_p[0], 2, nand, is_dram_);
      if (number_inputs_L1_gate != 3) {
        tot_area_L1_nand3 = 0;
        leak_L1_nand3 = 0;
      }
      else {
        tot_area_L1_nand3 = compute_gate_area(NAND, 3, w_L1_nand3_p[0], w_L1_nand3_n[0], g_tp.cell_h_def);
! //      leak_L1_nand3 = cmos_Ileak(w_L1_nand3_n[0], w_L1_nand3_p[0], is_dram_) * NAND3_LEAK_STACK_FACTOR;
!       leak_L1_nand3      = cmos_Isub_leakage(w_L1_nand3_n[0], w_L1_nand3_p[0], 3, nand);
      }
  
      switch (number_input_addr_bits)
***************
*** 693,733 ****
--- 741,799 ----
        case 1: //2 NAND2 gates
          num_L1_nand2 = 2;
          num_L2       = 0;
+         num_L1_active_nand2_path =1;
+         num_L1_active_nand3_path =0;
          break;
        case 2: //4 NAND2 gates
          num_L1_nand2 = 4;
          num_L2       = 0;
+         num_L1_active_nand2_path =1;
+         num_L1_active_nand3_path =0;
          break;
        case 3: //8 NAND3 gates
          num_L1_nand3 = 8;
          num_L2       = 0;
+         num_L1_active_nand2_path =0;
+         num_L1_active_nand3_path =1;
          break;
        case 4: //4 + 4 NAND2 gates
          num_L1_nand2 = 8;
          num_L2       = 16;
+         num_L1_active_nand2_path =2;
+         num_L1_active_nand3_path =0;
          break;
        case 5: //4 NAND2 gates, 8 NAND3 gates
          num_L1_nand2 = 4;
          num_L1_nand3 = 8;
          num_L2       = 32;
+         num_L1_active_nand2_path =1;
+         num_L1_active_nand3_path =1;
          break;
        case 6: //8 + 8 NAND3 gates
          num_L1_nand3 = 16;
          num_L2       = 64;
+         num_L1_active_nand2_path =0;
+         num_L1_active_nand3_path =2;
          break;
        case 7: //4 + 4 NAND2 gates, 8 NAND3 gates
          num_L1_nand2 = 8;
          num_L1_nand3 = 8;
          num_L2       = 128;
+         num_L1_active_nand2_path =2;
+         num_L1_active_nand3_path =1;
          break;
        case 8: //4 NAND2 gates, 8 + 8 NAND3 gates
          num_L1_nand2 = 4;
          num_L1_nand3 = 16;
          num_L2       = 256;
+         num_L1_active_nand2_path =2;
+         num_L1_active_nand3_path =2;
          break;
        case 9: //8 + 8 + 8 NAND3 gates
          num_L1_nand3 = 24;
          num_L2       = 512;
+         num_L1_active_nand2_path =0;
+         num_L1_active_nand3_path =3;
          break;
        default:
          break;
***************
*** 736,742 ****
      for (int i = 1; i < number_gates_L1_nand2_path; ++i)
      {
        tot_area_L1_nand2 += compute_gate_area(INV, 1, w_L1_nand2_p[i], w_L1_nand2_n[i], g_tp.cell_h_def);  
!       leak_L1_nand2 += cmos_Ileak(w_L1_nand2_n[i], w_L1_nand2_p[i], is_dram_) * INV_LEAK_STACK_FACTOR;
      }
      tot_area_L1_nand2 *= num_L1_nand2;
      leak_L1_nand2     *= num_L1_nand2;
--- 802,809 ----
      for (int i = 1; i < number_gates_L1_nand2_path; ++i)
      {
        tot_area_L1_nand2 += compute_gate_area(INV, 1, w_L1_nand2_p[i], w_L1_nand2_n[i], g_tp.cell_h_def);  
! //      leak_L1_nand2 += cmos_Ileak(w_L1_nand2_n[i], w_L1_nand2_p[i], is_dram_) * INV_LEAK_STACK_FACTOR;
!       leak_L1_nand2      += cmos_Isub_leakage(w_L1_nand2_n[i], w_L1_nand2_p[i], 2, nand, is_dram_);
      }
      tot_area_L1_nand2 *= num_L1_nand2;
      leak_L1_nand2     *= num_L1_nand2;
***************
*** 744,750 ****
      for (int i = 1; i < number_gates_L1_nand3_path; ++i)
      {
        tot_area_L1_nand3 += compute_gate_area(INV, 1, w_L1_nand3_p[i], w_L1_nand3_n[i], g_tp.cell_h_def); 
!       leak_L1_nand3 += cmos_Ileak(w_L1_nand3_n[i], w_L1_nand3_p[i], is_dram_) * INV_LEAK_STACK_FACTOR;
      }
      tot_area_L1_nand3 *= num_L1_nand3;
      leak_L1_nand3     *= num_L1_nand3;
--- 811,818 ----
      for (int i = 1; i < number_gates_L1_nand3_path; ++i)
      {
        tot_area_L1_nand3 += compute_gate_area(INV, 1, w_L1_nand3_p[i], w_L1_nand3_n[i], g_tp.cell_h_def); 
! //      leak_L1_nand3 += cmos_Ileak(w_L1_nand3_n[i], w_L1_nand3_p[i], is_dram_) * INV_LEAK_STACK_FACTOR;
!       leak_L1_nand3      += cmos_Isub_leakage(w_L1_nand3_n[i], w_L1_nand3_p[i], 3, nand, is_dram_);
      }
      tot_area_L1_nand3 *= num_L1_nand3;
      leak_L1_nand3     *= num_L1_nand3;
***************
*** 756,773 ****
      if (flag_L2_gate == 2)
      {
        cumulative_area_L2 = compute_gate_area(NAND, 2, w_L2_p[0], w_L2_n[0], g_tp.cell_h_def); 
!       leakage_L2         = cmos_Ileak(w_L2_n[0], w_L2_p[0], is_dram_) * NAND2_LEAK_STACK_FACTOR;
      }
      else if (flag_L2_gate == 3)
      {
        cumulative_area_L2 = compute_gate_area(NAND, 3, w_L2_p[0], w_L2_n[0], g_tp.cell_h_def);
!       leakage_L2         = cmos_Ileak(w_L2_n[0], w_L2_p[0], is_dram_) * NAND3_LEAK_STACK_FACTOR;
      }
  
      for (int i = 1; i < number_gates_L2; ++i)
      {
        cumulative_area_L2 += compute_gate_area(INV, 1, w_L2_p[i], w_L2_n[i], g_tp.cell_h_def); 
!       leakage_L2         += cmos_Ileak(w_L2_n[i], w_L2_p[i], is_dram_) * INV_LEAK_STACK_FACTOR;
      }
      cumulative_area_L2 *= num_L2;
      leakage_L2         *= num_L2;
--- 824,844 ----
      if (flag_L2_gate == 2)
      {
        cumulative_area_L2 = compute_gate_area(NAND, 2, w_L2_p[0], w_L2_n[0], g_tp.cell_h_def); 
! //      leakage_L2         = cmos_Ileak(w_L2_n[0], w_L2_p[0], is_dram_) * NAND2_LEAK_STACK_FACTOR;
!       leakage_L2         = cmos_Isub_leakage(w_L2_n[0], w_L2_p[0], 2, nand, is_dram_);
      }
      else if (flag_L2_gate == 3)
      {
        cumulative_area_L2 = compute_gate_area(NAND, 3, w_L2_p[0], w_L2_n[0], g_tp.cell_h_def);
! //      leakage_L2         = cmos_Ileak(w_L2_n[0], w_L2_p[0], is_dram_) * NAND3_LEAK_STACK_FACTOR;
!       leakage_L2         = cmos_Isub_leakage(w_L2_n[0], w_L2_p[0], 3, nand, is_dram_);
      }
  
      for (int i = 1; i < number_gates_L2; ++i)
      {
        cumulative_area_L2 += compute_gate_area(INV, 1, w_L2_p[i], w_L2_n[i], g_tp.cell_h_def); 
! //      leakage_L2         += cmos_Ileak(w_L2_n[i], w_L2_p[i], is_dram_) * INV_LEAK_STACK_FACTOR;
!       leakage_L2         += cmos_Isub_leakage(w_L2_n[i], w_L2_p[i], 2, inv, is_dram_);
      }
      cumulative_area_L2 *= num_L2;
      leakage_L2         *= num_L2;
***************
*** 973,978 ****
--- 1044,1180 ----
    return ret_val;
  }
  
+ void PredecBlk::leakage_feedback(double temperature)
+ {
+   if (exist)
+   { // First check whether a predecoder block is needed
+     int num_L1_nand2 = 0;
+     int num_L1_nand3 = 0;
+     int num_L2 = 0;
+     double leak_L1_nand3      =0;
+     double gate_leak_L1_nand3 =0;
+ 
+     double leak_L1_nand2      = cmos_Isub_leakage(w_L1_nand2_n[0], w_L1_nand2_p[0], 2, nand, is_dram_);
+     double gate_leak_L1_nand2 = cmos_Ig_leakage(w_L1_nand2_n[0], w_L1_nand2_p[0], 2, nand, is_dram_);
+     if (number_inputs_L1_gate != 3) {
+       leak_L1_nand3 = 0;
+       gate_leak_L1_nand3 =0;
+     }
+     else {
+       leak_L1_nand3      = cmos_Isub_leakage(w_L1_nand3_n[0], w_L1_nand3_p[0], 3, nand);
+       gate_leak_L1_nand3 = cmos_Ig_leakage(w_L1_nand3_n[0], w_L1_nand3_p[0], 3, nand);
+     }
+ 
+     switch (number_input_addr_bits)
+     {
+       case 1: //2 NAND2 gates
+         num_L1_nand2 = 2;
+         num_L2       = 0;
+         num_L1_active_nand2_path =1;
+         num_L1_active_nand3_path =0;
+         break;
+       case 2: //4 NAND2 gates
+         num_L1_nand2 = 4;
+         num_L2       = 0;
+         num_L1_active_nand2_path =1;
+         num_L1_active_nand3_path =0;
+         break;
+       case 3: //8 NAND3 gates
+         num_L1_nand3 = 8;
+         num_L2       = 0;
+         num_L1_active_nand2_path =0;
+         num_L1_active_nand3_path =1;
+         break;
+       case 4: //4 + 4 NAND2 gates
+         num_L1_nand2 = 8;
+         num_L2       = 16;
+         num_L1_active_nand2_path =2;
+         num_L1_active_nand3_path =0;
+         break;
+       case 5: //4 NAND2 gates, 8 NAND3 gates
+         num_L1_nand2 = 4;
+         num_L1_nand3 = 8;
+         num_L2       = 32;
+         num_L1_active_nand2_path =1;
+         num_L1_active_nand3_path =1;
+         break;
+       case 6: //8 + 8 NAND3 gates
+         num_L1_nand3 = 16;
+         num_L2       = 64;
+         num_L1_active_nand2_path =0;
+         num_L1_active_nand3_path =2;
+         break;
+       case 7: //4 + 4 NAND2 gates, 8 NAND3 gates
+         num_L1_nand2 = 8;
+         num_L1_nand3 = 8;
+         num_L2       = 128;
+         num_L1_active_nand2_path =2;
+         num_L1_active_nand3_path =1;
+         break;
+       case 8: //4 NAND2 gates, 8 + 8 NAND3 gates
+         num_L1_nand2 = 4;
+         num_L1_nand3 = 16;
+         num_L2       = 256;
+         num_L1_active_nand2_path =2;
+         num_L1_active_nand3_path =2;
+         break;
+       case 9: //8 + 8 + 8 NAND3 gates
+         num_L1_nand3 = 24;
+         num_L2       = 512;
+         num_L1_active_nand2_path =0;
+         num_L1_active_nand3_path =3;
+         break;
+       default:
+         break;
+     }
+ 
+     for (int i = 1; i < number_gates_L1_nand2_path; ++i)
+     {
+       leak_L1_nand2      += cmos_Isub_leakage(w_L1_nand2_n[i], w_L1_nand2_p[i], 2, nand, is_dram_);
+       gate_leak_L1_nand2 += cmos_Ig_leakage(w_L1_nand2_n[i], w_L1_nand2_p[i], 2, nand, is_dram_);
+     }
+     leak_L1_nand2      *= num_L1_nand2;
+     gate_leak_L1_nand2 *= num_L1_nand2;
+ 
+     for (int i = 1; i < number_gates_L1_nand3_path; ++i)
+     {
+       leak_L1_nand3      += cmos_Isub_leakage(w_L1_nand3_n[i], w_L1_nand3_p[i], 3, nand, is_dram_);
+       gate_leak_L1_nand3 += cmos_Ig_leakage(w_L1_nand3_n[i], w_L1_nand3_p[i], 3, nand, is_dram_);
+     }
+     leak_L1_nand3      *= num_L1_nand3;
+     gate_leak_L1_nand3 *= num_L1_nand3;
+ 
+     double leakage_L2         = 0.0;
+     double gate_leakage_L2    = 0.0;
+ 
+     if (flag_L2_gate == 2)
+     {
+       leakage_L2         = cmos_Isub_leakage(w_L2_n[0], w_L2_p[0], 2, nand, is_dram_);
+       gate_leakage_L2    = cmos_Ig_leakage(w_L2_n[0], w_L2_p[0], 2, nand, is_dram_);
+     }
+     else if (flag_L2_gate == 3)
+     {
+       leakage_L2         = cmos_Isub_leakage(w_L2_n[0], w_L2_p[0], 3, nand, is_dram_);
+       gate_leakage_L2    = cmos_Ig_leakage(w_L2_n[0], w_L2_p[0], 3, nand, is_dram_);
+     }
+ 
+     for (int i = 1; i < number_gates_L2; ++i)
+     {
+       leakage_L2         += cmos_Isub_leakage(w_L2_n[i], w_L2_p[i], 2, inv, is_dram_);
+       gate_leakage_L2    += cmos_Ig_leakage(w_L2_n[i], w_L2_p[i], 2, inv, is_dram_);
+     }
+     leakage_L2         *= num_L2;
+     gate_leakage_L2    *= num_L2;
+ 
+     power_nand2_path.readOp.leakage = leak_L1_nand2 * g_tp.peri_global.Vdd;
+     power_nand3_path.readOp.leakage = leak_L1_nand3 * g_tp.peri_global.Vdd;
+     power_L2.readOp.leakage         = leakage_L2    * g_tp.peri_global.Vdd;
+ 
+     power_nand2_path.readOp.gate_leakage = gate_leak_L1_nand2 * g_tp.peri_global.Vdd;
+     power_nand3_path.readOp.gate_leakage = gate_leak_L1_nand3 * g_tp.peri_global.Vdd;
+     power_L2.readOp.gate_leakage         = gate_leakage_L2    * g_tp.peri_global.Vdd;
+   }
+ }
  
  
  PredecBlkDrv::PredecBlkDrv(
***************
*** 1162,1168 ****
      for (int i = 0; i < number_gates_nand2_path; ++i)
      {
        area_nand2_path += compute_gate_area(INV, 1, width_nand2_path_p[i], width_nand2_path_n[i], g_tp.cell_h_def); 
!       leak_nand2_path += cmos_Ileak(width_nand2_path_n[i], width_nand2_path_p[i], is_dram_) * INV_LEAK_STACK_FACTOR;
      }
      area_nand2_path *= (num_buffers_driving_1_nand2_load +
                          num_buffers_driving_2_nand2_load +
--- 1363,1370 ----
      for (int i = 0; i < number_gates_nand2_path; ++i)
      {
        area_nand2_path += compute_gate_area(INV, 1, width_nand2_path_p[i], width_nand2_path_n[i], g_tp.cell_h_def); 
! //      leak_nand2_path += cmos_Ileak(width_nand2_path_n[i], width_nand2_path_p[i], is_dram_) * INV_LEAK_STACK_FACTOR;
!       leak_nand2_path += cmos_Isub_leakage(width_nand2_path_n[i], width_nand2_path_p[i], 1, inv,is_dram_);
      }
      area_nand2_path *= (num_buffers_driving_1_nand2_load +
                          num_buffers_driving_2_nand2_load +
***************
*** 1174,1180 ****
      for (int i = 0; i < number_gates_nand3_path; ++i)
      {
        area_nand3_path += compute_gate_area(INV, 1, width_nand3_path_p[i], width_nand3_path_n[i], g_tp.cell_h_def); 
!       leak_nand3_path += cmos_Ileak(width_nand3_path_n[i], width_nand3_path_p[i], is_dram_) * INV_LEAK_STACK_FACTOR;
      }
      area_nand3_path *= (num_buffers_driving_2_nand3_load + num_buffers_driving_8_nand3_load);
      leak_nand3_path *= (num_buffers_driving_2_nand3_load + num_buffers_driving_8_nand3_load);
--- 1376,1383 ----
      for (int i = 0; i < number_gates_nand3_path; ++i)
      {
        area_nand3_path += compute_gate_area(INV, 1, width_nand3_path_p[i], width_nand3_path_n[i], g_tp.cell_h_def); 
! //      leak_nand3_path += cmos_Ileak(width_nand3_path_n[i], width_nand3_path_p[i], is_dram_) * INV_LEAK_STACK_FACTOR;
!       leak_nand3_path += cmos_Isub_leakage(width_nand3_path_n[i], width_nand3_path_p[i], 1, inv,is_dram_);
      }
      area_nand3_path *= (num_buffers_driving_2_nand3_load + num_buffers_driving_8_nand3_load);
      leak_nand3_path *= (num_buffers_driving_2_nand3_load + num_buffers_driving_8_nand3_load);
***************
*** 1266,1271 ****
--- 1469,1509 ----
            num_addr_bits_nand3_path()*power_nand3_path.readOp.dynamic) * num_act_mats_hor_dir;
  }
  
+ void PredecBlkDrv::leakage_feedback(double temperature)
+ {
+   double leak_nand2_path = 0;
+   double leak_nand3_path = 0;
+   double gate_leak_nand2_path = 0;
+   double gate_leak_nand3_path = 0;
+ 
+   if (flag_driver_exists)
+   { // first check whether a predecoder block driver is needed
+     for (int i = 0; i < number_gates_nand2_path; ++i)
+     {
+       leak_nand2_path += cmos_Isub_leakage(width_nand2_path_n[i], width_nand2_path_p[i], 1, inv,is_dram_);
+       gate_leak_nand2_path += cmos_Ig_leakage(width_nand2_path_n[i], width_nand2_path_p[i], 1, inv,is_dram_);
+     }
+     leak_nand2_path *= (num_buffers_driving_1_nand2_load +
+                         num_buffers_driving_2_nand2_load +
+                         num_buffers_driving_4_nand2_load);
+     gate_leak_nand2_path *= (num_buffers_driving_1_nand2_load +
+                             num_buffers_driving_2_nand2_load +
+                             num_buffers_driving_4_nand2_load);
+ 
+     for (int i = 0; i < number_gates_nand3_path; ++i)
+     {
+       leak_nand3_path += cmos_Isub_leakage(width_nand3_path_n[i], width_nand3_path_p[i], 1, inv,is_dram_);
+       gate_leak_nand3_path += cmos_Ig_leakage(width_nand3_path_n[i], width_nand3_path_p[i], 1, inv,is_dram_);
+     }
+     leak_nand3_path *= (num_buffers_driving_2_nand3_load + num_buffers_driving_8_nand3_load);
+     gate_leak_nand3_path *= (num_buffers_driving_2_nand3_load + num_buffers_driving_8_nand3_load);
+ 
+     power_nand2_path.readOp.leakage = leak_nand2_path * g_tp.peri_global.Vdd;
+     power_nand3_path.readOp.leakage = leak_nand3_path * g_tp.peri_global.Vdd;
+     power_nand2_path.readOp.gate_leakage = gate_leak_nand2_path * g_tp.peri_global.Vdd;
+     power_nand3_path.readOp.gate_leakage = gate_leak_nand3_path * g_tp.peri_global.Vdd;
+   }
+ }
  
  
  Predec::Predec(
***************
*** 1305,1316 ****
      drv2->num_addr_bits_nand3_path() * drv2->power_nand3_path.readOp.dynamic;
  
    block_power.readOp.dynamic = 
!     blk1->power_nand2_path.readOp.dynamic +
!     blk1->power_nand3_path.readOp.dynamic +
!     blk1->power_L2.readOp.dynamic +
!     blk2->power_nand2_path.readOp.dynamic +
!     blk2->power_nand3_path.readOp.dynamic +
!     blk2->power_L2.readOp.dynamic;
  
    power.readOp.dynamic = driver_power.readOp.dynamic + block_power.readOp.dynamic;
  
--- 1543,1554 ----
      drv2->num_addr_bits_nand3_path() * drv2->power_nand3_path.readOp.dynamic;
  
    block_power.readOp.dynamic = 
! 		    blk1->power_nand2_path.readOp.dynamic*blk1->num_L1_active_nand2_path +
! 		    blk1->power_nand3_path.readOp.dynamic*blk1->num_L1_active_nand3_path +
! 		    blk1->power_L2.readOp.dynamic +
! 		    blk2->power_nand2_path.readOp.dynamic*blk1->num_L1_active_nand2_path  +
! 		    blk2->power_nand3_path.readOp.dynamic*blk1->num_L1_active_nand3_path +
! 		    blk2->power_L2.readOp.dynamic;
  
    power.readOp.dynamic = driver_power.readOp.dynamic + block_power.readOp.dynamic;
  
***************
*** 1318,1323 ****
--- 1556,1592 ----
    return  tmp_pair1.second;
  }
  
+ void Predec::leakage_feedback(double temperature)
+ {
+   drv1->leakage_feedback(temperature);
+   drv2->leakage_feedback(temperature);
+   blk1->leakage_feedback(temperature);
+   blk2->leakage_feedback(temperature);
+ 
+   driver_power.readOp.leakage = drv1->power_nand2_path.readOp.leakage +
+                                 drv1->power_nand3_path.readOp.leakage +
+                                 drv2->power_nand2_path.readOp.leakage +
+                                 drv2->power_nand3_path.readOp.leakage;
+   block_power.readOp.leakage = blk1->power_nand2_path.readOp.leakage +
+                                blk1->power_nand3_path.readOp.leakage +
+                                blk1->power_L2.readOp.leakage +
+                                blk2->power_nand2_path.readOp.leakage +
+                                blk2->power_nand3_path.readOp.leakage +
+                                blk2->power_L2.readOp.leakage;
+   power.readOp.leakage = driver_power.readOp.leakage + block_power.readOp.leakage;
+ 
+   driver_power.readOp.gate_leakage = drv1->power_nand2_path.readOp.gate_leakage +
+                                   drv1->power_nand3_path.readOp.gate_leakage +
+                                   drv2->power_nand2_path.readOp.gate_leakage +
+                                   drv2->power_nand3_path.readOp.gate_leakage;
+   block_power.readOp.gate_leakage = blk1->power_nand2_path.readOp.gate_leakage +
+                                  blk1->power_nand3_path.readOp.gate_leakage +
+                                  blk1->power_L2.readOp.gate_leakage +
+                                  blk2->power_nand2_path.readOp.gate_leakage +
+                                  blk2->power_nand3_path.readOp.gate_leakage +
+                                  blk2->power_L2.readOp.gate_leakage;
+   power.readOp.gate_leakage = driver_power.readOp.gate_leakage + block_power.readOp.gate_leakage;
+ }
  
  
  // returns <delay, risetime>
***************
*** 1362,1368 ****
    c_wire_load(c_wire_load_),
    r_wire_load(r_wire_load_),
    delay(0),
!   power(),
    is_dram_(is_dram)
  {
    for (int i = 0; i < MAX_NUMBER_GATES_STAGE; i++)
--- 1631,1637 ----
    c_wire_load(c_wire_load_),
    r_wire_load(r_wire_load_),
    delay(0),
! //  power(),
    is_dram_(is_dram)
  {
    for (int i = 0; i < MAX_NUMBER_GATES_STAGE; i++)
***************
*** 1372,1377 ****
--- 1641,1647 ----
    }
  
    compute_widths();
+   compute_area();
  }
  
  
***************
*** 1395,1400 ****
--- 1665,1682 ----
        g_tp.max_w_nmos_);
  }
  
+ void Driver::compute_area()
+ {
+   double cumulative_area = 0;
+ 
+     area.h = g_tp.cell_h_def;
+     for (int i = 0; i < number_gates; i++)
+     {
+       cumulative_area += compute_gate_area(INV, 1, width_p[i], width_n[i], area.h);
+ 
+     }
+     area.w = (cumulative_area / area.h);
+ }
  
  
  double Driver::compute_delay(double inrisetime)
***************
*** 1402,1408 ****
    int    i;
    double rd, c_load, c_intrinsic, tf;
    double this_delay = 0;
! 
    for (i = 0; i < number_gates - 1; ++i)
    {
      rd = tr_R_on(width_n[i], NCH, 1, is_dram_);
--- 1684,1690 ----
    int    i;
    double rd, c_load, c_intrinsic, tf;
    double this_delay = 0;
! //  cout << "number gates in bitline precharge driver : " << number_gates << endl;
    for (i = 0; i < number_gates - 1; ++i)
    {
      rd = tr_R_on(width_n[i], NCH, 1, is_dram_);
***************
*** 1414,1421 ****
      delay += this_delay;
      inrisetime = this_delay / (1.0 - 0.5);
      power.readOp.dynamic += (c_intrinsic + c_load) * g_tp.peri_global.Vdd * g_tp.peri_global.Vdd;
!     power.readOp.leakage += cmos_Ileak(width_n[i], width_p[i], is_dram_) *
!       0.5 * g_tp.peri_global.Vdd;
    }
  
    i = number_gates - 1;
--- 1696,1704 ----
      delay += this_delay;
      inrisetime = this_delay / (1.0 - 0.5);
      power.readOp.dynamic += (c_intrinsic + c_load) * g_tp.peri_global.Vdd * g_tp.peri_global.Vdd;
! //    power.readOp.leakage += cmos_Ileak(width_n[i], width_p[i], is_dram_) *
! //      0.5 * g_tp.peri_global.Vdd;
!     power.readOp.leakage += cmos_Isub_leakage(width_n[i], width_p[i], 1, inv, is_dram_) *g_tp.peri_global.Vdd;
    }
  
    i = number_gates - 1;
***************
*** 1427,1434 ****
    this_delay = horowitz(inrisetime, tf, 0.5, 0.5, RISE);
    delay += this_delay;
    power.readOp.dynamic += (c_intrinsic + c_load) * g_tp.peri_global.Vdd * g_tp.peri_global.Vdd;
!   power.readOp.leakage += cmos_Ileak(width_n[i], width_p[i], is_dram_) *
!     0.5 * g_tp.peri_global.Vdd;
  
    return this_delay / (1.0 - 0.5);
  }
--- 1710,1718 ----
    this_delay = horowitz(inrisetime, tf, 0.5, 0.5, RISE);
    delay += this_delay;
    power.readOp.dynamic += (c_intrinsic + c_load) * g_tp.peri_global.Vdd * g_tp.peri_global.Vdd;
! //  power.readOp.leakage += cmos_Ileak(width_n[i], width_p[i], is_dram_) *
! //    0.5 * g_tp.peri_global.Vdd;
!   power.readOp.leakage += cmos_Isub_leakage(width_n[i], width_p[i], 1, inv, is_dram_) * g_tp.peri_global.Vdd;
  
    return this_delay / (1.0 - 0.5);
  }
diff -crB pcacti_xml/decoder.h FN-CACTI/decoder.h
*** pcacti_xml/decoder.h	2014-07-03 09:47:24.000000000 +0200
--- FN-CACTI/decoder.h	2023-04-05 13:29:31.055922000 +0200
***************
*** 56,62 ****
          int _num_dec_signals,
          bool flag_way_select,
          double _C_ld_dec_out,
!         double _C_ld_dec_out_rd,
          double _R_wire_dec_out,
          bool fully_assoc_,
          bool is_dram_,
--- 56,62 ----
          int _num_dec_signals,
          bool flag_way_select,
          double _C_ld_dec_out,
! //        double _C_ld_dec_out_rd,
          double _R_wire_dec_out,
          bool fully_assoc_,
          bool is_dram_,
***************
*** 66,72 ****
      bool   exist;
      int    num_in_signals;
      double C_ld_dec_out;    // Alireza: Cload for WL (or WWL in 8T SRAM cell)
!     double C_ld_dec_out_rd; // Alireza: Cload for RWL
      double R_wire_dec_out;
      int    num_gates;    // Alireza: number of gates (inverters) for the WL (or WWL) driver
      int    num_gates_rd; // Alireza: number of gates (inverters) for the RWL driver
--- 66,72 ----
      bool   exist;
      int    num_in_signals;
      double C_ld_dec_out;    // Alireza: Cload for WL (or WWL in 8T SRAM cell)
! //    double C_ld_dec_out_rd; // Alireza: Cload for RWL //divya: we dont need 8T cell related details
      double R_wire_dec_out;
      int    num_gates;    // Alireza: number of gates (inverters) for the WL (or WWL) driver
      int    num_gates_rd; // Alireza: number of gates (inverters) for the RWL driver
***************
*** 77,83 ****
      double w_dec_p_rd[MAX_NUMBER_GATES_STAGE]; // Alireza: width of PMOS transistors in the decoder, DEMUX, and RWL driver
      double delay;    // Alireza: delay of the decoder, DEMUX, and WL (or WWL) driver
      double delay_rd; // Alireza: delay of the decoder, DEMUX, and RWL driver
!     powerDef power;
      bool   fully_assoc;
      bool   is_dram;
      bool   is_wl_tr;  // Alireza: row decoder?
--- 77,83 ----
      double w_dec_p_rd[MAX_NUMBER_GATES_STAGE]; // Alireza: width of PMOS transistors in the decoder, DEMUX, and RWL driver
      double delay;    // Alireza: delay of the decoder, DEMUX, and WL (or WWL) driver
      double delay_rd; // Alireza: delay of the decoder, DEMUX, and RWL driver
! //    powerDef power;
      bool   fully_assoc;
      bool   is_dram;
      bool   is_wl_tr;  // Alireza: row decoder?
***************
*** 87,92 ****
--- 87,95 ----
      void   compute_widths();
      void   compute_area();
      double compute_delays(double inrisetime);  // return outrisetime
+ 
+     void leakage_feedback(double temperature);
+ 
  };
  
  
***************
*** 118,123 ****
--- 121,128 ----
    int number_gates_L2;
    int min_number_gates_L1;
    int min_number_gates_L2;
+   int num_L1_active_nand2_path;
+   int num_L1_active_nand3_path;
    double w_L1_nand2_n[MAX_NUMBER_GATES_STAGE];
    double w_L1_nand2_p[MAX_NUMBER_GATES_STAGE];
    double w_L1_nand3_n[MAX_NUMBER_GATES_STAGE];
***************
*** 134,139 ****
--- 139,147 ----
  
    void compute_widths();
    void compute_area();
+ 
+   void leakage_feedback(double temperature);
+ 
    pair<double, double> compute_delays(pair<double, double> inrisetime); // <nand2, nand3>
    // return <outrise_nand2, outrise_nand3>
  };
***************
*** 178,183 ****
--- 186,194 ----
  
    void compute_widths();
    void compute_area();
+ 
+   void leakage_feedback(double temperature);
+ 
    pair<double, double> compute_delays(
        double inrisetime_nand2_path,
        double inrisetime_nand3_path);  // return <outrise_nand2, outrise_nand3>
***************
*** 206,211 ****
--- 216,222 ----
          PredecBlkDrv * drv2);
  
      double compute_delays(double inrisetime);  // return outrisetime
+     void leakage_feedback(double temperature);
  
      PredecBlk    * blk1;
      PredecBlk    * blk2;
***************
*** 237,246 ****
    double c_wire_load;
    double r_wire_load;
    double delay;
!   powerDef power;
    bool   is_dram_;
  
    void   compute_widths();
    double compute_delay(double inrisetime);
  };
  
--- 248,258 ----
    double c_wire_load;
    double r_wire_load;
    double delay;
! //  powerDef power;
    bool   is_dram_;
  
    void   compute_widths();
+   void   compute_area();
    double compute_delay(double inrisetime);
  };
  
Only in FN-CACTI: decoder_orig.cc
Only in pcacti_xml: dram.cfg
diff -crB pcacti_xml/htree2.cc FN-CACTI/htree2.cc
*** pcacti_xml/htree2.cc	2014-07-03 09:47:00.000000000 +0200
--- FN-CACTI/htree2.cc	2023-04-05 13:37:48.440305000 +0200
***************
*** 46,61 ****
  
  Htree2::Htree2(
      enum Wire_type wire_model, double mat_w, double mat_h, 
!     int a_bits, int d_inbits, int d_outbits, int bl, int wl, enum Htree_type htree_type,
!     bool uca_tree_, TechnologyParameter::DeviceType *dt)
   :in_rise_time(0), out_rise_time(0),
    tree_type(htree_type), mat_width(mat_w), mat_height(mat_h),
!   add_bits(a_bits), data_in_bits(d_inbits), data_out_bits(d_outbits), ndbl(bl), ndwl(wl),
!   uca_tree(uca_tree_), wt(wire_model), deviceType(dt)
  {
!   assert(bl >= 2 && wl >= 2);
!   
! //  if (bl == 1 && wl == 1)
  //  {
  //    delay = 0;
  //    power.readOp.dynamic = 0;
--- 46,62 ----
  
  Htree2::Htree2(
      enum Wire_type wire_model, double mat_w, double mat_h, 
!     int a_bits, int d_inbits, int search_data_in, int d_outbits, int search_data_out, int bl, int wl, enum Htree_type htree_type,
!     bool uca_tree_, bool search_tree_, TechnologyParameter::DeviceType *dt)
   :in_rise_time(0), out_rise_time(0),
    tree_type(htree_type), mat_width(mat_w), mat_height(mat_h),
!   add_bits(a_bits), data_in_bits(d_inbits), search_data_in_bits(search_data_in),data_out_bits(d_outbits),
!   search_data_out_bits(search_data_out), ndbl(bl), ndwl(wl),
!   uca_tree(uca_tree_), search_tree(search_tree_), wt(wire_model), deviceType(dt)
  {
!   assert(ndbl >= 2 && ndwl >= 2);
! 
! //  if (ndbl == 1 && ndwl == 1)
  //  {
  //    delay = 0;
  //    power.readOp.dynamic = 0;
***************
*** 64,71 ****
  //    area.h = mat_h;
  //    return;
  //  }
! //  if (bl == 1) ndbl++;
! //  if (wl == 1) ndwl++;
  
    max_unpipelined_link_delay = 0; //TODO
    min_w_nmos = g_tp.min_w_nmos_;
--- 65,72 ----
  //    area.h = mat_h;
  //    return;
  //  }
! //  if (ndbl == 1) ndbl++;
! //  if (ndwl == 1) ndwl++;
  
    max_unpipelined_link_delay = 0; //TODO
    min_w_nmos = g_tp.min_w_nmos_;
***************
*** 85,90 ****
--- 86,99 ----
        wire_bw = init_wire_bw = data_out_bits;
        out_htree();
        break;
+     case Search_in_htree:
+       wire_bw = init_wire_bw = search_data_in_bits;//in_search_tree is broad cast, out_htree is not.
+       in_htree();
+       break;
+     case Search_out_htree:
+       wire_bw = init_wire_bw = search_data_out_bits;
+       out_htree();
+       break;
      default:
        assert(0);
        break;
***************
*** 111,125 ****
    double tc = 2*tr_R_on(nsize*min_w_nmos, NCH, 1) *
      (drain_C_(nsize*min_w_nmos, NCH, 1, 1, g_tp.cell_h_def)*2 +
       2 * gate_C(s2*(min_w_nmos + min_w_pmos), 0));
    delay+= horowitz (w1.out_rise_time, tc, 
        deviceType->Vth/deviceType->Vdd, deviceType->Vth/deviceType->Vdd, RISE);
    power.readOp.dynamic += 0.5 *
      (2*drain_C_(pton_size * nsize*min_w_pmos, PCH, 1, 1, g_tp.cell_h_def)
       + drain_C_(nsize*min_w_nmos, NCH, 1, 1, g_tp.cell_h_def)
       + 2*gate_C(s2*(min_w_nmos + min_w_pmos), 0)) * 
      deviceType->Vdd * deviceType->Vdd;
  
!   power.readOp.leakage += (wire_bw*cmos_Ileak(min_w_nmos*(nsize*2), min_w_pmos * nsize * 2, false)*deviceType->Vdd);
  }
  
  
--- 120,147 ----
    double tc = 2*tr_R_on(nsize*min_w_nmos, NCH, 1) *
      (drain_C_(nsize*min_w_nmos, NCH, 1, 1, g_tp.cell_h_def)*2 +
       2 * gate_C(s2*(min_w_nmos + min_w_pmos), 0));
+ /*
+   cout << "input_nand : w1.out_rise_time : " << w1.out_rise_time << ", tc : "<< tc << ", Vth : " << deviceType->Vth << ", Vdd : " << deviceType->Vdd <<
+ 		  ", deviceType->Vth/deviceType->Vdd : "<< deviceType->Vth/deviceType->Vdd << endl;
+ */
    delay+= horowitz (w1.out_rise_time, tc, 
        deviceType->Vth/deviceType->Vdd, deviceType->Vth/deviceType->Vdd, RISE);
+ 
+ //  cout << "input_nand Htree delay : " << delay << endl;
+ 
    power.readOp.dynamic += 0.5 *
      (2*drain_C_(pton_size * nsize*min_w_pmos, PCH, 1, 1, g_tp.cell_h_def)
       + drain_C_(nsize*min_w_nmos, NCH, 1, 1, g_tp.cell_h_def)
       + 2*gate_C(s2*(min_w_nmos + min_w_pmos), 0)) * 
      deviceType->Vdd * deviceType->Vdd;
+   power.searchOp.dynamic += 0.5 *
+   (2*drain_C_(pton_size * nsize*min_w_pmos, PCH, 1, 1, g_tp.cell_h_def)
+    + drain_C_(nsize*min_w_nmos, NCH, 1, 1, g_tp.cell_h_def)
+    + 2*gate_C(s2*(min_w_nmos + min_w_pmos), 0)) *
+   deviceType->Vdd * deviceType->Vdd * wire_bw ;
  
! //  power.readOp.leakage += (wire_bw*cmos_Ileak(min_w_nmos*(nsize*2), min_w_pmos * nsize * 2, false)*deviceType->Vdd);
!   power.readOp.leakage             += (wire_bw*cmos_Isub_leakage(min_w_nmos*(nsize*2), min_w_pmos * nsize * 2, 2, nand))*deviceType->Vdd;
  }
  
  
***************
*** 159,164 ****
--- 181,193 ----
       gate_C(tr_size*(min_w_pmos), 0)) * 
      deviceType->Vdd * deviceType->Vdd;
  
+   power.searchOp.dynamic += 0.5 *
+   (2*drain_C_(size*min_w_pmos, PCH, 1, 1, g_tp.cell_h_def) +
+      drain_C_(size*min_w_nmos, NCH, 1, 1, g_tp.cell_h_def) +
+    gate_C(tr_size*(min_w_pmos), 0)) *
+   deviceType->Vdd * deviceType->Vdd*init_wire_bw;
+ 
+ 
    //not
    power.readOp.dynamic += 0.5 *
      (drain_C_(size*min_w_pmos, PCH, 1, 1, g_tp.cell_h_def)
***************
*** 166,171 ****
--- 195,206 ----
       +gate_C(size*(min_w_nmos + min_w_pmos), 0)) * 
      deviceType->Vdd * deviceType->Vdd;
  
+   power.searchOp.dynamic += 0.5 *
+   (drain_C_(size*min_w_pmos, PCH, 1, 1, g_tp.cell_h_def)
+    +drain_C_(size*min_w_nmos, NCH, 1, 1, g_tp.cell_h_def)
+    +gate_C(size*(min_w_nmos + min_w_pmos), 0)) *
+   deviceType->Vdd * deviceType->Vdd*init_wire_bw;
+ 
    //nor
    power.readOp.dynamic += 0.5 *
      (drain_C_(size*min_w_pmos, PCH, 1, 1, g_tp.cell_h_def)
***************
*** 173,178 ****
--- 208,219 ----
       +gate_C(tr_size*(min_w_nmos + min_w_pmos), 0)) * 
      deviceType->Vdd * deviceType->Vdd;
  
+   power.searchOp.dynamic += 0.5 *
+   (drain_C_(size*min_w_pmos, PCH, 1, 1, g_tp.cell_h_def)
+    + 2*drain_C_(size*min_w_nmos, NCH, 1, 1, g_tp.cell_h_def)
+    +gate_C(tr_size*(min_w_nmos + min_w_pmos), 0)) *
+   deviceType->Vdd * deviceType->Vdd*init_wire_bw;
+ 
    //output transistor
    power.readOp.dynamic += 0.5 *
      ((drain_C_(tr_size*min_w_pmos, PCH, 1, 1, g_tp.cell_h_def)
***************
*** 180,192 ****
       + gate_C(s1*(min_w_nmos + min_w_pmos), 0)) * 
      deviceType->Vdd * deviceType->Vdd;
  
    if(uca_tree) {
!     power.readOp.leakage += (deviceType->Vdd*cmos_Ileak(min_w_nmos*(tr_size*2/*inverter + output tr*/ + size*6 /*nand + nor*/), 
!         min_w_pmos*(tr_size*2 + size*6), false)*wire_bw);
    }
    else {
!     power.readOp.leakage += (deviceType->Vdd*cmos_Ileak(min_w_nmos*(tr_size*2/*inverter + output tr*/ + size*6 /*nand + nor*/), 
!         min_w_pmos*(tr_size*2 + size*6), false)*wire_bw);
    }
  }
  
--- 221,245 ----
       + gate_C(s1*(min_w_nmos + min_w_pmos), 0)) * 
      deviceType->Vdd * deviceType->Vdd;
  
+   power.searchOp.dynamic += 0.5 *
+    ((drain_C_(tr_size*min_w_pmos, PCH, 1, 1, g_tp.cell_h_def)
+      +drain_C_(tr_size*min_w_nmos, NCH, 1, 1, g_tp.cell_h_def))*2
+     + gate_C(s1*(min_w_nmos + min_w_pmos), 0)) *
+    deviceType->Vdd * deviceType->Vdd*init_wire_bw;
+ 
    if(uca_tree) {
! //    power.readOp.leakage += (deviceType->Vdd*cmos_Ileak(min_w_nmos*(tr_size*2/*inverter + output tr*/ + size*6 /*nand + nor*/),
! //        min_w_pmos*(tr_size*2 + size*6), false)*wire_bw);
! 		power.readOp.leakage += cmos_Isub_leakage(min_w_nmos*tr_size*2, min_w_pmos*tr_size*2, 1, inv)*deviceType->Vdd*wire_bw;/*inverter + output tr*/
! 		power.readOp.leakage += cmos_Isub_leakage(min_w_nmos*size*3, min_w_pmos*size*3, 2, nand)*deviceType->Vdd*wire_bw;//nand
! 		power.readOp.leakage += cmos_Isub_leakage(min_w_nmos*size*3, min_w_pmos*size*3, 2, nor)*deviceType->Vdd*wire_bw;//nor
    }
    else {
! //    power.readOp.leakage += (deviceType->Vdd*cmos_Ileak(min_w_nmos*(tr_size*2/*inverter + output tr*/ + size*6 /*nand + nor*/),
! //        min_w_pmos*(tr_size*2 + size*6), false)*wire_bw);
! 		power.readOp.leakage += cmos_Isub_leakage(min_w_nmos*tr_size*2, min_w_pmos*tr_size*2, 1, inv)*deviceType->Vdd*wire_bw;/*inverter + output tr*/
! 		power.readOp.leakage += cmos_Isub_leakage(min_w_nmos*size*3, min_w_pmos*size*3, 2, nand)*deviceType->Vdd*wire_bw;//nand
! 		power.readOp.leakage += cmos_Isub_leakage(min_w_nmos*size*3, min_w_pmos*size*3, 2, nor)*deviceType->Vdd*wire_bw;//nor
    }
  }
  
***************
*** 220,263 ****
    int v = (int) _log2(ndbl/2); // vertical nodes
    double len_temp;
    double ht_temp;
    if (uca_tree)
    {
!     ht_temp = (mat_height*ndbl/2 +/* since uca_tree models interbank tree, mat_height => bank height */  
!         ((add_bits + data_in_bits + data_out_bits) * g_tp.wire_outside_mat.pitch *
           2 * (1-pow(0.5,h))))/2;
      len_temp = (mat_width*ndwl/2 +
!         ((add_bits + data_in_bits + data_out_bits) * g_tp.wire_outside_mat.pitch *
           2 * (1-pow(0.5,v))))/2;
    }
    else
    {
      if (ndwl == ndbl) {
        ht_temp = ((mat_height*ndbl/2) +
!           (add_bits * (ndbl/2-1) * g_tp.wire_outside_mat.pitch) +
!           ((data_in_bits + data_out_bits) * g_tp.wire_outside_mat.pitch * h)
!           )/2;  
        len_temp = (mat_width*ndwl/2 +
!         (add_bits * (ndwl/2-1) * g_tp.wire_outside_mat.pitch) +
          ((data_in_bits + data_out_bits) * g_tp.wire_outside_mat.pitch * v))/2;
      }
      else if (ndwl > ndbl) {
        double excess_part = (_log2(ndwl/2) - _log2(ndbl/2));
        ht_temp = ((mat_height*ndbl/2) +
!           (add_bits * ((ndbl/2-1) + excess_part) * g_tp.wire_outside_mat.pitch) +
            (data_in_bits + data_out_bits) * g_tp.wire_outside_mat.pitch * 
            (2*(1 - pow(0.5, h-v)) + pow(0.5, v-h) * v))/2;
        len_temp = (mat_width*ndwl/2 +
!         (add_bits * (ndwl/2-1) * g_tp.wire_outside_mat.pitch) +
          ((data_in_bits + data_out_bits) * g_tp.wire_outside_mat.pitch * v))/2;
      }
      else {
        double excess_part = (_log2(ndbl/2) - _log2(ndwl/2));
        ht_temp = ((mat_height*ndbl/2) +
!           (add_bits * ((ndwl/2-1) + excess_part) * g_tp.wire_outside_mat.pitch) +
            ((data_in_bits + data_out_bits) * g_tp.wire_outside_mat.pitch * h)
            )/2;  
        len_temp = (mat_width*ndwl/2 + 
!           (add_bits * ((ndwl/2-1) + excess_part) * g_tp.wire_outside_mat.pitch) +
            (data_in_bits + data_out_bits) * g_tp.wire_outside_mat.pitch * (h + 2*(1-pow(0.5, v-h))))/2;
      }
    }
--- 273,320 ----
    int v = (int) _log2(ndbl/2); // vertical nodes
    double len_temp;
    double ht_temp;
+ /*  cout <<  " mat_width(mat_w) : " << mat_width << ", mat_height(mat_h) : " << mat_height << ", add_bits(a_bits) " << add_bits <<
+ 		  ", data_in_bits(d_inbits) : " << data_in_bits << ", data_out_bits(d_outbits) : " << data_out_bits <<
+ 		  ", ndbl(bl) : " << ndbl << ", ndwl(wl) : " << ndwl << ", uca_tree" << uca_tree << endl;
+ */
+ 
    if (uca_tree)
    {
!     ht_temp = (mat_height*ndbl/2 + /* since uca_tree models interbank tree, mat_height => bank height */
!         ((add_bits + data_in_bits + data_out_bits + (search_data_in_bits + search_data_out_bits)) * g_tp.wire_outside_mat.pitch *
           2 * (1-pow(0.5,h))))/2;
      len_temp = (mat_width*ndwl/2 +
!         ((add_bits + data_in_bits + data_out_bits + (search_data_in_bits + search_data_out_bits)) * g_tp.wire_outside_mat.pitch *
           2 * (1-pow(0.5,v))))/2;
    }
    else
    {
      if (ndwl == ndbl) {
        ht_temp = ((mat_height*ndbl/2) +
!           ((add_bits  + (search_data_in_bits + search_data_out_bits)) * (ndbl/2-1) * g_tp.wire_outside_mat.pitch) +
!           ((data_in_bits + data_out_bits) * g_tp.wire_outside_mat.pitch * h))/2;
        len_temp = (mat_width*ndwl/2 +
!         ((add_bits  + (search_data_in_bits + search_data_out_bits)) * (ndwl/2-1) * g_tp.wire_outside_mat.pitch) +
          ((data_in_bits + data_out_bits) * g_tp.wire_outside_mat.pitch * v))/2;
      }
      else if (ndwl > ndbl) {
        double excess_part = (_log2(ndwl/2) - _log2(ndbl/2));
        ht_temp = ((mat_height*ndbl/2) +
!           ((add_bits  + (search_data_in_bits + search_data_out_bits)) * ((ndbl/2-1) + excess_part) * g_tp.wire_outside_mat.pitch) +
            (data_in_bits + data_out_bits) * g_tp.wire_outside_mat.pitch * 
            (2*(1 - pow(0.5, h-v)) + pow(0.5, v-h) * v))/2;
        len_temp = (mat_width*ndwl/2 +
!         ((add_bits  + (search_data_in_bits + search_data_out_bits)) * (ndwl/2-1) * g_tp.wire_outside_mat.pitch) +
          ((data_in_bits + data_out_bits) * g_tp.wire_outside_mat.pitch * v))/2;
      }
      else {
        double excess_part = (_log2(ndbl/2) - _log2(ndwl/2));
        ht_temp = ((mat_height*ndbl/2) +
!           ((add_bits  + (search_data_in_bits + search_data_out_bits)) * ((ndwl/2-1) + excess_part) * g_tp.wire_outside_mat.pitch) +
            ((data_in_bits + data_out_bits) * g_tp.wire_outside_mat.pitch * h)
            )/2;  
        len_temp = (mat_width*ndwl/2 + 
!           ((add_bits  + (search_data_in_bits + search_data_out_bits)) * ((ndwl/2-1) + excess_part) * g_tp.wire_outside_mat.pitch) +
            (data_in_bits + data_out_bits) * g_tp.wire_outside_mat.pitch * (h + 2*(1-pow(0.5, v-h))))/2;
      }
    }
***************
*** 270,275 ****
--- 327,334 ----
    len = len_temp;
    ht  = ht_temp/2;
  
+ //  cout << " v : " << v << ", h : " << h << endl;
+ 
    while (v > 0 || h > 0)
    {
      if (wtemp1) delete wtemp1;
***************
*** 281,286 ****
--- 340,346 ----
        //the iteration considers only one horizontal link
        wtemp1 = new Wire(wt, len); // hor
        wtemp2 = new Wire(wt, len/2);  // next hor
+ //      cout << "1 wtemp2 : wt : " << wt<< ", len/2 : " << len << endl;
        len_temp = len;
        len /= 2;
        wtemp3 = 0; 
***************
*** 291,297 ****
--- 351,359 ----
      {
        //considers one horizontal link and one vertical link
        wtemp1 = new Wire(wt, len); // hor
+ //      cout << "2 wtemp2 : wt : " << wt<< ", ht : " << ht << endl;
        wtemp2 = new Wire(wt, ht);  // ver
+ //      cout << "2 wtemp3 : wt : " << wt<< ", len/2 : " << len/2 << endl;
        wtemp3 = new Wire(wt, len/2);  // next hor
        len_temp = len;
        ht_temp = ht;
***************
*** 307,322 ****
        assert(h == 0);
        wtemp1 = new Wire(wt, ht); // ver
        wtemp2 = new Wire(wt, ht/2);  // next ver
        ht_temp = ht;
        ht /= 2;
        wtemp3 = 0; 
        v--;
        option = 2;
      }
! 
      delay += wtemp1->delay;
      power.readOp.dynamic += wtemp1->power.readOp.dynamic;
      power.readOp.leakage += wtemp1->power.readOp.leakage*wire_bw;
      if (uca_tree == false && option == 2)
      {
        wire_bw*=2;  // wire bandwidth doubles only for vertical branches
--- 369,388 ----
        assert(h == 0);
        wtemp1 = new Wire(wt, ht); // ver
        wtemp2 = new Wire(wt, ht/2);  // next ver
+ //     cout << "3 wtemp2 : wt : " << wt<< ", ht/2 : " << ht/2 << endl;
        ht_temp = ht;
        ht /= 2;
        wtemp3 = 0; 
        v--;
        option = 2;
      }
! //    cout << "2 v : " << v << ", h : " << h << endl;
      delay += wtemp1->delay;
+ //    cout << "delay : " << delay << ", option : " << option << ", uca_tree : " << uca_tree << ", wtemp2->delay : "<< wtemp2->delay<< endl;
      power.readOp.dynamic += wtemp1->power.readOp.dynamic;
+     power.searchOp.dynamic += wtemp1->power.readOp.dynamic*wire_bw;
      power.readOp.leakage += wtemp1->power.readOp.leakage*wire_bw;
+ 
      if (uca_tree == false && option == 2)
      {
        wire_bw*=2;  // wire bandwidth doubles only for vertical branches
***************
*** 346,352 ****
        // first level
        input_nand(s1, s2, l_eff);
      }
! 
  
      if (option != 1)
      {
--- 412,418 ----
        // first level
        input_nand(s1, s2, l_eff);
      }
! //    cout << "2 delay : " << delay << ", option : " << option << ", uca_tree : " << uca_tree << ", wtemp2->delay : "<< wtemp2->delay<< endl;
  
      if (option != 1)
      {
***************
*** 355,361 ****
--- 421,429 ----
  
      // second level
      delay += wtemp2->delay;
+ //    cout << "2 delay : " << delay << endl;
      power.readOp.dynamic += wtemp2->power.readOp.dynamic;
+     power.searchOp.dynamic += wtemp2->power.readOp.dynamic*wire_bw;
      power.readOp.leakage += wtemp2->power.readOp.leakage*wire_bw;
  
      if (uca_tree)
***************
*** 414,457 ****
    int v = (int) _log2(ndbl/2);
    double len_temp;
    double ht_temp;
    if (uca_tree)
    {
      ht_temp = (mat_height*ndbl/2 +/* since uca_tree models interbank tree, mat_height => bank height */  
!         ((add_bits + data_in_bits + data_out_bits) * g_tp.wire_outside_mat.pitch *
           2 * (1-pow(0.5,h))))/2;
      len_temp = (mat_width*ndwl/2 +
!         ((add_bits + data_in_bits + data_out_bits) * g_tp.wire_outside_mat.pitch *
           2 * (1-pow(0.5,v))))/2;
    }
    else
    {
      if (ndwl == ndbl) {
        ht_temp = ((mat_height*ndbl/2) +
!           (add_bits * (ndbl/2-1) * g_tp.wire_outside_mat.pitch) +
            ((data_in_bits + data_out_bits) * g_tp.wire_outside_mat.pitch * h)
            )/2;  
        len_temp = (mat_width*ndwl/2 +
!         (add_bits * (ndwl/2-1) * g_tp.wire_outside_mat.pitch) +
          ((data_in_bits + data_out_bits) * g_tp.wire_outside_mat.pitch * v))/2;
      }
      else if (ndwl > ndbl) {
        double excess_part = (_log2(ndwl/2) - _log2(ndbl/2));
        ht_temp = ((mat_height*ndbl/2) +
!           (add_bits * ((ndbl/2-1) + excess_part) * g_tp.wire_outside_mat.pitch) +
            (data_in_bits + data_out_bits) * g_tp.wire_outside_mat.pitch * 
            (2*(1 - pow(0.5, h-v)) + pow(0.5, v-h) * v))/2;
        len_temp = (mat_width*ndwl/2 +
!         (add_bits * (ndwl/2-1) * g_tp.wire_outside_mat.pitch) +
          ((data_in_bits + data_out_bits) * g_tp.wire_outside_mat.pitch * v))/2;
      }
      else {
        double excess_part = (_log2(ndbl/2) - _log2(ndwl/2));
        ht_temp = ((mat_height*ndbl/2) +
!           (add_bits * ((ndwl/2-1) + excess_part) * g_tp.wire_outside_mat.pitch) +
            ((data_in_bits + data_out_bits) * g_tp.wire_outside_mat.pitch * h)
            )/2;  
        len_temp = (mat_width*ndwl/2 + 
!           (add_bits * ((ndwl/2-1) + excess_part) * g_tp.wire_outside_mat.pitch) +
            (data_in_bits + data_out_bits) * g_tp.wire_outside_mat.pitch * (h + 2*(1-pow(0.5, v-h))))/2;
      }
    }
--- 482,526 ----
    int v = (int) _log2(ndbl/2);
    double len_temp;
    double ht_temp;
+  // cout << "out_htree: uca_tree : " << uca_tree << endl;
    if (uca_tree)
    {
      ht_temp = (mat_height*ndbl/2 +/* since uca_tree models interbank tree, mat_height => bank height */  
!         ((add_bits + data_in_bits + data_out_bits + (search_data_in_bits + search_data_out_bits)) * g_tp.wire_outside_mat.pitch *
           2 * (1-pow(0.5,h))))/2;
      len_temp = (mat_width*ndwl/2 +
!         ((add_bits + data_in_bits + data_out_bits + (search_data_in_bits + search_data_out_bits)) * g_tp.wire_outside_mat.pitch *
           2 * (1-pow(0.5,v))))/2;
    }
    else
    {
      if (ndwl == ndbl) {
        ht_temp = ((mat_height*ndbl/2) +
!           ((add_bits + (search_data_in_bits + search_data_out_bits)) * (ndbl/2-1) * g_tp.wire_outside_mat.pitch) +
            ((data_in_bits + data_out_bits) * g_tp.wire_outside_mat.pitch * h)
            )/2;  
        len_temp = (mat_width*ndwl/2 +
!         ((add_bits + (search_data_in_bits + search_data_out_bits)) * (ndwl/2-1) * g_tp.wire_outside_mat.pitch) +
          ((data_in_bits + data_out_bits) * g_tp.wire_outside_mat.pitch * v))/2;
      }
      else if (ndwl > ndbl) {
        double excess_part = (_log2(ndwl/2) - _log2(ndbl/2));
        ht_temp = ((mat_height*ndbl/2) +
!           ((add_bits + (search_data_in_bits + search_data_out_bits)) * ((ndbl/2-1) + excess_part) * g_tp.wire_outside_mat.pitch) +
            (data_in_bits + data_out_bits) * g_tp.wire_outside_mat.pitch * 
            (2*(1 - pow(0.5, h-v)) + pow(0.5, v-h) * v))/2;
        len_temp = (mat_width*ndwl/2 +
!         ((add_bits + (search_data_in_bits + search_data_out_bits)) * (ndwl/2-1) * g_tp.wire_outside_mat.pitch) +
          ((data_in_bits + data_out_bits) * g_tp.wire_outside_mat.pitch * v))/2;
      }
      else {
        double excess_part = (_log2(ndbl/2) - _log2(ndwl/2));
        ht_temp = ((mat_height*ndbl/2) +
!           ((add_bits + (search_data_in_bits + search_data_out_bits)) * ((ndwl/2-1) + excess_part) * g_tp.wire_outside_mat.pitch) +
            ((data_in_bits + data_out_bits) * g_tp.wire_outside_mat.pitch * h)
            )/2;  
        len_temp = (mat_width*ndwl/2 + 
!           ((add_bits + (search_data_in_bits + search_data_out_bits)) * ((ndwl/2-1) + excess_part) * g_tp.wire_outside_mat.pitch) +
            (data_in_bits + data_out_bits) * g_tp.wire_outside_mat.pitch * (h + 2*(1-pow(0.5, v-h))))/2;
      }
    }
***************
*** 506,511 ****
--- 575,581 ----
      }
      delay += wtemp1->delay;
      power.readOp.dynamic += wtemp1->power.readOp.dynamic;
+     power.searchOp.dynamic += wtemp1->power.readOp.dynamic*init_wire_bw;
      power.readOp.leakage += wtemp1->power.readOp.leakage*wire_bw;
      if (uca_tree == false && option == 2)
      {
***************
*** 545,550 ****
--- 615,621 ----
      // second level
      delay += wtemp2->delay;
      power.readOp.dynamic += wtemp2->power.readOp.dynamic;
+     power.searchOp.dynamic += wtemp2->power.readOp.dynamic*init_wire_bw;
      power.readOp.leakage += wtemp2->power.readOp.leakage*wire_bw;
      if (uca_tree)
      {
diff -crB pcacti_xml/htree2.h FN-CACTI/htree2.h
*** pcacti_xml/htree2.h	2014-07-03 09:47:28.000000000 +0200
--- FN-CACTI/htree2.h	2023-04-05 13:30:03.463426000 +0200
***************
*** 57,64 ****
  {
    public:
      Htree2(enum Wire_type wire_model, 
!         double mat_w, double mat_h, int add, int data_in, int data_out, int bl, int wl,
!         enum Htree_type h_type, bool uca_tree = false,
          TechnologyParameter::DeviceType *dt = &(g_tp.peri_global));
      ~Htree2() {};
  
--- 57,64 ----
  {
    public:
      Htree2(enum Wire_type wire_model, 
!          double mat_w, double mat_h, int add, int data_in, int search_data_in, int data_out, int search_data_out, int bl, int wl,
!          enum Htree_type h_type, bool uca_tree_ = false, bool search_tree_ = false,
          TechnologyParameter::DeviceType *dt = &(g_tp.peri_global));
      ~Htree2() {};
  
***************
*** 90,98 ****
      double htree_vnodes;
      double mat_width;
      double mat_height;
!     int add_bits, data_in_bits, data_out_bits;
      int ndbl, ndwl;
      bool uca_tree; // should have full bandwidth to access all banks in the array simultaneously 
  
  
      enum Wire_type wt;
--- 90,99 ----
      double htree_vnodes;
      double mat_width;
      double mat_height;
!     int add_bits, data_in_bits,search_data_in_bits,data_out_bits,  search_data_out_bits;
      int ndbl, ndwl;
      bool uca_tree; // should have full bandwidth to access all banks in the array simultaneously 
+     bool search_tree;
  
  
      enum Wire_type wt;
diff -crB pcacti_xml/io.cc FN-CACTI/io.cc
*** pcacti_xml/io.cc	2014-07-17 16:19:49.000000000 +0200
--- FN-CACTI/io.cc	2023-04-05 13:30:26.139079000 +0200
***************
*** 44,49 ****
--- 44,52 ----
  #include <sstream>
  #include <stdlib.h>	// Majid
  #include <stdio.h>	// Majid
+ #ifdef ENABLE_CACHE
+ #include <db.h>
+ #endif
  
  #include "io.h"
  #include "area.h"
***************
*** 53,64 ****
  #include "nuca.h"
  #include "crossbar.h"
  #include "arbiter.h"
! #include "xmlParser.h"	// Majid
  
  using namespace std;
  
  
  
  /* Parses "cache.cfg" file */
  void InputParameter::parse_cfg(const string & in_file)
  {
--- 56,79 ----
  #include "nuca.h"
  #include "crossbar.h"
  #include "arbiter.h"
! //#include "xmlParser.h"	// Majid
! #include <cstddef>
  
  using namespace std;
  
+ InputParameter::InputParameter()
+ {
+ 	dvs_voltage = std::vector<double>(0);
+ 
+    // Clear out all data used as the DB key, especially unused bits
+    // such that they're zero and not old data that might be different per run
+    size_t o1 = offsetof(InputParameter, first);
+    size_t o2 = offsetof(InputParameter, last);
+    memset((char*)this + o1, 0, o2 - o1);
  
+ }
  
+ //Divya modifying parse_cfg() call 14-11-2021
  /* Parses "cache.cfg" file */
  void InputParameter::parse_cfg(const string & in_file)
  {
***************
*** 66,540 ****
    char line[5000];
    char jk[5000];
    char temp_var[5000];
  
    if(!fp) {
      cout << in_file << " is missing!\n";
      exit(-1);
    }
  
! 	/******************** MAJID BEGIN ********************/
! 	
! 	XMLNode xMainNode = XMLNode::openFileHelper(in_file.c_str(), "cache_config");
! 	
! 	if ( xMainNode.getChildNode("transistor_type").isEmpty() ) {
! 		cerr << "XML ERROR: <transistor_type> in the '" << in_file <<"' file is missing.\n";
! 		exit(0);
! 	} else if ( xMainNode.getChildNode("transistor_type").nText() == 0 ) {
! 		cerr << "XML ERROR: <transistor_type> in the '" << in_file <<"' file does not have a value.\n";
! 		cerr << "Please specify either 'finfet' or 'cmos' as the transistor type." << endl;
! 		exit(0);
! 	} else {
! 		strcpy(temp_var,xMainNode.getChildNode("transistor_type").getText(0));
! 		for (int i = 0; temp_var[i]; i++) { temp_var[i] = tolower(temp_var[i]); }
! 		if (!strncmp("finfet", temp_var, strlen("finfet"))) {
! 			is_finfet = 1;
! 		} else if (!strncmp("cmos", temp_var, strlen("cmos"))) {
! 			is_finfet = 0;
! 		} else {
  			cerr << "ERROR: Invalid transistor type!\nSupported transistor types: 'finfet', 'cmos'.\n";
  			exit(0);
! 		}
! 	}
! 	
! 	if ( xMainNode.getChildNode("technology_node").isEmpty() ) {
! 		cerr << "XML ERROR: <technology_node> in the '" << in_file <<"' file is missing.\n";
! 		exit(0);
! 	} else if ( xMainNode.getChildNode("technology_node").nText() == 0 ) {
! 		cerr << "XML ERROR: <technology_node> in the '" << in_file <<"' file does not have a value.\n";
! 		exit(0);
! 	} else {
! 		strcpy(temp_var,xMainNode.getChildNode("technology_node").getText(0));
! 		sscanf(temp_var, "%lf", &(F_sz_um));
! 		F_sz_nm = F_sz_um*1000;
! 	}
! 	
! 	if ( xMainNode.getChildNode("operating_voltage").isEmpty() ) {
! 		cerr << "XML ERROR: <operating_voltage> in the '" << in_file <<"' file is missing.\n";
! 		exit(0);
! 	} else if ( xMainNode.getChildNode("operating_voltage").nText() == 0 ) {
! 		cerr << "XML ERROR: <operating_voltage> in the '" << in_file <<"' file does not have a value.\n";
! 		cerr << "Please specify either 'super-threshold' or 'near-threshold' as the operating voltage." << endl;
! 		exit(0);
! 	} else {
! 		strcpy(temp_var,xMainNode.getChildNode("operating_voltage").getText(0));
! 		for (int i = 0; temp_var[i]; i++) { temp_var[i] = tolower(temp_var[i]); }
! 		if (!strncmp("near-threshold", temp_var, strlen("near-threshold"))) {
! 			is_near_threshold = 1;
! 		} else if (!strncmp("super-threshold", temp_var, strlen("super-threshold"))) {
! 			is_near_threshold = 0;
! 		} else {
! 			cerr << "ERROR: Invalid operating voltage!\nSupported operating voltages: 'super-threshold', 'near-threshold'.\n";
! 			exit(0);
! 		}
! 	}
! 	
! 	if ( xMainNode.getChildNode("temperature").isEmpty() ) {
! 		cerr << "XML ERROR: <temperature> in the '" << in_file <<"' file is missing.\n";
! 		exit(0);
! 	} else if ( xMainNode.getChildNode("temperature").nText() == 0 ) {
! 		cerr << "XML ERROR: <temperature> in the '" << in_file <<"' file does not have a value.\n";
! 		cerr << "Please specify a number between 300 and 400, which is a multiple of 10." << endl;
! 		exit(0);
! 	} else {
! 		strcpy(temp_var,xMainNode.getChildNode("temperature").getText(0));
! 		sscanf(temp_var, "%u", &(temp));
! 		if (temp < 300 || temp > 400 || temp%10 != 0) {
! 			cerr << "ERROR: " << temp << "K is not a valid temperature." << endl;
! 			cerr << "The temperature must be a multiple of 10 between 300K and 400K." << endl;
! 			exit(0);
! 		}
! 	}
! 	
! 	strcpy(temp_var,xMainNode.getChildNode("cache_size").getText(0));
! 	sscanf(temp_var, "%u", &(cache_sz));
! 	
! 	strcpy(temp_var,xMainNode.getChildNode("block_size").getText(0));
! 	sscanf(temp_var, "%u", &(line_sz));
! 	
! 	strcpy(temp_var,xMainNode.getChildNode("associativity").getText(0));
! 	sscanf(temp_var, "%u", &(assoc));
! 	
! 	strcpy(data_array_cell_tech_file,xMainNode.getChildNode("devices").getChildNode("data_array").getChildNode("cell").getText(0));
! 	strcpy(data_array_peri_tech_file,xMainNode.getChildNode("devices").getChildNode("data_array").getChildNode("peripheral").getText(0));
! 	strcpy(tag_array_cell_tech_file,xMainNode.getChildNode("devices").getChildNode("tag_array").getChildNode("cell").getText(0));
! 	strcpy(tag_array_peri_tech_file,xMainNode.getChildNode("devices").getChildNode("tag_array").getChildNode("peripheral").getText(0));
! 
! 	string sram_cell_file = xMainNode.getChildNode("sram_cell").getText(0);
! 	XMLNode SRAM_cell_conf_node = XMLNode::openFileHelper(sram_cell_file.c_str(),"sram_cell");
! 	strcpy(temp_var,SRAM_cell_conf_node.getChildNode("type").getText(0));
! 	if (!strncmp("6T", temp_var, strlen("6T"))) {
! 		sram_cell_design.setType(std_6T);
! 	} else if (!strncmp("8T", temp_var, strlen("8T"))) {
! 		sram_cell_design.setType(std_8T);
! 	} else {
! 		cerr << "ERROR: Invalid SRAM cell type!\n";
! 		exit(0);
! 	}
! 	
! 	if ( !SRAM_cell_conf_node.getChildNode("dual_gate_control").isEmpty() ) {
! 		if ( SRAM_cell_conf_node.getChildNode("dual_gate_control").nText() == 0 ) {
! 			cout << "XML ERROR: <dual_gate_control> in the '" << sram_cell_file <<"' file does not have a value.\n";
! 			cerr << "Please specify either 'true' or 'false' for the dual_gate_control." << endl;
! 			exit(0);
! 		} else {
! 			strcpy(temp_var,SRAM_cell_conf_node.getChildNode("dual_gate_control").getText(0));
! 			for (int i = 0; temp_var[i]; i++) { temp_var[i] = tolower(temp_var[i]); }
! 			if (!strncmp("true", temp_var, strlen("true"))) {
! 				sram_cell_design.setDGcontrol(true);
! 			} else if (!strncmp("false", temp_var, strlen("false"))) {
! 				sram_cell_design.setDGcontrol(false);
! 			} else {
! 				cerr << "ERROR: Invalid value for the dual_gate_control in '" << sram_cell_file <<"' file!\n";
! 				exit(0);
! 			}
! 		}
! 	} else {
! 		sram_cell_design.setDGcontrol(false);
! 	}
! 	
! 	XMLNode SRAM_leak_power = SRAM_cell_conf_node.getChildNode("leakage_power");
! 	if ( !SRAM_leak_power.getChildNode("bitline").isEmpty() ) {
! 		if ( SRAM_leak_power.getChildNode("bitline").nText() > 0 ) {
! 			strcpy(temp_var,SRAM_leak_power.getChildNode("bitline").getText(0));
! 			double pleak;
! 			sscanf(temp_var, "%lf", &(pleak));
! 			sram_cell_design.setPleakAccTx(pleak);
! 		}
! 	}
! 	if ( !SRAM_leak_power.getChildNode("cc_inverters").isEmpty() ) {
! 		if ( SRAM_leak_power.getChildNode("cc_inverters").nText() > 0 ) {
! 			strcpy(temp_var,SRAM_leak_power.getChildNode("cc_inverters").getText(0));
! 			double pleak;
! 			sscanf(temp_var, "%lf", &(pleak));
! 			sram_cell_design.setPleakCCInv(pleak);
! 		}
! 	}
! 	
! 	int Nfins[5];
! 	double Lphys[5], Ioffs[5];
! 	XMLNode SRAM_transistor_parameters = SRAM_cell_conf_node.getChildNode("transistor_parameters");
! 	if ( is_finfet ) {
! 		strcpy(temp_var,SRAM_transistor_parameters.getChildNode("acc").getChildNode("num_of_fins").getText(0));
! 		sscanf(temp_var,"%d",&(Nfins[0]));
! 		strcpy(temp_var,SRAM_transistor_parameters.getChildNode("pup").getChildNode("num_of_fins").getText(0));
! 		sscanf(temp_var,"%d",&(Nfins[1]));
! 		strcpy(temp_var,SRAM_transistor_parameters.getChildNode("pdn").getChildNode("num_of_fins").getText(0));
! 		sscanf(temp_var,"%d",&(Nfins[2]));
! 		if (sram_cell_design.getType() == std_8T) {
! 			strcpy(temp_var,SRAM_transistor_parameters.getChildNode("iso").getChildNode("num_of_fins").getText(0));
! 			sscanf(temp_var,"%d",&(Nfins[3]));
! 			strcpy(temp_var,SRAM_transistor_parameters.getChildNode("rac").getChildNode("num_of_fins").getText(0));
! 			sscanf(temp_var,"%d",&(Nfins[4]));
! 		}
! 	} else {
! 		Nfins[0] = 0; Nfins[1] = 0; Nfins[2] = 0; Nfins[3] = 0; Nfins[4] = 0;
! 	}
! 	
! 	XMLNode SRAM_transistor_definition = XMLNode::openFileHelper(SRAM_transistor_parameters.getChildNode("acc").getChildNode("device_type").getText(0),"device_definition");
! 	strcpy(temp_var,SRAM_transistor_definition.getChildNode("geometries").getChildNode("Lphy").getText(0));
! 	sscanf(temp_var,"%lf",&(Lphys[0]));
! 	char temperature[10];
! 	sprintf(temperature,"%d",g_ip->temp);
! 	if (is_near_threshold)
! 		strcpy(temp_var,SRAM_transistor_definition.getChildNode("currents").getChildNode("OFF_current").getChildNode("NMOS").getChildNode("near_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 	else
! 		strcpy(temp_var,SRAM_transistor_definition.getChildNode("currents").getChildNode("OFF_current").getChildNode("NMOS").getChildNode("super_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 	sscanf(temp_var,"%lf",&(Ioffs[0]));
  
! 	SRAM_transistor_definition = XMLNode::openFileHelper(SRAM_transistor_parameters.getChildNode("pup").getChildNode("device_type").getText(0),"device_definition");
! 	strcpy(temp_var,SRAM_transistor_definition.getChildNode("geometries").getChildNode("Lphy").getText(0));
! 	sscanf(temp_var,"%lf",&(Lphys[1]));
! 	if(is_near_threshold)
! 		strcpy(temp_var,SRAM_transistor_definition.getChildNode("currents").getChildNode("OFF_current").getChildNode("PMOS").getChildNode("near_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 	else
! 		strcpy(temp_var,SRAM_transistor_definition.getChildNode("currents").getChildNode("OFF_current").getChildNode("PMOS").getChildNode("super_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 	sscanf(temp_var,"%lf",&(Ioffs[1]));
! 	
! 	SRAM_transistor_definition = XMLNode::openFileHelper(SRAM_transistor_parameters.getChildNode("pdn").getChildNode("device_type").getText(0),"device_definition");
! 	strcpy(temp_var,SRAM_transistor_definition.getChildNode("geometries").getChildNode("Lphy").getText(0));
! 	sscanf(temp_var,"%lf",&(Lphys[2]));
! 	if(is_near_threshold)
! 		strcpy(temp_var,SRAM_transistor_definition.getChildNode("currents").getChildNode("OFF_current").getChildNode("NMOS").getChildNode("near_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 	else
! 		strcpy(temp_var,SRAM_transistor_definition.getChildNode("currents").getChildNode("OFF_current").getChildNode("NMOS").getChildNode("super_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 	sscanf(temp_var,"%lf",&(Ioffs[2]));
! 	
! 	if (sram_cell_design.getType() == std_8T) {
! 		SRAM_transistor_definition = XMLNode::openFileHelper(SRAM_transistor_parameters.getChildNode("iso").getChildNode("device_type").getText(0),"device_definition");
! 		strcpy(temp_var,SRAM_transistor_definition.getChildNode("geometries").getChildNode("Lphy").getText(0));
! 		sscanf(temp_var,"%lf",&(Lphys[3]));
! 		if (is_near_threshold)
! 			strcpy(temp_var,SRAM_transistor_definition.getChildNode("currents").getChildNode("OFF_current").getChildNode("NMOS").getChildNode("near_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 		else
! 			strcpy(temp_var,SRAM_transistor_definition.getChildNode("currents").getChildNode("OFF_current").getChildNode("NMOS").getChildNode("super_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 		sscanf(temp_var,"%lf",&(Ioffs[3]));
  
! 		SRAM_transistor_definition = XMLNode::openFileHelper(SRAM_transistor_parameters.getChildNode("rac").getChildNode("device_type").getText(0),"device_definition");
! 		strcpy(temp_var,SRAM_transistor_definition.getChildNode("geometries").getChildNode("Lphy").getText(0));
! 		sscanf(temp_var,"%lf",&(Lphys[4]));
! 		if (is_near_threshold)
! 			strcpy(temp_var,SRAM_transistor_definition.getChildNode("currents").getChildNode("OFF_current").getChildNode("NMOS").getChildNode("near_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 		else
! 			strcpy(temp_var,SRAM_transistor_definition.getChildNode("currents").getChildNode("OFF_current").getChildNode("NMOS").getChildNode("super_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 		sscanf(temp_var,"%lf",&(Ioffs[4]));
! 	}
! 	
! 	sram_cell_design.setTransistorParams(Nfins, Lphys, Ioffs);
  
! 	XMLNode ports_node = xMainNode.getChildNode("ports");
! 	strcpy(temp_var,ports_node.getChildNode("read_write_port").getText(0));
! 	sscanf(temp_var, "%u", &(num_rw_ports));
! 	strcpy(temp_var,ports_node.getChildNode("exclusive_read_port").getText(0));
! 	sscanf(temp_var, "%u", &(num_rd_ports));
! 	strcpy(temp_var,ports_node.getChildNode("exclusive_write_port").getText(0));
! 	sscanf(temp_var, "%u", &(num_wr_ports));
! 	strcpy(temp_var,ports_node.getChildNode("single_ended_read_ports").getText(0));
! 	sscanf(temp_var, "%u", &(num_se_rd_ports));
! 	
! 	strcpy(temp_var,xMainNode.getChildNode("cache_model").getText(0));
! 	if (!strncmp("UCA", temp_var, strlen("UCA"))) {
! 		nuca = 0;
! 	} else {
! 		nuca = 1;
! 	}
! 	
! 	strcpy(temp_var,xMainNode.getChildNode("uca_bank_count").getText(0));
! 	sscanf(temp_var, "%u", &(nbanks));
! 	
! 	strcpy(temp_var,xMainNode.getChildNode("nuca_bank_count").getText(0));
! 	sscanf(temp_var, "%d", &(nuca_bank_count));
! 	if (nuca_bank_count != 0) {
! 		force_nuca_bank = 1;
! 	}
! 	
! 	strcpy(temp_var,xMainNode.getChildNode("bus_width").getText(0));
! 	sscanf(temp_var, "%u", &(out_w));
! 
! 	strcpy(temp_var,xMainNode.getChildNode("memory_type").getText(0));
! 	if (!strncmp("cache", temp_var, sizeof("cache"))) {
! 		is_cache = true;
! 	} else {
! 		is_cache = false;
! 	}
! 	if (!strncmp("main memory", temp_var, sizeof("main memory"))) {
! 		is_main_mem = true;
! 	} else {
! 		is_main_mem = false;
! 	}
  
! 	strcpy(temp_var,xMainNode.getChildNode("tag_size").getText(0));
! 	if (!strncmp("default", temp_var, sizeof("default"))) {
! 		specific_tag = false;
! 		tag_w = 42;
! 		// the acutal value is calculated later based on the cache size,
! 		// bank count, and associativity
! 	} else {
! 		specific_tag = true;
! 		sscanf(temp_var, "%u", &(tag_w));
! 	}
! 	
! 	strcpy(temp_var,xMainNode.getChildNode("access_mode").getText(0));
! 	if (!strncmp("fast", temp_var, strlen("fast"))) {
! 		access_mode = 2;
! 	} else if (!strncmp("sequential", temp_var, strlen("sequential"))) {
! 		access_mode = 1;
! 	} else if(!strncmp("normal", temp_var, strlen("normal"))) {
! 		access_mode = 0;
! 	} else {
! 		cout << "ERROR: Invalid access mode!\n";
! 		exit(0);
! 	}
  
! 	XMLNode objectiveFuncNode=xMainNode.getChildNode("objective_function");
! 	strcpy(temp_var,objectiveFuncNode.getChildNode("optimize").getText(0));
! 	if(!strncmp("ED^2", temp_var, strlen("ED^2"))) {
! 		ed = 2;
! 	} else if(!strncmp("ED", temp_var, strlen("ED"))) {
! 		ed = 1;
! 	} else {
! 		ed = 0;
! 	}
! 	XMLNode designObjectiveNode=objectiveFuncNode.getChildNode("design_objective");
! 	strcpy(temp_var,designObjectiveNode.getChildNode("weights").getChildNode("delay").getText(0));
! 	sscanf(temp_var, "%d", &(delay_wt));
! 	strcpy(temp_var,designObjectiveNode.getChildNode("weights").getChildNode("dynamic_power").getText(0));
! 	sscanf(temp_var, "%d", &(dynamic_power_wt));
! 	strcpy(temp_var,designObjectiveNode.getChildNode("weights").getChildNode("leakage_power").getText(0));
! 	sscanf(temp_var, "%d", &(leakage_power_wt));
! 	strcpy(temp_var,designObjectiveNode.getChildNode("weights").getChildNode("cycle_time").getText(0));
! 	sscanf(temp_var, "%d", &(cycle_time_wt));
! 	strcpy(temp_var,designObjectiveNode.getChildNode("weights").getChildNode("area").getText(0));
! 	sscanf(temp_var, "%d", &(area_wt));
! 	strcpy(temp_var,designObjectiveNode.getChildNode("deviations").getChildNode("delay").getText(0));
! 	sscanf(temp_var, "%d", &(delay_dev));
! 	strcpy(temp_var,designObjectiveNode.getChildNode("deviations").getChildNode("dynamic_power").getText(0));
! 	sscanf(temp_var, "%d", &(dynamic_power_dev));
! 	strcpy(temp_var,designObjectiveNode.getChildNode("deviations").getChildNode("leakage_power").getText(0));
! 	sscanf(temp_var, "%d", &(leakage_power_dev));
! 	strcpy(temp_var,designObjectiveNode.getChildNode("deviations").getChildNode("cycle_time").getText(0));
! 	sscanf(temp_var, "%d", &(cycle_time_dev));
! 	strcpy(temp_var,designObjectiveNode.getChildNode("deviations").getChildNode("area").getText(0));
! 	sscanf(temp_var, "%d", &(area_dev));
! 	
! 	designObjectiveNode=objectiveFuncNode.getChildNode("nuca_design_objective");
! 	strcpy(temp_var,designObjectiveNode.getChildNode("weights").getChildNode("delay").getText(0));
! 	sscanf(temp_var, "%d", &(delay_wt_nuca));
! 	strcpy(temp_var,designObjectiveNode.getChildNode("weights").getChildNode("dynamic_power").getText(0));
! 	sscanf(temp_var, "%d", &(dynamic_power_wt_nuca));
! 	strcpy(temp_var,designObjectiveNode.getChildNode("weights").getChildNode("leakage_power").getText(0));
! 	sscanf(temp_var, "%d", &(leakage_power_wt_nuca));
! 	strcpy(temp_var,designObjectiveNode.getChildNode("weights").getChildNode("cycle_time").getText(0));
! 	sscanf(temp_var, "%d", &(cycle_time_wt_nuca));
! 	strcpy(temp_var,designObjectiveNode.getChildNode("weights").getChildNode("area").getText(0));
! 	sscanf(temp_var, "%d", &(area_wt_nuca));
! 	strcpy(temp_var,designObjectiveNode.getChildNode("deviations").getChildNode("delay").getText(0));
! 	sscanf(temp_var, "%d", &(delay_dev_nuca));
! 	strcpy(temp_var,designObjectiveNode.getChildNode("deviations").getChildNode("dynamic_power").getText(0));
! 	sscanf(temp_var, "%d", &(dynamic_power_dev_nuca));
! 	strcpy(temp_var,designObjectiveNode.getChildNode("deviations").getChildNode("leakage_power").getText(0));
! 	sscanf(temp_var, "%d", &(leakage_power_dev_nuca));
! 	strcpy(temp_var,designObjectiveNode.getChildNode("deviations").getChildNode("cycle_time").getText(0));
! 	sscanf(temp_var, "%d", &(cycle_time_dev_nuca));
! 	strcpy(temp_var,designObjectiveNode.getChildNode("deviations").getChildNode("area").getText(0));
! 	sscanf(temp_var, "%d", &(area_dev_nuca));
! 	
! 	XMLNode interconnectsInfoNode=xMainNode.getChildNode("interconnects");
! 	strcpy(temp_var,interconnectsInfoNode.getChildNode("source").getText(0));
! 	if (!strncmp("ITRS2012", temp_var, strlen("ITRS2012"))) {
! 		is_itrs2012 = true;
! 	} else if (!strncmp("RonHo2003", temp_var, strlen("RonHo2003"))) {
! 		is_itrs2012 = false;
! 	} else {
! 		cout << "ERROR: Invalid interconnect source!\n";
! 		exit(0);
! 	}
! 	strcpy(temp_var,interconnectsInfoNode.getChildNode("wire_signalling").getText(0));
! 	if (!strncmp("default", temp_var, strlen("default"))) {
! 		force_wiretype = 0;
! 		wt = Global;
! 	} else if (!(strncmp("Global_10", temp_var, strlen("Global_10")))) {
! 		force_wiretype = 1;
! 		wt = Global_10;
! 	} else if (!(strncmp("Global_20", temp_var, strlen("Global_20")))) {
! 		force_wiretype = 1;
! 		wt = Global_20;
! 	} else if (!(strncmp("Global_30", temp_var, strlen("Global_30")))) {
! 		force_wiretype = 1;
! 		wt = Global_30;
! 	} else if (!(strncmp("Global_5", temp_var, strlen("Global_5")))) {
! 		force_wiretype = 1;
! 		wt = Global_5;
! 	} else if (!(strncmp("Global", temp_var, strlen("Global")))) {
! 		force_wiretype = 1;
! 		wt = Global;
! 	} else {
! 		wt = Low_swing;
! 		force_wiretype = 1;
! 	}
! 	strcpy(temp_var,interconnectsInfoNode.getChildNode("wire_type").getChildNode("inside_mat").getText(0));
! 	if (!strncmp("global", temp_var, strlen("global"))) {
! 		wire_is_mat_type = 2;
! 	} else if (!strncmp("local", temp_var, strlen("local"))) {
! 		wire_is_mat_type = 0;
! 	} else {
! 		wire_is_mat_type = 1;
! 	}
! 	strcpy(temp_var,interconnectsInfoNode.getChildNode("wire_type").getChildNode("outside_mat").getText(0));
! 	if (!strncmp("global", temp_var, strlen("global"))) {
! 		wire_os_mat_type = 2;
! 	} else {
! 		wire_os_mat_type = 1;
! 	}
! 	strcpy(temp_var,interconnectsInfoNode.getChildNode("projection").getText(0));
! 	if (!strncmp("aggressive", temp_var, strlen("aggressive"))) {
! 		ic_proj_type = 0;
! 	} else {
! 		ic_proj_type = 1;
! 	}
! 	
! 	strcpy(temp_var,xMainNode.getChildNode("core_count").getText(0));
! 	sscanf(temp_var, "%d", &(cores));
! 	if (cores > 16) {
! 		printf("No. of cores should be less than 16!\n");
! 	}
! 	
! 	strcpy(temp_var,xMainNode.getChildNode("cache_level").getText(0));
! 	if (!strncmp("L2", temp_var, strlen("L2"))) {
! 		cache_level = 0;
! 	} else {
! 		cache_level = 1;
! 	}
! 	
! 	strcpy(temp_var,xMainNode.getChildNode("add_ecc").getText(0));
! 	if (!strncmp("true", temp_var, strlen("true"))) {
! 		add_ecc_b_ = true;
! 	} else {
! 		add_ecc_b_ = false;
! 	}
! 	
! 	strcpy(temp_var,xMainNode.getChildNode("print_level").getText(0));
! 	if (!strncmp("DETAILED", temp_var, strlen("DETAILED"))) {
! 		print_detail = 1;
! 	} else {
! 		print_detail = 0;
! 	}
! 	
! 	strcpy(temp_var,xMainNode.getChildNode("print_input_parameters").getText(0));
! 	if (!strncmp("true", temp_var, strlen("true"))) {
! 		print_input_args = true;
! 	} else {
! 		print_input_args = false;
! 	}
! 	
! 	strcpy(temp_var,xMainNode.getChildNode("force_cache_config").getText(0));
! 	if (!strncmp("true", temp_var, strlen("true"))) {
! 		force_cache_config = true;
! 	} else {
! 		force_cache_config = false;
! 	}
! 	
! 	strcpy(temp_var,xMainNode.getChildNode("Ndbl").getText(0));
! 	sscanf(temp_var, "%d", &(ndbl));
! 	
! 	strcpy(temp_var,xMainNode.getChildNode("Ndwl").getText(0));
! 	sscanf(temp_var, "%d", &(ndwl));
! 	
! 	strcpy(temp_var,xMainNode.getChildNode("Nspd").getText(0));
! 	sscanf(temp_var, "%d", &(nspd));
! 	
! 	strcpy(temp_var,xMainNode.getChildNode("Ndsam1").getText(0));
! 	sscanf(temp_var, "%d", &(ndsam1));
! 	
! 	strcpy(temp_var,xMainNode.getChildNode("Ndsam2").getText(0));
! 	sscanf(temp_var, "%d", &(ndsam2));
! 	
! 	strcpy(temp_var,xMainNode.getChildNode("Ndcm").getText(0));
! 	sscanf(temp_var, "%d", &(ndcm));
! 	
! 	strcpy(temp_var,xMainNode.getChildNode("page_size").getText(0));
! 	sscanf(temp_var, "%u", &(page_sz_bits));
! 	
! 	strcpy(temp_var,xMainNode.getChildNode("burst_length").getText(0));
! 	sscanf(temp_var, "%u", &(burst_len));
! 	
! 	strcpy(temp_var,xMainNode.getChildNode("internal_prefetch_width").getText(0));
! 	sscanf(temp_var, "%u", &(int_prefetch_w));
  
! 	/********************  MAJID END  ********************/
  
  	data_arr_ram_cell_tech_type = 0;
  	data_arr_peri_global_tech_type = 0;
  	tag_arr_ram_cell_tech_type = 0;
  	tag_arr_peri_global_tech_type = 0;
  
! 	////////////////////////////////////////////////////////////
!   
    rpters_in_htree = true;
    fclose(fp);
  }
  
!   void
! InputParameter::display_ip()
  {
    cout << "\n----------------------------------------"; // Alireza
    cout << "\n            Input Parameters            "; // Alireza
--- 81,685 ----
    char line[5000];
    char jk[5000];
    char temp_var[5000];
+   double Ioffs[5];
+   double temp_double;
+   char *data = line;
+   int offset= 0;
+ 
  
    if(!fp) {
      cout << in_file << " is missing!\n";
      exit(-1);
    }
  
!   while(fscanf(fp, "%[^\n]\n", line) != EOF) {
! 
!     if (!strncmp("-transistor type", line, strlen("-transistor type"))) {
!       sscanf(line, "-transistor type%[^\"]\"%[^\"]\"", jk, (temp_var));
! 
!       if (!strncmp("finfet", temp_var, strlen("finfet"))) {
!     	  is_finfet = true;
!       }
!       else if (!strncmp("cmos", temp_var, strlen("cmos"))) {
!     	  is_finfet = false;
!       } else {
  			cerr << "ERROR: Invalid transistor type!\nSupported transistor types: 'finfet', 'cmos'.\n";
  			exit(0);
! 	  }
!       continue;
!     }
  
!     if (!strncmp("-technology node", line, strlen("-technology node"))) {
!       sscanf(line, "-technology node %lf", &(F_sz_um));
!       F_sz_nm = F_sz_um*1000;
!       continue;
!     }
  
!     if (!strncmp("-wire technology node", line, strlen("-wire technology node"))) {
!       sscanf(line, "-wire technology node %lf", &(wire_F_sz_um));
!       wire_F_sz_nm = wire_F_sz_um*1000;
!       continue;
!     }
  
!     if (!strncmp("-operating voltage", line, strlen("-operating voltage"))) {
!      sscanf(line, "-operating voltage %lf", &(vdd));
!       continue;
!     }
  
!     if (!strncmp("-DVS(V):", line, strlen("-DVS(V):"))) {
!         memmove (line,line+9,strlen(line));
!     	while (1 == sscanf(data, "%lf%n", &temp_double, &offset)) {
!     		data += offset;
!     		dvs_voltage.push_back(temp_double);
!     	}
!     	continue;
!     }
  
! /*
!     if(!strncmp("-DVS", line, strlen("-DVS"))) {
!       sscanf(line, "-DVS %[^\"]\"%[^\"]\"", jk, temp_var);
!       if (!strncmp("true", temp_var, strlen("true"))) {
!     	  is_dvs = true;
!       } else {
!     	  is_dvs = false;
!       }
! //      cout << "DVS : " << is_dvs << endl;
!       continue;
!     }
! 
!     if (!strncmp("-start-limit", line, strlen("-start-limit"))) {
!       sscanf(line, "-start-limit %lf", &(dvs_start));
! //      cout << "dvs : " << is_dvs << ", start : " << dvs_start;
!       continue;
!     }
!     if (!strncmp("-end-limit", line, strlen("-end-limit"))) {
!       sscanf(line, "-end-limit %lf", &(dvs_end));
! //      cout << ", end : " << dvs_end << endl;
!       continue;
!     }
! */
!     if (!strncmp("-temperature", line, strlen("-temperature"))) {
!        sscanf(line, "-temperature %d", &(temp));
!       continue;
!     }
! 
!     if (!strncmp("-size", line, strlen("-size"))) {
!       sscanf(line, "-size %d", &(cache_sz));
!       continue;
!     }
! 
!     if (!strncmp("-block", line, strlen("-block"))) {
!       sscanf(line, "-block size %d", &(line_sz));
!       continue;
!     }
! 
!     if (!strncmp("-associativity", line, strlen("-associativity"))) {
!       sscanf(line, "-associativity %d", &(assoc));
!       continue;
!     }
! 
!     if(!strncmp("-ncfet", line, strlen("-ncfet"))) {
!       sscanf(line, "-ncfet %[^\"]\"%[^\"]\"", jk, temp_var);
!       if (!strncmp("true", temp_var, strlen("true"))) {
!     	  is_ncfet = true;
!       } else {
!     	  is_ncfet = false;
!       }
! 
!       //ToDo introducing finfet and ncfet cell types
!       //Fixing SRAM cells to 6T1 SRAM model
!       sram_cell_design.setType(std_6T);
!       Nfins[0] = 1;	// access transistor fins
!       Nfins[1] = 1;	// pup fins
!       Nfins[2] = 1; 	// pdn fins
! 
!       //Dual Gate control is being set to false
!       sram_cell_design.setDGcontrol(false);
! 
!       if(is_finfet) {
! 		  //Fixing the transistor parameters acdng to ncfet/finfet type, instead of reading transistor.xml files
! 		  if(is_ncfet) {	//for NCFET
! 			  Lphys[0] = 0.02;	//20-nm access transistor
! 			  Lphys[1] = 0.02;	//20-nm pup
! 			  Lphys[2] = 0.02;	//20-nm pdn
! 
! 			  //NCFET Ioff currents acdng to voltage
! 			  if(vdd == 0.8) {
! 				  Ioffs[0] = 5.836957e-10;	//n-type acc transistor
! 				  Ioffs[1] = 6.39565e-10;	//p-type pup transistor
! 				  Ioffs[2] = 5.836957e-10;	//n-type pdn transistor
! 			  } else if(vdd = 0.7) {
! 				  Ioffs[0] = 6.880435e-10;	//n-type acc transistor
! 				  Ioffs[1] = 7.836957e-10;	//p-type pup transistor
! 				  Ioffs[2] = 6.880435e-10;	//n-type pdn transistor
! 			  } else if(vdd = 0.6) {
! 				  Ioffs[0] = 8.119565e-10;	//n-type acc transistor
! 				  Ioffs[1] = 1.0e-09;		//p-type pup transistor
! 				  Ioffs[2] = 8.119565e-10;	//n-type pdn transistor
! 			  } else if(vdd = 0.5) {
! 				  Ioffs[0] = 1.0e-09;		//n-type acc transistor
! 				  Ioffs[1] = 1.184783e-09;	//p-type pup transistor
! 				  Ioffs[2] = 1.0e-09;		//n-type pdn transistor
! 			  } else if(vdd = 0.4) {
! 				  Ioffs[0] = 1.119565e-09;	//n-type acc transistor
! 				  Ioffs[1] = 1.456522e-09;	//p-type pup transistor
! 				  Ioffs[2] = 1.119565e-09;	//n-type pdn transistor
! 			  } else if(vdd = 0.3) {
! 				  Ioffs[0] = 1.304348e-09;	//n-type acc transistor
! 				  Ioffs[1] = 1.771739e-09;	//p-type pup transistor
! 				  Ioffs[2] = 1.304348e-09;	//n-type pdn transistor
! 			  } else if(vdd = 0.2) {
! 				  Ioffs[0] = 1.51087e-09;	//n-type acc transistor
! 				  Ioffs[1] = 2.163043e-09;	//p-type pup transistor
! 				  Ioffs[2] = 1.51087e-09;	//n-type pdn transistor
! 			  } else
! 				cerr << "ERROR: Invalid transistor type!\nSupported transistor types: 'finfet', 'cmos'.\n";
! 		  }
! 		  else {	//for FinFET
! 			  Lphys[0] = 0.02;	//20-nm access transistor
! 			  Lphys[1] = 0.02;	//20-nm pup
! 			  Lphys[2] = 0.02;	//20-nm pdn
! 
! 			  //FinFET Ioff currents acdng to voltage
! 			  if(vdd == 0.8) {
! 				  Ioffs[0] = 6.684783e-09;	//n-type acc transistor
! 				  Ioffs[1] = 6.478261e-09;	//p-type pup transistor
! 				  Ioffs[2] = 6.684783e-09;	//n-type pdn transistor
! 			  } else if(vdd = 0.7) {
! 				  Ioffs[0] = 5.336957e-09;	//n-type acc transistor
! 				  Ioffs[1] = 5.130435e-09;	//p-type pup transistor
! 				  Ioffs[2] = 5.336957e-09;	//n-type pdn transistor
! 			  } else if(vdd = 0.6) {
! 				  Ioffs[0] = 4.217391e-09;	//n-type acc transistor
! 				  Ioffs[1] = 4.054348e-09;	//p-type pup transistor
! 				  Ioffs[2] = 4.217391e-09;	//n-type pdn transistor
! 			  } else if(vdd = 0.5) {
! 				  Ioffs[0] = 3.304348e-09;		//n-type acc transistor
! 				  Ioffs[1] = 3.195652e-09;	//p-type pup transistor
! 				  Ioffs[2] = 3.304348e-09;		//n-type pdn transistor
! 			  } else if(vdd = 0.4) {
! 				  Ioffs[0] = 2.565217e-09;	//n-type acc transistor
! 				  Ioffs[1] = 2.5e-09;	//p-type pup transistor
! 				  Ioffs[2] = 2.565217e-09;	//n-type pdn transistor
! 			  } else if(vdd = 0.3) {
! 				  Ioffs[0] = 2.0e-09;	//n-type acc transistor
! 				  Ioffs[1] = 2.0e-09;	//p-type pup transistor
! 				  Ioffs[2] = 2.0e-09;	//n-type pdn transistor
! 			  } else if(vdd = 0.2) {
! 				  Ioffs[0] = 1.489133e-09;	//n-type acc transistor
! 				  Ioffs[1] = 1.532609e-09;	//p-type pup transistor
! 				  Ioffs[2] = 1.489133e-09;	//n-type pdn transistor
! 			  } else
! 				cerr << "ERROR: Invalid transistor type!\nSupported transistor types: 'finfet', 'cmos'.\n";
! 		  }
! 		  sram_cell_design.setTransistorParams(Nfins, Lphys, Ioffs);
!       }
!       continue;
!     }
! 
!     if (!strncmp("-read-write", line, strlen("-read-write"))) {
!       sscanf(line, "-read-write port %d", &(num_rw_ports));
!       continue;
!     }
! 
!     if (!strncmp("-exclusive read", line, strlen("exclusive read"))) {
!       sscanf(line, "-exclusive read port %d", &(num_rd_ports));
!       continue;
!     }
! 
!     if(!strncmp("-exclusive write", line, strlen("-exclusive write"))) {
!       sscanf(line, "-exclusive write port %d", &(num_wr_ports));
!       continue;
!     }
! 
!     if (!strncmp("-single ended", line, strlen("-single ended"))) {
!       sscanf(line, "-single %[(:-~)*]%d", jk,
!           &(num_se_rd_ports));
!       continue;
!     }
! 
!     if (!strncmp("-search", line, strlen("-search"))) {
!       sscanf(line, "-search port %d", &(num_search_ports));
!       continue;
!     }
! 
!     if(!strncmp("-cache model", line, strlen("-cache model"))) {
!       sscanf(line, "-cache model %[^\"]\"%[^\"]\"", jk, temp_var);
  
!       if (!strncmp("UCA", temp_var, strlen("UCA"))) {
!         nuca = 0;
!       }
!       else {
!         nuca = 1;
!       }
!       continue;
!     }
! 
!     if (!strncmp("-uca bank", line, strlen("-uca bank"))) {
!       sscanf(line, "-uca bank%[((:-~)| )*]%d", jk, &(nbanks));
!       continue;
!     }
! 
!     if(!strncmp("-nuca bank", line, strlen("-nuca bank"))) {
!       sscanf(line, "-nuca bank count %d", &(nuca_bank_count));
  
+       if (nuca_bank_count != 0) {
+         force_nuca_bank = 1;
+       }
+       continue;
+     }
+ 
+     if (!strncmp("-bus width", line, strlen("-bus width"))) {
+       sscanf(line, "-bus width %d", &(out_w));
+ //      cout << "out_w : " << out_w << " buswidth : " << line << endl;
+       continue;
+     }
+ 
+     if (!strncmp("-memory type", line, strlen("-memory type"))) {
+       sscanf(line, "-memory type%[^\"]\"%[^\"]\"", jk, temp_var);
+ 
+       if (!strncmp("cache", temp_var, sizeof("cache"))) {
+         is_cache = true;
+       }
+       else
+       {
+         is_cache = false;
+       }
+ 
+       if (!strncmp("main memory", temp_var, sizeof("main memory"))) {
+         is_main_mem = true;
+       }
+       else {
+         is_main_mem = false;
+       }
+ 
+       if (!strncmp("cam", temp_var, sizeof("cam"))) {
+         pure_cam = true;
+       }
+       else {
+         pure_cam = false;
+       }
+ 
+       if (!strncmp("ram", temp_var, sizeof("ram"))) {
+         pure_ram = true;
+       }
+       else {
+     	  if (!is_main_mem)
+     		  pure_ram = false;
+     	  else
+     		  pure_ram = true;
+       }
+       continue;
+     }
+ 
+     if (!strncmp("-tag size", line, strlen("-tag size"))) {
+       sscanf(line, "-tag size%[^\"]\"%[^\"]\"", jk, temp_var);
+       if (!strncmp("default", temp_var, sizeof("default"))) {
+         specific_tag = false;
+         tag_w = 42; /* the actual value is calculated
+                      * later based on the cache size, bank count, and associativity
+                      */
+       }
+       else {
+         specific_tag = true;
+         sscanf(line, "-tag size %d", &(tag_w));
+ //        cout << "tag : " << tag_w << endl;
+       }
+       continue;
+     }
+ 
+     if (!strncmp("-access mode", line, strlen("-access mode"))) {
+       sscanf(line, "-access %[^\"]\"%[^\"]\"", jk, temp_var);
+       if (!strncmp("fast", temp_var, strlen("fast"))) {
+         access_mode = 2;
+       } else if (!strncmp("sequential", temp_var, strlen("sequential"))) {
+         access_mode = 1;
+       } else if(!strncmp("normal", temp_var, strlen("normal"))) {
+         access_mode = 0;
+       } else {
+         cout << "ERROR: Invalid access mode!\n";
+         exit(0);
+       }
+       continue;
+     }
+ 
+     if(!strncmp("-optimize", line, strlen("-optimize"))) {
+       sscanf(line, "-optimize  %[^\"]\"%[^\"]\"", jk, temp_var);
+ 
+       if(!strncmp("ED^2", temp_var, strlen("ED^2"))) {
+         ed = 2;
+       }
+       else if(!strncmp("ED", temp_var, strlen("ED"))) {
+         ed = 1;
+       }
+       else {
+         ed = 0;
+       }
+     }
+ 
+     if(!strncmp("-design", line, strlen("-design"))) {
+       sscanf(line, "-%[((:-~)| |,)*]%d:%d:%d:%d:%d", jk,
+           &(delay_wt), &(dynamic_power_wt),
+           &(leakage_power_wt),
+           &(cycle_time_wt), &(area_wt));
+       continue;
+     }
+ 
+     if(!strncmp("-deviate", line, strlen("-deviate"))) {
+       sscanf(line, "-%[((:-~)| |,)*]%d:%d:%d:%d:%d", jk,
+           &(delay_dev), &(dynamic_power_dev),
+           &(leakage_power_dev),
+           &(cycle_time_dev), &(area_dev));
+       continue;
+     }
+ 
+     if(!strncmp("-NUCAdesign", line, strlen("-NUCAdesign"))) {
+       sscanf(line, "-%[((:-~)| |,)*]%d:%d:%d:%d:%d", jk,
+           &(delay_wt_nuca), &(dynamic_power_wt_nuca),
+           &(leakage_power_wt_nuca),
+           &(cycle_time_wt_nuca), &(area_wt_nuca));
+       continue;
+     }
+ 
+     if(!strncmp("-NUCAdeviate", line, strlen("-NUCAdeviate"))) {
+       sscanf(line, "-%[((:-~)| |,)*]%d:%d:%d:%d:%d", jk,
+           &(delay_dev_nuca), &(dynamic_power_dev_nuca),
+           &(leakage_power_dev_nuca),
+           &(cycle_time_dev_nuca), &(area_dev_nuca));
+       continue;
+     }
+ 
+     if(!strncmp("-interconnects", line, strlen("-interconnects"))) {
+         sscanf(line, "-interconnects  %[^\"]\"%[^\"]\"", jk, temp_var);
+     	if (!strncmp("ITRS2012", temp_var, strlen("ITRS2012"))) {
+     		is_itrs2012 = true;
+     		is_asap7 = false;
+     	} else if (!strncmp("RonHo2003", temp_var, strlen("RonHo2003"))) {
+     		is_itrs2012 = false;
+     		is_asap7 = false;
+     	} else if (!strncmp("ASAP7", temp_var, strlen("ASAP7"))) {
+     		is_asap7 = true;
+     		is_itrs2012 = false;
+     	}else {
+     		cout << "ERROR: Invalid interconnect source!\n";
+     		exit(0);
+     	}
+     	continue;
+     }
+ 
+     if(!strncmp("-wire signalling", line, strlen("-wire signalling"))) {
+       sscanf(line, "-wire%[^\"]\"%[^\"]\"", jk, temp_var);
+ 
+       if (!strncmp("default", temp_var, strlen("default"))) {
+         force_wiretype = 0;
+         wt = Global;
+       }
+       else if (!(strncmp("Global_10", temp_var, strlen("Global_10")))) {
+         force_wiretype = 1;
+         wt = Global_10;
+       }
+       else if (!(strncmp("Global_20", temp_var, strlen("Global_20")))) {
+         force_wiretype = 1;
+         wt = Global_20;
+       }
+       else if (!(strncmp("Global_30", temp_var, strlen("Global_30")))) {
+         force_wiretype = 1;
+         wt = Global_30;
+       }
+       else if (!(strncmp("Global_5", temp_var, strlen("Global_5")))) {
+         force_wiretype = 1;
+         wt = Global_5;
+       }
+       else if (!(strncmp("Global", temp_var, strlen("Global")))) {
+         force_wiretype = 1;
+         wt = Global;
+       }
+       else {
+         wt = Low_swing;
+         force_wiretype = 1;
+       }
+       continue;
+     }
+ 
+     if(!strncmp("-Wire inside mat", line, strlen("-Wire inside mat"))) {
+       sscanf(line, "-Wire%[^\"]\"%[^\"]\"", jk, temp_var);
+ 
+       if (!strncmp("global", temp_var, strlen("global"))) {
+         wire_is_mat_type = 2;
+         continue;
+       }
+       else if (!strncmp("local", temp_var, strlen("local"))) {
+         wire_is_mat_type = 0;
+         continue;
+       }
+       else {
+         wire_is_mat_type = 1;
+         continue;
+       }
+     }
+ 
+     if(!strncmp("-Wire outside mat", line, strlen("-Wire outside mat"))) {
+       sscanf(line, "-Wire%[^\"]\"%[^\"]\"", jk, temp_var);
+ 
+       if (!strncmp("global", temp_var, strlen("global"))) {
+         wire_os_mat_type = 2;
+       }
+       else {
+         wire_os_mat_type = 1;
+       }
+       continue;
+     }
+ 
+     if(!strncmp("-Interconnect projection", line, strlen("-Interconnect projection"))) {
+       sscanf(line, "-Interconnect projection%[^\"]\"%[^\"]\"", jk, temp_var);
+ 
+       if (!strncmp("aggressive", temp_var, strlen("aggressive"))) {
+         ic_proj_type = 0;
+       }
+       else {
+         ic_proj_type = 1;
+       }
+       continue;
+     }
+ 
+     if(!strncmp("-Core", line, strlen("-Core"))) {
+       sscanf(line, "-Core count %d\n", &(cores));
+       if (cores > 16) {
+         printf("No. of cores should be less than 16!\n");
+       }
+       continue;
+     }
+ 
+     if(!strncmp("-Cache level", line, strlen("-Cache level"))) {
+       sscanf(line, "-Cache l%[^\"]\"%[^\"]\"", jk, temp_var);
+       if (!strncmp("L2", temp_var, strlen("L2"))) {
+         cache_level = 0;
+       }
+       else {
+         cache_level = 1;
+       }
+       continue;
+     }
+ 
+     if(!strncmp("-Add ECC", line, strlen("-Add ECC"))) {
+       sscanf(line, "-Add ECC %[^\"]\"%[^\"]\"", jk, temp_var);
+       if (!strncmp("true", temp_var, strlen("true"))) {
+         add_ecc_b_ = true;
+       }
+       else {
+         add_ecc_b_ = false;
+       }
+       continue;
+     }
+ 
+     if(!strncmp("-Print level", line, strlen("-Print level"))) {
+       sscanf(line, "-Print l%[^\"]\"%[^\"]\"", jk, temp_var);
+       if (!strncmp("DETAILED", temp_var, strlen("DETAILED"))) {
+         print_detail = 1;
+       }
+       else {
+         print_detail = 0;
+       }
+       continue;
+     }
+ 
+     if(!strncmp("-Print input parameters", line, strlen("-Print input parameters"))) {
+       sscanf(line, "-Print input %[^\"]\"%[^\"]\"", jk, temp_var);
+       if (!strncmp("true", temp_var, strlen("true"))) {
+         print_input_args = true;
+       }
+       else {
+         print_input_args = false;
+       }
+     }
+ 
+     if(!strncmp("-Force cache config", line, strlen("-Force cache config"))) {
+       sscanf(line, "-Force cache %[^\"]\"%[^\"]\"", jk, temp_var);
+       if (!strncmp("true", temp_var, strlen("true"))) {
+         force_cache_config = true;
+       }
+       else {
+         force_cache_config = false;
+       }
+     }
+ 
+     if(!strncmp("-Ndbl", line, strlen("-Ndbl"))) {
+       sscanf(line, "-Ndbl %d\n", &(ndbl));
+       continue;
+     }
+     if(!strncmp("-Ndwl", line, strlen("-Ndwl"))) {
+       sscanf(line, "-Ndwl %d\n", &(ndwl));
+       continue;
+     }
+     if(!strncmp("-Nspd", line, strlen("-Nspd"))) {
+       sscanf(line, "-Nspd %d\n", &(nspd));
+       continue;
+     }
+     if(!strncmp("-Ndsam1", line, strlen("-Ndsam1"))) {
+       sscanf(line, "-Ndsam1 %d\n", &(ndsam1));
+       continue;
+     }
+     if(!strncmp("-Ndsam2", line, strlen("-Ndsam2"))) {
+       sscanf(line, "-Ndsam2 %d\n", &(ndsam2));
+       continue;
+     }
+     if(!strncmp("-Ndcm", line, strlen("-Ndcm"))) {
+ 		  sscanf(line, "-Ndcm %d\n", &(ndcm));
+ 		  continue;
+ 		}
+ 
+ 	   if(!strncmp("-Ntbl", line, strlen("-Ntbl"))) {
+ 		 sscanf(line, "-Ntbl %d\n", &(ntbl));
+ 		 continue;
+ 	   }
+ 	   if(!strncmp("-Ntwl", line, strlen("-Ntwl"))) {
+ 		 sscanf(line, "-Ntwl %d\n", &(ntwl));
+ 		 continue;
+ 	   }
+ 	   if(!strncmp("-Ntspd", line, strlen("-Ntspd"))) {
+ 		 sscanf(line, "-Ntspd %d\n", &(ntspd));
+ 		 continue;
+ 	   }
+ 	   if(!strncmp("-Ntsam1", line, strlen("-Ntsam1"))) {
+ 		 sscanf(line, "-Ntsam1 %d\n", &(ntsam1));
+ 		 continue;
+ 	   }
+ 	   if(!strncmp("-Ntsam2", line, strlen("-Ntsam2"))) {
+ 		 sscanf(line, "-Ntsam2 %d\n", &(ntsam2));
+ 		 continue;
+ 	   }
+ 	  if(!strncmp("-Ntcm", line, strlen("-Ntcm"))) {
+ 		 sscanf(line, "-Ntcm %d\n", &(ntcm));
+ 		 continue;
+ 	  }
+ 
+ 	  if (!strncmp("-page size", line, strlen("-page size"))) {
+ 		sscanf(line, "-page size %[(:-~)*]%u", jk, &(page_sz_bits));
+ 		continue;
+ 	  }
+ 
+ 	  if (!strncmp("-burst length", line, strlen("-burst length"))) {
+ 		sscanf(line, "-burst %[(:-~)*]%u", jk, &(burst_len));
+ 		continue;
+ 	  }
+ 
+ 	  if (!strncmp("-internal prefetch width", line, strlen("-internal prefetch width"))) {
+ 		sscanf(line, "-internal prefetch %[(:-~)*]%u", jk, &(int_prefetch_w));
+ 		continue;
+ 	  }
+   }
  	data_arr_ram_cell_tech_type = 0;
  	data_arr_peri_global_tech_type = 0;
  	tag_arr_ram_cell_tech_type = 0;
  	tag_arr_peri_global_tech_type = 0;
  
! 
    rpters_in_htree = true;
    fclose(fp);
  }
+ //divya end
  
! void InputParameter::display_ip()
  {
    cout << "\n----------------------------------------"; // Alireza
    cout << "\n            Input Parameters            "; // Alireza
***************
*** 546,569 ****
    cout << "Write only ports              : " << num_wr_ports << endl;
    cout << "Read write ports              : " << num_rw_ports << endl;
    cout << "Single ended read ports       : " << num_se_rd_ports << endl;
    cout << "Cache banks (UCA)             : " << nbanks << endl;
    cout << "Technology                    : " << F_sz_nm << "nm" << endl; // changed to nm. -Alireza
    cout << "Transistor type               : " << (is_finfet ? "FinFET" : "CMOS" ) << endl; // Alireza
!   cout << "Operating voltage             : " << (is_near_threshold ? "Near-threshold" : "Super-threshold" ) << endl; // Alireza
!   if (g_ip->sram_cell_design.getType()==std_6T) { // Alireza
      cout << "SRAM cell type                : " << "Standard 6T" << endl;
    } else if (g_ip->sram_cell_design.getType()==std_8T) {
      cout << "SRAM cell type                : " << "Standard 8T" << endl;
    }
!   cout << "Temperature                   : " << temp << "K" << endl; // Alireza
    cout << "Tag size                      : " << tag_w << endl;
    if (is_cache) {
      cout << "cache type                    : " << "Cache" << endl;
!   } else if (is_main_mem) {
      cout << "cache type                    : " << "Main Memory" << endl; // Alireza
!   } else { // Alireza
      cout << "cache type                    : " << "Scratch RAM" << endl;
    }
    //cout << "Model as memory               : " << is_main_mem << endl;  // Alireza
    cout << "Access mode                   : " << access_mode << endl;
    cout << "Data array cell type          : " << data_arr_ram_cell_tech_type << endl;
--- 691,727 ----
    cout << "Write only ports              : " << num_wr_ports << endl;
    cout << "Read write ports              : " << num_rw_ports << endl;
    cout << "Single ended read ports       : " << num_se_rd_ports << endl;
+   if (fully_assoc||pure_cam)
+   {
+ 	  cout << "Search ports                  : " << num_search_ports << endl;
+   }
    cout << "Cache banks (UCA)             : " << nbanks << endl;
    cout << "Technology                    : " << F_sz_nm << "nm" << endl; // changed to nm. -Alireza
    cout << "Transistor type               : " << (is_finfet ? "FinFET" : "CMOS" ) << endl; // Alireza
!   if(is_finfet)
! 	  cout << "NCFET (1) or FinFET (0): " << is_ncfet << endl;
! //  cout << "Operating voltage             : " << (is_near_threshold ? "Near-threshold" : "Super-threshold" ) << endl; // Alireza
!     cout << "Operating voltage             : " << vdd << endl; // Alireza
! /* 	if (g_ip->sram_cell_design.getType()==std_6T) { // Alireza
      cout << "SRAM cell type                : " << "Standard 6T" << endl;
    } else if (g_ip->sram_cell_design.getType()==std_8T) {
      cout << "SRAM cell type                : " << "Standard 8T" << endl;
    }
! */
!     cout << "Temperature                   : " << temp << "K" << endl; // Alireza
    cout << "Tag size                      : " << tag_w << endl;
    if (is_cache) {
      cout << "cache type                    : " << "Cache" << endl;
!   }
!   if (is_main_mem) {
      cout << "cache type                    : " << "Main Memory" << endl; // Alireza
!   }
!   if(pure_ram){ // Alireza
      cout << "cache type                    : " << "Scratch RAM" << endl;
    }
+   if(pure_cam)  {
+       cout << "array type                    : " << "CAM" << endl;
+   }
    //cout << "Model as memory               : " << is_main_mem << endl;  // Alireza
    cout << "Access mode                   : " << access_mode << endl;
    cout << "Data array cell type          : " << data_arr_ram_cell_tech_type << endl;
***************
*** 587,593 ****
    cout << "Wire inside mat               : " << wire_is_mat_type << endl;
    cout << "Wire outside mat              : " << wire_os_mat_type << endl;
    cout << "Interconnect projection       : " << ic_proj_type << endl;
!   cout << "Wire signalling               : " << force_wiretype << endl;
    cout << "Cores                         : " << cores << endl;
    cout << "Print details                 : " << (print_detail ? "Yes" : "No" ) << endl; // Alireza
    cout << "ECC overhead                  : " << (add_ecc_b_ ? "Yes" : "No" ) << endl; // Alireza
--- 745,752 ----
    cout << "Wire inside mat               : " << wire_is_mat_type << endl;
    cout << "Wire outside mat              : " << wire_os_mat_type << endl;
    cout << "Interconnect projection       : " << ic_proj_type << endl;
!   cout << "Wire signalling               : " << wt << endl;
!   cout << "Force Wire type				 : " << force_wiretype << endl;
    cout << "Cores                         : " << cores << endl;
    cout << "Print details                 : " << (print_detail ? "Yes" : "No" ) << endl; // Alireza
    cout << "ECC overhead                  : " << (add_ecc_b_ ? "Yes" : "No" ) << endl; // Alireza
***************
*** 595,600 ****
--- 754,760 ----
    cout << "Burst length                  : " << burst_len << endl;
    cout << "Internal prefetch width       : " << int_prefetch_w << endl;
    cout << "Force cache config            : " << (g_ip->force_cache_config ? "Yes" : "No" ) << endl; // Alireza
+   cout << "Optimization Goal			 : " << g_ip->ed << endl;
    if (g_ip->force_cache_config) {
      cout << "Ndwl                          : " << g_ip->ndwl << endl;
      cout << "Ndbl                          : " << g_ip->ndbl << endl;
***************
*** 603,612 ****
      cout << "Ndsam1                        : " << g_ip->ndsam1 << endl;
      cout << "Ndsam2                        : " << g_ip->ndsam2 << endl;
    }
  }
  
- 
- 
  powerComponents operator+(const powerComponents & x, const powerComponents & y)
  {
    powerComponents z;
--- 763,771 ----
      cout << "Ndsam1                        : " << g_ip->ndsam1 << endl;
      cout << "Ndsam2                        : " << g_ip->ndsam2 << endl;
    }
+   cout << "Bus width			: " << g_ip->out_w << endl;
  }
  
  powerComponents operator+(const powerComponents & x, const powerComponents & y)
  {
    powerComponents z;
***************
*** 617,623 ****
--- 776,790 ----
    return z;
  }
  
+ powerComponents operator*(const powerComponents & x, double const * const y)
+ {
+   powerComponents z;
  
+   z.dynamic = x.dynamic*y[0];
+   z.leakage = x.leakage*y[1];
+ 
+   return z;
+ }
  
  powerDef operator+(const powerDef & x, const powerDef & y)
  {
***************
*** 625,669 ****
  
    z.readOp  = x.readOp  + y.readOp;
    z.writeOp = x.writeOp + y.writeOp;
  
    return z;
  }
  
  
  
  uca_org_t cacti_interface(const string & infile_name)
  {
    uca_org_t fin_res;
- //  uca_org_t result;
    fin_res.valid = false;
  
    g_ip = new InputParameter();
    g_ip->parse_cfg(infile_name);
!   
    if (g_ip->error_checking() == false) { cout << "ERROR: Invalid input parameters!\n", exit(0); }
!   if (g_ip->print_input_args) g_ip->display_ip();
  
-   init_tech_params(g_ip->F_sz_um, false);
    if (g_ip->print_input_args) g_tp.display(); // Alireza
    
    Wire winit; // Do not delete this line. It initializes wires.
    
-   //g_ip->sram_cell_design.print_transistor_params();
-   //cout << g_ip->sram_cell_design.getPleakCCInv(g_tp.sram_cell.Vdd, g_tp.sram_cell.H_fin) << endl;
-   //cout << g_ip->sram_cell_design.getPleakAccTx(g_tp.sram_cell.Vdd, g_tp.sram_cell.H_fin) << endl;
- 
    if (g_ip->nuca == 1)
    {
      Nuca n(&g_tp.peri_global);
      n.sim_nuca();
    }
  //  g_ip->display_ip();
    solve(&fin_res);
  
    output_UCA(&fin_res);
    //output_summary_of_results(&fin_res);
    output_summary_of_results_file(&fin_res);
  
    delete (g_ip);
    return fin_res;
  }
--- 792,860 ----
  
    z.readOp  = x.readOp  + y.readOp;
    z.writeOp = x.writeOp + y.writeOp;
+   z.searchOp = x.searchOp + y.searchOp;
  
    return z;
  }
  
+ powerDef operator*(const powerDef & x, double const * const y)
+ {
+   powerDef z;
+ 
+   z.readOp   = x.readOp*y;
+   z.writeOp  = x.writeOp*y;
+   z.searchOp = x.searchOp*y;
+   return z;
+ }
  
  
  uca_org_t cacti_interface(const string & infile_name)
  {
    uca_org_t fin_res;
    fin_res.valid = false;
  
    g_ip = new InputParameter();
    g_ip->parse_cfg(infile_name);
! //  cout << "parsing file done \n" ;
! 
    if (g_ip->error_checking() == false) { cout << "ERROR: Invalid input parameters!\n", exit(0); }
!   if (g_ip->print_input_args)
! 	  g_ip->display_ip();
! 
! //  init_tech_params(g_ip->F_sz_um, false);
!   init_tech_params(g_ip->F_sz_um, g_ip->wire_F_sz_um, false); //Divya added wire_technology
! //  cout << "tech params done \n" ;
  
    if (g_ip->print_input_args) g_tp.display(); // Alireza
    
    Wire winit; // Do not delete this line. It initializes wires.
    
    if (g_ip->nuca == 1)
    {
      Nuca n(&g_tp.peri_global);
      n.sim_nuca();
    }
  //  g_ip->display_ip();
+ //  cout << "entering solve \n" ;
    solve(&fin_res);
+   Wire wprint;//reset wires to original configuration as in *.cfg file (dvs level 0)
+ 
+   //Divya begin
+ //  if (g_ip->is_dvs)
+   if (!g_ip->dvs_voltage.empty())
+    {
+  	  update_dvs(&fin_res);
+    }
+   //Divya end
  
    output_UCA(&fin_res);
    //output_summary_of_results(&fin_res);
    output_summary_of_results_file(&fin_res);
  
+ //  Wire wprint;//reset wires to original configuration as in *.cfg file (dvs level 0)
+   //Wire::print_wire();
+   wprint.print_wire();
+ 
    delete (g_ip);
    return fin_res;
  }
***************
*** 845,851 ****
    if (g_ip->error_checking() == false) exit(0);
    if (g_ip->print_input_args) 
      g_ip->display_ip();
!   init_tech_params(g_ip->F_sz_um, false);
    Wire winit; // Do not delete this line. It initializes wires.
  
    if (g_ip->nuca == 1)
--- 1036,1044 ----
    if (g_ip->error_checking() == false) exit(0);
    if (g_ip->print_input_args) 
      g_ip->display_ip();
! //  init_tech_params(g_ip->F_sz_um, false);
!   init_tech_params(g_ip->F_sz_um, g_ip->wire_F_sz_um, false); //divya added wire technology
! 
    Wire winit; // Do not delete this line. It initializes wires.
  
    if (g_ip->nuca == 1)
***************
*** 862,875 ****
    return fin_res;
  }
  
  
  
  bool InputParameter::error_checking()
  {
    int  A;
    bool seq_access  = false;
    fast_access = true;
!   
    ///if ( (is_finfet && F_sz_nm != 7) || (!is_finfet && F_sz_nm == 7) ) // Alireza
    ///  return false;
    
--- 1055,1251 ----
    return fin_res;
  }
  
+ //divya added 14-11-2021
+ //McPAT's plain interface by parameter passing, please keep !!!
+ uca_org_t cacti_interface(
+     int cache_size,
+     int line_size,
+     int associativity,
+     int rw_ports,
+     int excl_read_ports,// para5
+     int excl_write_ports,
+     int single_ended_read_ports,
+     int search_ports,
+     int banks,
+     double tech_node,//para10
+     int output_width,
+     int specific_tag,
+     int tag_width,
+     int access_mode,
+     int cache,      //para15
+     int main_mem,
+     int obj_func_delay,
+     int obj_func_dynamic_power,
+     int obj_func_leakage_power,
+     int obj_func_cycle_time, //para20
+     int obj_func_area,
+     int dev_func_delay,
+     int dev_func_dynamic_power,
+     int dev_func_leakage_power,
+     int dev_func_area, //para25
+     int dev_func_cycle_time,
+     int ed_ed2_none, // 0 - ED, 1 - ED^2, 2 - use weight and deviate
+     int temp,
+     int wt, //0 - default(search across everything), 1 - global, 2 - 5% delay penalty, 3 - 10%, 4 - 20 %, 5 - 30%, 6 - low-swing
+     int data_arr_ram_cell_tech_flavor_in,//para30
+     int data_arr_peri_global_tech_flavor_in,
+     int tag_arr_ram_cell_tech_flavor_in,
+     int tag_arr_peri_global_tech_flavor_in,
+     int interconnect_projection_type_in,
+     int wire_inside_mat_type_in,//para35
+     int wire_outside_mat_type_in,
+     int REPEATERS_IN_HTREE_SEGMENTS_in,
+     int VERTICAL_HTREE_WIRES_OVER_THE_ARRAY_in,
+     int BROADCAST_ADDR_DATAIN_OVER_VERTICAL_HTREES_in,
+     int PAGE_SIZE_BITS_in,//para40
+     int BURST_LENGTH_in,
+     int INTERNAL_PREFETCH_WIDTH_in,
+     int force_wiretype,
+     int wiretype,
+     int force_config,//para45
+     int ndwl,
+     int ndbl,
+     int nspd,
+     int ndcm,
+     int ndsam1,//para50
+     int ndsam2,
+     int ecc)
+ {
+   g_ip = new InputParameter();
+ 
+   uca_org_t fin_res;
+   fin_res.valid = false;
+ 
+   g_ip->data_arr_ram_cell_tech_type    = data_arr_ram_cell_tech_flavor_in;
+   g_ip->data_arr_peri_global_tech_type = data_arr_peri_global_tech_flavor_in;
+   g_ip->tag_arr_ram_cell_tech_type     = tag_arr_ram_cell_tech_flavor_in;
+   g_ip->tag_arr_peri_global_tech_type  = tag_arr_peri_global_tech_flavor_in;
+ 
+   g_ip->ic_proj_type     = interconnect_projection_type_in;
+   g_ip->wire_is_mat_type = wire_inside_mat_type_in;
+   g_ip->wire_os_mat_type = wire_outside_mat_type_in;
+   g_ip->burst_len        = BURST_LENGTH_in;
+   g_ip->int_prefetch_w   = INTERNAL_PREFETCH_WIDTH_in;
+   g_ip->page_sz_bits     = PAGE_SIZE_BITS_in;
+ 
+   g_ip->cache_sz            = cache_size;
+   g_ip->line_sz             = line_size;
+   g_ip->assoc               = associativity;
+   g_ip->nbanks              = banks;
+   g_ip->out_w               = output_width;
+   g_ip->specific_tag        = specific_tag;
+   if (specific_tag == 0) {
+     g_ip->tag_w = 42;
+   }
+   else {
+     g_ip->tag_w               = tag_width;
+   }
  
+   g_ip->access_mode         = access_mode;
+   g_ip->delay_wt = obj_func_delay;
+   g_ip->dynamic_power_wt = obj_func_dynamic_power;
+   g_ip->leakage_power_wt = obj_func_leakage_power;
+   g_ip->area_wt = obj_func_area;
+   g_ip->cycle_time_wt    = obj_func_cycle_time;
+   g_ip->delay_dev = dev_func_delay;
+   g_ip->dynamic_power_dev = dev_func_dynamic_power;
+   g_ip->leakage_power_dev = dev_func_leakage_power;
+   g_ip->area_dev = dev_func_area;
+   g_ip->cycle_time_dev    = dev_func_cycle_time;
+   g_ip->temp = temp;
+   g_ip->ed = ed_ed2_none;
+ 
+   g_ip->F_sz_nm         = tech_node;
+   g_ip->F_sz_um         = tech_node / 1000;
+   g_ip->is_main_mem     = (main_mem != 0) ? true : false;
+   g_ip->is_cache        = (cache ==1) ? true : false;
+   g_ip->pure_ram        = (cache ==0) ? true : false;
+   g_ip->pure_cam        = (cache ==2) ? true : false;
+   g_ip->rpters_in_htree = (REPEATERS_IN_HTREE_SEGMENTS_in != 0) ? true : false;
+   g_ip->ver_htree_wires_over_array = VERTICAL_HTREE_WIRES_OVER_THE_ARRAY_in;
+   g_ip->broadcast_addr_din_over_ver_htrees = BROADCAST_ADDR_DATAIN_OVER_VERTICAL_HTREES_in;
+ 
+   g_ip->num_rw_ports    = rw_ports;
+   g_ip->num_rd_ports    = excl_read_ports;
+   g_ip->num_wr_ports    = excl_write_ports;
+   g_ip->num_se_rd_ports = single_ended_read_ports;
+   g_ip->num_search_ports = search_ports;
+ 
+   g_ip->print_detail = 1;
+   g_ip->nuca = 0;
+ 
+   if (force_wiretype == 0)
+   {
+ 	  g_ip->wt = Global;
+       g_ip->force_wiretype = false;
+   }
+   else
+   {   g_ip->force_wiretype = true;
+ 	  if (wiretype==10) {
+ 		  g_ip->wt = Global_10;
+ 	        }
+ 	  if (wiretype==20) {
+ 		  g_ip->wt = Global_20;
+ 	        }
+ 	  if (wiretype==30) {
+ 		  g_ip->wt = Global_30;
+ 	        }
+ 	  if (wiretype==5) {
+ 	      g_ip->wt = Global_5;
+ 	        }
+ 	  if (wiretype==0) {
+ 		  g_ip->wt = Low_swing;
+ 	  }
+   }
+   //g_ip->wt = Global_5;
+   if (force_config == 0)
+     {
+   	  g_ip->force_cache_config = false;
+     }
+     else
+     {
+     	g_ip->force_cache_config = true;
+     	g_ip->ndbl=ndbl;
+     	g_ip->ndwl=ndwl;
+     	g_ip->nspd=nspd;
+     	g_ip->ndcm=ndcm;
+     	g_ip->ndsam1=ndsam1;
+     	g_ip->ndsam2=ndsam2;
+     }
+ 
+   if (ecc==0){
+ 	  g_ip->add_ecc_b_=false;
+   }
+   else
+   {
+ 	  g_ip->add_ecc_b_=true;
+   }
+ 
+ 
+   if(!g_ip->error_checking())
+ 	  exit(0);
+ 
+ //  init_tech_params(g_ip->F_sz_um, false);
+   init_tech_params(g_ip->F_sz_um, g_ip->wire_F_sz_um, false); //Divya added wire_technology
+ Wire winit; // Do not delete this line. It initializes wires.
+ 
+   g_ip->display_ip();
+   solve(&fin_res);
+   output_UCA(&fin_res);
+   output_data_csv(fin_res);
+   delete (g_ip);
+ 
+   return fin_res;
+ }
+ //divya end
  
  bool InputParameter::error_checking()
  {
    int  A;
    bool seq_access  = false;
    fast_access = true;
!   fully_assoc = false;
! 
    ///if ( (is_finfet && F_sz_nm != 7) || (!is_finfet && F_sz_nm == 7) ) // Alireza
    ///  return false;
    
***************
*** 932,958 ****
    uint32_t ERP  = num_rd_ports;
    uint32_t EWP  = num_wr_ports;
    uint32_t NSER = num_se_rd_ports;
! 
! //  // If multiple banks and multiple ports are specified, then if number of ports is less than or equal to
! //  // the number of banks, we assume that the multiple ports are implemented via the multiple banks.
! //  // In such a case we assume that each bank has 1 RWP port. 
! //  if ((RWP + ERP + EWP) <= nbanks)
! //  {
! //    RWP  = 1;
! //    ERP  = 0;
! //    EWP  = 0;
! //    NSER = 0;
! //  }
! //  else if ((RWP < 0) || (EWP < 0) || (ERP < 0))
! //  {
! //    cerr << "Ports must >=0" << endl;
! //    return false;
! //  }
! //  else if (RWP > 2)
! //  {
! //    cerr << "Maximum of 2 read/write ports" << endl;
! //    return false;
! //  }
  
    //  The number of ports specified at input is per bank
    if ((RWP+ERP+EWP) < 1)
--- 1308,1314 ----
    uint32_t ERP  = num_rd_ports;
    uint32_t EWP  = num_wr_ports;
    uint32_t NSER = num_se_rd_ports;
!   uint32_t SCHP = num_search_ports;
  
    //  The number of ports specified at input is per bank
    if ((RWP+ERP+EWP) < 1)
***************
*** 973,994 ****
      cerr << "Cache size must >=64" << endl;
      return false;
    }
  
    if (assoc == 0)
    {
      A = C/B;
!     fully_assoc = true;
    }
    else
    {
      if (assoc == 1)
      {
        A = 1;
!       fully_assoc = false;
      }
      else
      {
!       fully_assoc = false;
        A = assoc;
        if (is_pow2(A) == false)
        {
--- 1329,1402 ----
      cerr << "Cache size must >=64" << endl;
      return false;
    }
+   //added 10-11-2021 divya acdng to McPAT-CACTI
+   //fully assoc and cam check
+   if (is_cache && assoc==0)
+   	fully_assoc =true;
+   else
+   	fully_assoc = false;
+ 
+   if (pure_cam==true && assoc!=0)
+   {
+ 	  cerr << "Pure CAM must have associativity as 0" << endl;
+ 	  return false;
+   }
+ 
+   if (assoc==0 && (pure_cam==false && is_cache ==false))
+   {
+ 	  cerr << "Only CAM or Fully associative cache can have associativity as 0" << endl;
+ 	  return false;
+   }
+ 
+   if ((fully_assoc==true || pure_cam==true)
+ 		  &&  (data_arr_ram_cell_tech_type!= tag_arr_ram_cell_tech_type
+ 				 || data_arr_peri_global_tech_type != tag_arr_peri_global_tech_type  ))
+   {
+ 	  cerr << "CAM and fully associative cache must have same device type for both data and tag array" << endl;
+ 	  return false;
+   }
+ 
+   if ((fully_assoc==true || pure_cam==true)
+ 		  &&  (data_arr_ram_cell_tech_type== lp_dram || data_arr_ram_cell_tech_type== comm_dram))
+   {
+ 	  cerr << "DRAM based CAM and fully associative cache are not supported" << endl;
+ 	  return false;
+   }
+ 
+   if ((fully_assoc==true || pure_cam==true)
+ 		  &&  (is_main_mem==true))
+   {
+ 	  cerr << "CAM and fully associative cache cannot be as main memory" << endl;
+ 	  return false;
+   }
+ 
+   if ((fully_assoc || pure_cam) && SCHP<1)
+   {
+ 	  cerr << "CAM and fully associative must have at least 1 search port" << endl;
+ 	  return false;
+   }
+ 
+  if (RWP==0 && ERP==0 && SCHP>0 && ((fully_assoc || pure_cam)))
+   {
+ 	  ERP=SCHP;
+   }
+ 
  
    if (assoc == 0)
    {
      A = C/B;
!     //fully_assoc = true;
    }
    else
    {
      if (assoc == 1)
      {
        A = 1;
!       //fully_assoc = false;
      }
      else
      {
!       //fully_assoc = false;
        A = assoc;
        if (is_pow2(A) == false)
        {
***************
*** 998,1004 ****
      }
    }
  
!   if (C/(B*A) <= 1 && !fully_assoc)
    {
      cerr << "Number of sets is too small: " << endl;
      cerr << " Need to either increase cache size, or decrease associativity or block size" << endl;
--- 1406,1413 ----
      }
    }
  
! //  if (C/(B*A) <= 1 && !fully_assoc)
!   if (C/(B*A) <= 1 && assoc!=0)
    {
      cerr << "Number of sets is too small: " << endl;
      cerr << " Need to either increase cache size, or decrease associativity or block size" << endl;
***************
*** 1022,1028 ****
      is_seq_acc = false;
    }
  
!   if (fully_assoc)
    {
      data_assoc = 1;
    }
--- 1431,1437 ----
      is_seq_acc = false;
    }
  
!   if (assoc==0)
    {
      data_assoc = 1;
    }
***************
*** 1030,1035 ****
--- 1439,1446 ----
    num_rd_ports    = ERP;
    num_wr_ports    = EWP;
    num_se_rd_ports = NSER;
+   if (!(fully_assoc || pure_cam))
+     num_search_ports = 0;
    nsets           = C/(B*A);
  
    if (temp < 300 || temp > 400 || temp%10 != 0)
***************
*** 1078,1083 ****
--- 1489,1495 ----
        file << "Tag array access time (ns), ";
        file << "Refresh period (microsec), ";
        file << "DRAM array availability (%), ";
+       file << "Dynamic search energy (nJ), ";
        file << "Dynamic read energy (nJ), ";
        file << "Dynamic write energy (nJ), ";
        file << "Dynamic read power (mW), ";
***************
*** 1185,1204 ****
    file.close();
  }
  
! 
! 
  void output_UCA(uca_org_t *fr)
  {
!   //    if (NUCA) 
    if (0) {
      cout << "\n\n Detailed Bank Stats:\n";
!     cout << "    Bank Size (bytes): %d\n" << 
                                       (int) (g_ip->cache_sz);
    }
    else {
      if (g_ip->data_arr_ram_cell_tech_type == 3) {
        cout << "\n---------- P-CACTI, Uniform Cache Access " <<
!         "Logic Process Based DRAM Model ----------\n"; 
      }
      else if (g_ip->data_arr_ram_cell_tech_type == 4) {
        cout << "\n---------- P-CACTI, Uniform" <<
--- 1597,1622 ----
    file.close();
  }
  
! //Divya begin
  void output_UCA(uca_org_t *fr)
  {
! //	bool dvs = g_ip->is_dvs;
! //	double dvs_volt_step = 0.1;
! //	int dvs_levels = (g_ip->dvs_end - g_ip->dvs_start)/dvs_volt_step + 1;
! 
! 	int dvs_levels = g_ip->dvs_voltage.size();
! 	int i;
! 	bool dvs  = !g_ip->dvs_voltage.empty();
! 
    if (0) {
      cout << "\n\n Detailed Bank Stats:\n";
!     cout << "    Bank Size (bytes): %d\n" <<
                                       (int) (g_ip->cache_sz);
    }
    else {
      if (g_ip->data_arr_ram_cell_tech_type == 3) {
        cout << "\n---------- P-CACTI, Uniform Cache Access " <<
!         "Logic Process Based DRAM Model ----------\n";
      }
      else if (g_ip->data_arr_ram_cell_tech_type == 4) {
        cout << "\n---------- P-CACTI, Uniform" <<
***************
*** 1209,1290 ****
          "SRAM Model ----------\n";
      }
      cout << "\nCache Parameters:\n";
!     cout << "    Total cache size (bytes): " << 
        (int) (g_ip->cache_sz) << endl;
    }
  
    cout << "    Number of banks: " << (int) g_ip->nbanks << endl;
!   if (g_ip->fully_assoc)
!     cout << "    Associativity: fully associative\n";
!   else {
!     if (g_ip->tag_assoc == 1)
!       cout << "    Associativity: direct mapped\n";
!     else
!       cout << "    Associativity: " << 
!         g_ip->tag_assoc << endl;
!   }
  
  
!   cout << "    Block size (bytes): " << g_ip->line_sz << endl;
!   cout << "    Read/write Ports: " <<
!     g_ip->num_rw_ports << endl;
!   cout << "    Read ports: " <<
!     g_ip->num_rd_ports << endl;
!   cout << "    Write ports: " <<
!     g_ip->num_wr_ports << endl;;
!   cout << "    Technology size (nm): " <<  
!     g_ip->F_sz_nm << endl << endl;
  
!   cout << "    Access time (ns): " << fr->access_time*1e9 << endl;
    cout << "    Cycle time (ns):  " << fr->cycle_time*1e9 << endl;
    if (g_ip->data_arr_ram_cell_tech_type >= 4) {
!     cout << "    Precharge Delay (ns): " << fr->data_array2->precharge_delay*1e9 << endl;
!     cout << "    Activate Energy (nJ): " << fr->data_array2->activate_energy*1e9 << endl;
!     cout << "    Read Energy (nJ): " << fr->data_array2->read_energy*1e9 << endl;
!     cout << "    Write Energy (nJ): " << fr->data_array2->write_energy*1e9 << endl;
!     cout << "    Precharge Energy (nJ): " << fr->data_array2->precharge_energy*1e9 << endl;
!     cout << "    Leakage Power Closed Page (mW): " << fr->data_array2->leak_power_subbank_closed_page*1e3 << endl;
!     cout << "    Leakage Power Open Page (mW): " << fr->data_array2->leak_power_subbank_open_page*1e3 << endl;
!     cout << "    Leakage Power I/O (mW): " << fr->data_array2->leak_power_request_and_reply_networks*1e3 << endl;
!     cout << "    Refresh power (mW): " << 
!       fr->data_array2->refresh_power*1e3 << endl; 
    }
    else {
!     cout << "    Total dynamic read energy per access (nJ): " <<
!       fr->power.readOp.dynamic*1e9 << endl;
!     cout << "    Total dynamic write energy per access (nJ): " << // Alireza
!       fr->power.writeOp.dynamic*1e9 << endl;                      // Alireza
!     cout << "    Total leakage power of a bank"
!       " (mW): " << fr->power.readOp.leakage*1e3 << endl;
    }
  
    if (g_ip->data_arr_ram_cell_tech_type ==3 || g_ip->data_arr_ram_cell_tech_type ==4)
    {
    }
!   cout <<  "    Cache height x width (mm): " <<
!     fr->cache_ht*1e-3 << " x " << fr->cache_len*1e-3 << endl;
!   cout <<  "    Cache area (mm2): " <<
!     fr->area*1e-3*1e-3 << endl << endl;
! 
! 
!   cout << "    Best Ndwl : " << fr->data_array2->Ndwl << endl;
!   cout << "    Best Ndbl : " << fr->data_array2->Ndbl << endl;
!   cout << "    Best Nspd : " << fr->data_array2->Nspd << endl;
!   cout << "    Best Ndcm : " << fr->data_array2->deg_bl_muxing << endl;
!   cout << "    Best Ndsam L1 : " << fr->data_array2->Ndsam_lev_1 << endl;
!   cout << "    Best Ndsam L2 : " << fr->data_array2->Ndsam_lev_2 << endl << endl;
! 
!   if (g_ip->is_cache && !g_ip->is_main_mem)
!   {
!     cout << "    Best Ntwl : " << fr->tag_array2->Ndwl << endl;
!     cout << "    Best Ntbl : " << fr->tag_array2->Ndbl << endl;
!     cout << "    Best Ntspd : " << fr->tag_array2->Nspd << endl;
!     cout << "    Best Ntcm : " << fr->tag_array2->deg_bl_muxing << endl;
!     cout << "    Best Ntsam L1 : " << fr->tag_array2->Ndsam_lev_1 << endl;
!     cout << "    Best Ntsam L2 : " << fr->tag_array2->Ndsam_lev_2 << endl;
    }
  
!   switch (fr->data_array2->wt) {
      case (0):
        cout <<  "    Data array, H-tree wire type: Delay optimized global wires\n";
        break;
--- 1627,1844 ----
          "SRAM Model ----------\n";
      }
      cout << "\nCache Parameters:\n";
!     cout << "    Total cache size (bytes): " <<
        (int) (g_ip->cache_sz) << endl;
    }
  
    cout << "    Number of banks: " << (int) g_ip->nbanks << endl;
!     if (g_ip->fully_assoc)
!       cout << "    Associativity: fully associative\n";
!     else {
!       if (g_ip->tag_assoc == 1)
!         cout << "    Associativity: direct mapped\n";
!       else
!         cout << "    Associativity: " <<
!           g_ip->tag_assoc << endl;
!     }
  
  
!     cout << "    Block size (bytes): " << g_ip->line_sz << endl;
!     cout << "    Read/write Ports: " <<
!       g_ip->num_rw_ports << endl;
!     cout << "    Read ports: " <<
!       g_ip->num_rd_ports << endl;
!     cout << "    Write ports: " <<
!       g_ip->num_wr_ports << endl;;
!     if (g_ip->fully_assoc|| g_ip->pure_cam)
!   	  cout << "    search ports: " <<
!   	      g_ip->num_search_ports << endl;
!     cout << "    Technology size (nm): " <<
!       g_ip->F_sz_nm << endl << endl;
! 
!   if (dvs)
!   {
! 	 cout << "    Access time (ns): ";
! 	 for (i = 0; i<dvs_levels; i++)
! 		  cout<<fr->uca_q[i]->access_time*1e9 <<";";
! 	 cout << endl;
!   }
!   else
! 	  cout << "    Access time (ns): " << fr->access_time*1e9 << endl;
  
! 
!   if (dvs)
!   {
! 	  cout << "    Cycle time (ns):  " ;
! 	 for (i = 0; i<dvs_levels; i++)
! 		  cout<<fr->uca_q[i]->cycle_time*1e9 <<"; ";
! 	 cout<< endl;
!   }
!   else
    cout << "    Cycle time (ns):  " << fr->cycle_time*1e9 << endl;
+ 
+ 
    if (g_ip->data_arr_ram_cell_tech_type >= 4) {
!     cout << "    Precharge Delay (ns): " << fr->data_array2.precharge_delay*1e9 << endl;
!     cout << "    Activate Energy (nJ): " << fr->data_array2.activate_energy*1e9 << endl;
!     cout << "    Read Energy (nJ): " << fr->data_array2.read_energy*1e9 << endl;
!     cout << "    Write Energy (nJ): " << fr->data_array2.write_energy*1e9 << endl;
!     cout << "    Precharge Energy (nJ): " << fr->data_array2.precharge_energy*1e9 << endl;
!     cout << "    Leakage Power Closed Page (mW): " << fr->data_array2.leak_power_subbank_closed_page*1e3 << endl;
!     cout << "    Leakage Power Open Page (mW): " << fr->data_array2.leak_power_subbank_open_page*1e3 << endl;
!     cout << "    Leakage Power I/O (mW): " << fr->data_array2.leak_power_request_and_reply_networks*1e3 << endl;
!     cout << "    Refresh power (mW): " <<
!       fr->data_array2.refresh_power*1e3 << endl;
    }
    else {
! 	  if ((g_ip->fully_assoc|| g_ip->pure_cam))
! 	  {
! 		  if (dvs)
! 		  {
! 			  cout << "    Total dynamic associative search energy per access (nJ): ";
! 			  for (i = 0; i<dvs_levels; i++)
! 				  cout<<fr->uca_q[i]->power.searchOp.dynamic*1e9 <<"; ";
! 			  cout<< endl;
! 		  }
! 		  else
! 			  cout << "    Total dynamic associative search energy per access (nJ): " <<
! 					  fr->power.searchOp.dynamic*1e9;
! 
! 			  //		  cout << "    Total dynamic read energy per access (nJ): " <<
! 		  //		  fr->power.readOp.dynamic*1e9 << endl;
! 		  //		  cout << "    Total dynamic write energy per access (nJ): " <<
! 		  //		  fr->power.writeOp.dynamic*1e9 << endl;
! 	  }
! 	  if (dvs)
! 	  {
! 		  cout << "    Total dynamic read energy per access (nJ): ";
! 		  for (i = 0; i<dvs_levels; i++)
! 			  cout<<fr->uca_q[i]->power.readOp.dynamic*1e9 <<"; ";
! 		  cout<< endl;
! 		  cout << "    Total dynamic write energy per access (nJ): ";
! 		  for (i = 0; i<dvs_levels; i++)
! 		 			  cout<<fr->uca_q[i]->power.writeOp.dynamic*1e9 <<"; ";
! 		  cout<< endl;
! 		  cout << "    Total leakage power of a bank (mW): ";
! 		  for (i = 0; i<dvs_levels; i++)
! 			  cout<< fr->uca_q[i]->power.readOp.leakage*1e3 <<"; ";
! 		  cout<< endl;
!  	  }
! 	  else {
! 		cout << "    Total dynamic read energy per access (nJ): " <<
! 		  fr->power.readOp.dynamic*1e9 << endl;
! 		cout << "    Total dynamic write energy per access (nJ): " << // Alireza
! 		  fr->power.writeOp.dynamic*1e9 << endl;                      // Alireza
! 		cout << "    Total leakage power of a bank"
! 		  " (mW): " << fr->power.readOp.leakage*1e3 << endl;
! 	  }
    }
  
    if (g_ip->data_arr_ram_cell_tech_type ==3 || g_ip->data_arr_ram_cell_tech_type ==4)
    {
    }
!   if (dvs) {
! 	  cout <<  "    Cache height x width (mm): ";
! 	  for (i = 0; i<dvs_levels; i++)
! 		  cout << fr->uca_q[i]->cache_ht*1e-3 << " x " << fr->cache_len*1e-3 << "; ";
! 	  cout<< endl;
! 	  cout <<  "    Cache area (mm2): ";
! 	  for (i = 0; i<dvs_levels; i++)
! 		  cout <<	fr->uca_q[i]->area*1e-3*1e-3 << "; ";
! 	  cout<< endl << endl;
!   } else {
! 	 cout <<  "    Cache height x width (mm): " <<
! 		fr->cache_ht*1e-3 << " x " << fr->cache_len*1e-3 << endl;
! 	  cout <<  "    Cache area (mm2): " <<
! 		fr->area*1e-3*1e-3 << endl << endl;
!   	  }
!   if (dvs) {
! 	  cout << "    Best Ndwl : ";
! 	  for (i = 0; i<dvs_levels; i++)
! 		  cout << fr->uca_q[i]->data_array2.Ndwl << "; ";
! 	  cout<< endl;
! 
! 	  cout << "    Best Ndbl : ";
! 	  for (i = 0; i<dvs_levels; i++)
! 		  cout << fr->uca_q[i]->data_array2.Ndbl << "; ";
! 	  cout<< endl;
! 
! 	  cout << "    Best Nspd : ";
! 	  for (i = 0; i<dvs_levels; i++)
! 		  cout << fr->uca_q[i]->data_array2.Nspd << "; ";
! 	  cout<< endl;
! 
! 	  cout << "    Best Ndcm : ";
! 	  for (i = 0; i<dvs_levels; i++)
! 		  cout << fr->uca_q[i]->data_array2.deg_bl_muxing << "; ";
! 	  cout<< endl;
! 
! 	  cout << "    Best Ndsam L1 : ";
! 	  for (i = 0; i<dvs_levels; i++)
! 		  cout << fr->uca_q[i]->data_array2.Ndsam_lev_1 << "; ";
! 	  cout<< endl;
! 
! 
! 	  cout << "    Best Ndsam L2 : ";
! 	  for (i = 0; i<dvs_levels; i++)
! 		  cout << fr->uca_q[i]->data_array2.Ndsam_lev_2 << "; ";
! 	  cout<< endl << endl;
! 
!   } else {
!   cout << "    Best Ndwl : " << fr->data_array2.Ndwl << endl;
!   cout << "    Best Ndbl : " << fr->data_array2.Ndbl << endl;
!   cout << "    Best Nspd : " << fr->data_array2.Nspd << endl;
!   cout << "    Best Ndcm : " << fr->data_array2.deg_bl_muxing << endl;
!   cout << "    Best Ndsam L1 : " << fr->data_array2.Ndsam_lev_1 << endl;
!   cout << "    Best Ndsam L2 : " << fr->data_array2.Ndsam_lev_2 << endl << endl;
! 
!   }
! 
!   if ((!(g_ip->pure_ram|| g_ip->pure_cam || g_ip->fully_assoc)) && !g_ip->is_main_mem)
!   {
! 	  if(dvs) {
! 		  cout << "    Best Ntwl : ";
! 		  for (i = 0; i<dvs_levels; i++)
! 			  cout << fr->uca_q[i]->tag_array2.Ndwl << ";";
! 		  cout<< endl;
! 
! 		  cout << "    Best Ntbl : ";
! 		  for (i = 0; i<dvs_levels; i++)
! 			cout << fr->uca_q[i]->tag_array2.Ndbl << ";";
!  		  cout<< endl;
! 
!  		  cout << "    Best Ntspd : ";
! 		  for (i = 0; i<dvs_levels; i++)
! 			cout << fr->uca_q[i]->tag_array2.Nspd << ";";
! 		  cout<< endl;
! 
! 		  cout << "    Best Ntcm : ";
! 		  for (i = 0; i<dvs_levels; i++)
! 			cout << fr->uca_q[i]->tag_array2.deg_bl_muxing << ";";
!   		  cout<< endl;
! 
! 		  cout << "    Best Ntsam L1 : ";
! 		  for (i = 0; i<dvs_levels; i++)
! 			cout << fr->uca_q[i]->tag_array2.Ndsam_lev_1 << ";";
! 		  cout<< endl;
! 
! 		  cout << "    Best Ntsam L2 : ";
! 		  for (i = 0; i<dvs_levels; i++)
! 			cout << fr->uca_q[i]->tag_array2.Ndsam_lev_2 << ";";
! 		  cout<< endl;
! 
! 	  } else {
! 		cout << "    Best Ntwl : " << fr->tag_array2.Ndwl << endl;
! 		cout << "    Best Ntbl : " << fr->tag_array2.Ndbl << endl;
! 		cout << "    Best Ntspd : " << fr->tag_array2.Nspd << endl;
! 		cout << "    Best Ntcm : " << fr->tag_array2.deg_bl_muxing << endl;
! 		cout << "    Best Ntsam L1 : " << fr->tag_array2.Ndsam_lev_1 << endl;
! 		cout << "    Best Ntsam L2 : " << fr->tag_array2.Ndsam_lev_2 << endl;
! 	  }
    }
  
! //  cout << "dataarray wt " << fr->data_array2.wt << endl;
!   switch (fr->data_array2.wt) {
      case (0):
        cout <<  "    Data array, H-tree wire type: Delay optimized global wires\n";
        break;
***************
*** 1304,1315 ****
        cout <<  "    Data array, wire type: Low swing wires\n";
        break;
      default:
!       cout << "ERROR - Unknown wire type " << (int) fr->data_array2->wt <<endl;
        exit(0);
    }
  
!   if (g_ip->is_cache) {
!     switch (fr->tag_array2->wt) {
        case (0):
          cout <<  "    Tag array, H-tree wire type: Delay optimized global wires\n";
          break;
--- 1858,1869 ----
        cout <<  "    Data array, wire type: Low swing wires\n";
        break;
      default:
!       cout << "ERROR - Unknown wire type " << (int) fr->data_array2.wt <<endl;
        exit(0);
    }
  
!   if (!(g_ip->pure_ram|| g_ip->pure_cam || g_ip->fully_assoc)) {
!     switch (fr->tag_array2.wt) {
        case (0):
          cout <<  "    Tag array, H-tree wire type: Delay optimized global wires\n";
          break;
***************
*** 1329,1522 ****
          cout <<  "    Tag array, wire type: Low swing wires\n";
          break;
        default:
!         cout << "ERROR - Unknown wire type " << (int) fr->tag_array2->wt <<endl;
          exit(-1);
      }
    }
  
    if (g_ip->print_detail)
    {
!     if(g_ip->fully_assoc) return;
  
      /* Delay stats */
!     /* data array stats */ 
      cout << endl << "Time Components:" << endl << endl;
  
      cout << "  Data side (with Output driver) (ns): " <<
!       fr->data_array2->access_time/1e-9 << endl;
! 
!     cout <<  "\tH-tree input delay (ns): " << 
!       fr->data_array2->delay_route_to_bank * 1e9 +
!       fr->data_array2->delay_input_htree * 1e9 << endl;
! 
!     cout <<  "\tDecoder + wordline delay (ns): " <<
!       fr->data_array2->delay_row_predecode_driver_and_block * 1e9 +
!       fr->data_array2->delay_row_decoder * 1e9 << endl;
  
!     cout <<  "\tBitline delay (ns): " <<
!       fr->data_array2->delay_bitlines/1e-9 << endl;
! 
!     cout <<  "\tSense Amplifier delay (ns): " <<
!       fr->data_array2->delay_sense_amp * 1e9 << endl;
  
  
!     cout <<  "\tH-tree output delay (ns): " <<
!       fr->data_array2->delay_subarray_output_driver * 1e9 +
!       fr->data_array2->delay_dout_htree * 1e9 << endl;
  
!     if (g_ip->is_cache && !g_ip->is_main_mem)
      {
        /* tag array stats */
!       cout << endl << "  Tag side (with Output driver) (ns): " <<
!         fr->tag_array2->access_time/1e-9 << endl;
  
!       cout <<  "\tH-tree input delay (ns): " << 
!         fr->tag_array2->delay_route_to_bank * 1e9 +
!         fr->tag_array2->delay_input_htree * 1e9 << endl;
! 
!       cout <<  "\tDecoder + wordline delay (ns): " <<
!         fr->tag_array2->delay_row_predecode_driver_and_block * 1e9 +
!         fr->tag_array2->delay_row_decoder * 1e9 << endl;
  
!       cout <<  "\tBitline delay (ns): " <<
!         fr->tag_array2->delay_bitlines/1e-9 << endl;
  
!       cout <<  "\tSense Amplifier delay (ns): " <<
!         fr->tag_array2->delay_sense_amp * 1e9 << endl;
  
!       cout <<  "\tComparator delay (ns): " <<
!         fr->tag_array2->delay_comparator * 1e9 << endl;
  
!       cout <<  "\tH-tree output delay (ns): " << 
!         fr->tag_array2->delay_subarray_output_driver * 1e9 +
!         fr->tag_array2->delay_dout_htree * 1e9 << endl;
      }
  
      /* Energy/Power stats */
      cout << endl << endl << "Power Components:" << endl << endl;
!     cout << "  Data array: Total dynamic read energy/access  (nJ): " <<
!       fr->data_array2->power.readOp.dynamic * 1e9 << endl;
!     cout << "\tTotal leakage read/write power of a bank (mW): " <<
!         fr->data_array2->power.readOp.leakage * 1e3 << endl;
!     cout << "\tTotal energy in H-tree (that includes both "
!       "address and data transfer) (nJ): " << 
!         (fr->data_array2->power_addr_input_htree.readOp.dynamic +
!          fr->data_array2->power_data_output_htree.readOp.dynamic +
!          fr->data_array2->power_routing_to_bank.readOp.dynamic) * 1e9 << endl;
! 
!     cout << "\tOutput Htree Energy (nJ): " <<
!       fr->data_array2->power_data_output_htree.readOp.dynamic * 1e9 << endl;
!     cout <<  "\tDecoder (nJ): " <<
!       fr->data_array2->power_row_predecoder_drivers.readOp.dynamic * 1e9 +
!       fr->data_array2->power_row_predecoder_blocks.readOp.dynamic * 1e9 << endl;
!     cout <<  "\tWordline (nJ): " <<
!       fr->data_array2->power_row_decoders.readOp.dynamic * 1e9 << endl;
!     cout <<  "\tBitline mux & associated drivers (nJ): " <<
!       fr->data_array2->power_bit_mux_predecoder_drivers.readOp.dynamic * 1e9 +
!       fr->data_array2->power_bit_mux_predecoder_blocks.readOp.dynamic * 1e9 +
!       fr->data_array2->power_bit_mux_decoders.readOp.dynamic * 1e9 << endl;
!     cout <<  "\tSense amp mux & associated drivers (nJ): " <<
!       fr->data_array2->power_senseamp_mux_lev_1_predecoder_drivers.readOp.dynamic * 1e9 +
!       fr->data_array2->power_senseamp_mux_lev_1_predecoder_blocks.readOp.dynamic * 1e9 +
!       fr->data_array2->power_senseamp_mux_lev_1_decoders.readOp.dynamic * 1e9  +
!       fr->data_array2->power_senseamp_mux_lev_2_predecoder_drivers.readOp.dynamic * 1e9 +
!       fr->data_array2->power_senseamp_mux_lev_2_predecoder_blocks.readOp.dynamic * 1e9 +
!       fr->data_array2->power_senseamp_mux_lev_2_decoders.readOp.dynamic * 1e9 << endl;
!     cout <<  "\tBitlines (nJ): " <<
!       fr->data_array2->power_bitlines.readOp.dynamic * 1e9 << endl;
!     cout <<  "\tSense amplifier energy (nJ): " <<
!       fr->data_array2->power_sense_amps.readOp.dynamic * 1e9 << endl;
!     cout <<  "\tSub-array output driver (nJ): " <<
!       fr->data_array2->power_output_drivers_at_subarray.readOp.dynamic * 1e9 << endl;
  
!     if (g_ip->is_cache && !g_ip->is_main_mem)
      {
!       cout << endl << "  Tag array:  Total dynamic read energy/access (nJ): " <<
!         fr->tag_array2->power.readOp.dynamic * 1e9 << endl;
!       cout << "\tTotal leakage read/write power of a bank (mW): " <<
!           fr->tag_array2->power.readOp.leakage * 1e3 << endl;
!       cout << "\tTotal energy in H-tree (that includes both "
!         "address and data transfer) (nJ): " << 
!           (fr->tag_array2->power_addr_input_htree.readOp.dynamic +
!            fr->tag_array2->power_data_output_htree.readOp.dynamic +
!            fr->tag_array2->power_routing_to_bank.readOp.dynamic) * 1e9 << endl;
! 
!       cout << "\tOutput Htree Energy (nJ): " <<
!         fr->tag_array2->power_data_output_htree.readOp.dynamic * 1e9 << endl;
!       cout <<  "\tDecoder (nJ): " <<
!         fr->tag_array2->power_row_predecoder_drivers.readOp.dynamic * 1e9 +
!         fr->tag_array2->power_row_predecoder_blocks.readOp.dynamic * 1e9 << endl;
!       cout <<  "\tWordline (nJ): " <<
!         fr->tag_array2->power_row_decoders.readOp.dynamic * 1e9 << endl;
!       cout <<  "\tBitline mux & associated drivers (nJ): " <<
!         fr->tag_array2->power_bit_mux_predecoder_drivers.readOp.dynamic * 1e9 +
!         fr->tag_array2->power_bit_mux_predecoder_blocks.readOp.dynamic * 1e9 +
!         fr->tag_array2->power_bit_mux_decoders.readOp.dynamic * 1e9 << endl;
!       cout <<  "\tSense amp mux & associated drivers (nJ): " <<
!         fr->tag_array2->power_senseamp_mux_lev_1_predecoder_drivers.readOp.dynamic * 1e9 +
!         fr->tag_array2->power_senseamp_mux_lev_1_predecoder_blocks.readOp.dynamic * 1e9 +
!         fr->tag_array2->power_senseamp_mux_lev_1_decoders.readOp.dynamic * 1e9  +
!         fr->tag_array2->power_senseamp_mux_lev_2_predecoder_drivers.readOp.dynamic * 1e9 +
!         fr->tag_array2->power_senseamp_mux_lev_2_predecoder_blocks.readOp.dynamic * 1e9 +
!         fr->tag_array2->power_senseamp_mux_lev_2_decoders.readOp.dynamic * 1e9 << endl;
!       cout <<  "\tBitlines (nJ): " <<
!         fr->tag_array2->power_bitlines.readOp.dynamic * 1e9 << endl;
!       cout <<  "\tSense amplifier energy (nJ): " <<
!         fr->tag_array2->power_sense_amps.readOp.dynamic * 1e9 << endl;
!       cout <<  "\tSub-array output driver (nJ): " <<
!         fr->tag_array2->power_output_drivers_at_subarray.readOp.dynamic * 1e9 << endl;
      }
  
      cout << endl << endl <<  "Area Components:" << endl << endl;
      /* Data array area stats */
!     cout <<  "  Data array: Area (mm2): " << fr->data_array2->area * 1e-6 << endl;
!     cout <<  "\tHeight (mm): " <<
!       fr->data_array2->all_banks_height*1e-3 << endl;
!     cout <<  "\tWidth (mm): " <<
!       fr->data_array2->all_banks_width*1e-3 << endl;
      if (g_ip->print_detail) {
!       cout <<  "\tArea efficiency (Memory cell area/Total area) - " <<
!         fr->data_array2->area_efficiency << " %" << endl;
!       cout << "\t\tMAT Height (mm): " <<
!         fr->data_array2->mat_height*1e-3 << endl;
!       cout << "\t\tMAT Length (mm): " <<
!         fr->data_array2->mat_length*1e-3 << endl;
!       cout << "\t\tSubarray Height (mm): " <<
!         fr->data_array2->subarray_height*1e-3 << endl;
!       cout << "\t\tSubarray Length (mm): " <<
!         fr->data_array2->subarray_length*1e-3 << endl;
      }
  
      /* Tag array area stats */
!     if (g_ip->is_cache && !g_ip->is_main_mem)
      {
!       cout << endl << "  Tag array: Area (mm2): " << fr->tag_array2->area * 1e-6 << endl;
!       cout <<  "\tHeight (mm): " <<
!         fr->tag_array2->all_banks_height*1e-3 << endl;
!       cout <<  "\tWidth (mm): " <<
!         fr->tag_array2->all_banks_width*1e-3 << endl;
        if (g_ip->print_detail)
        {
!         cout <<  "\tArea efficiency (Memory cell area/Total area) - " <<
!           fr->tag_array2->area_efficiency << " %" << endl;
!         cout << "\t\tMAT Height (mm): " <<
!           fr->tag_array2->mat_height*1e-3 << endl;
!         cout << "\t\tMAT Length (mm): " <<
!           fr->tag_array2->mat_length*1e-3 << endl;
!         cout << "\t\tSubarray Height (mm): " <<
!           fr->tag_array2->subarray_height*1e-3 << endl;
!         cout << "\t\tSubarray Length (mm): " <<
!           fr->tag_array2->subarray_length*1e-3 << endl;
        }
      }
! 
! 
!     Wire wpr;
!     wpr.print_wire();
! 
!     //cout << "FO4 = " << g_tp.FO4 << endl;
    }
  }
  
  /***** Alireza - BEGIN *****/
  void output_summary_of_results(uca_org_t *fr) {
--- 1883,2825 ----
          cout <<  "    Tag array, wire type: Low swing wires\n";
          break;
        default:
!         cout << "ERROR - Unknown wire type " << (int) fr->tag_array2.wt <<endl;
          exit(-1);
      }
    }
  
    if (g_ip->print_detail)
    {
! //    if(g_ip->fully_assoc) return;
  
      /* Delay stats */
!     /* data array stats */
      cout << endl << "Time Components:" << endl << endl;
  
+     if (dvs)
+      {
+      	cout<< "Data side (with Output driver) (ns): ";
+      	for (i = 0; i<dvs_levels; i++)
+      		cout<<fr->uca_q[i]->data_array2.access_time/1e-9 <<"; ";
+      	cout << endl;
+      } else {
      cout << "  Data side (with Output driver) (ns): " <<
!       fr->data_array2.access_time/1e-9 << endl;
!      }
  
!     if (dvs)
!    {
! 	 cout <<  "\tH-tree delay outside banks (ns) : " ;
! 	for (i = 0; i<dvs_levels; i++)
! 		cout<<fr->uca_q[i]->data_array2.delay_route_to_bank * 1e9 <<"; ";
! 	cout << endl;
!    } else {
! 	   cout <<  "\tH-tree delay outside banks (ns) : " <<
! 			 fr->data_array2.delay_route_to_bank * 1e9 << endl;
!    }
! 
! 	if (dvs)
! 	{
! 		cout<<"\tH-tree input delay (inside a bank) (ns) :  ";
! 		for (i = 0; i<dvs_levels; i++)
! 			cout<<fr->uca_q[i]->data_array2.delay_input_htree * 1e9 <<"; ";
! 	}
! 	else {
! 		 cout <<  "\tH-tree input delay (inside a bank) (ns) : " <<
! 					  fr->data_array2.delay_input_htree * 1e9 ;
! 	}
! 	cout<< endl;
! 
! 	if (!(g_ip->pure_cam || g_ip->fully_assoc))
! 	{
! 		cout <<  "\tDecoder + wordline delay (ns): ";
! 		if (dvs)
! 		{
! 			for (i = 0; i<dvs_levels; i++)
! 				cout<<fr->uca_q[i]->data_array2.delay_row_predecode_driver_and_block * 1e9 +
! 					fr->uca_q[i]->data_array2.delay_row_decoder * 1e9 <<"; ";
! 			cout << endl;
! 		} else {
! 		  cout << fr->data_array2.delay_row_predecode_driver_and_block * 1e9 +
! 		  fr->data_array2.delay_row_decoder * 1e9 << endl;
! 		}
! 	}
! 	else
! 	{
! 	   cout <<  "\tCAM search delay (ns): " ;
! 	   if (dvs)
! 	   {
! 		for (i = 0; i<dvs_levels; i++)
! 			cout<<fr->uca_q[i]->data_array2.delay_matchlines * 1e9  <<"; ";
! 		cout<< endl;
! 	   }
! 	   else
! 			  cout << fr->data_array2.delay_matchlines * 1e9 << endl;
! 	}
! 
! 	cout <<  "\tBitline delay (ns): ";
!     if(dvs) {
!     	for (i = 0; i<dvs_levels; i++)
!     	    cout<<fr->uca_q[i]->data_array2.delay_bitlines/1e-9  <<"; ";
!     	cout << endl;
!     }
!     else {
!      cout << fr->data_array2.delay_bitlines/1e-9 << endl;
!     }
  
+     cout <<  "\tSense Amplifier delay (ns): ";
+     if(dvs) {
+     	for (i = 0; i<dvs_levels; i++)
+     		cout<<fr->uca_q[i]->data_array2.delay_sense_amp*1e9  <<"; ";
+     	cout << endl;
+     } else {
+      cout << fr->data_array2.delay_sense_amp * 1e9 << endl;
+     }
  
!     cout <<  "\tH-tree output delay (inside a bank) (ns): ";
!     if(dvs) {
!     	for (i = 0; i<dvs_levels; i++)
!     		cout<<fr->uca_q[i]->data_array2.delay_subarray_output_driver * 1e9 +
!     	      		fr->uca_q[i]->data_array2.delay_dout_htree * 1e9  <<"; ";
!     	cout << endl;
!     } else {
!      cout << fr->data_array2.delay_subarray_output_driver * 1e9 +
!       fr->data_array2.delay_dout_htree * 1e9 << endl;
!     }
  
!     if ((!(g_ip->pure_ram|| g_ip->pure_cam || g_ip->fully_assoc)) && !g_ip->is_main_mem)
      {
        /* tag array stats */
!       cout << endl << "  Tag side (with Output driver) (ns): " ;
  
!       if(dvs) {
!     	  for (i = 0; i<dvs_levels; i++)
!     	    cout<<fr->uca_q[i]->tag_array2.access_time/1e-9  <<"; ";
!     	  cout << endl;
!       }
!       else {
!     	  cout << fr->tag_array2.access_time/1e-9 << endl;
!       }
  
!       if(dvs) {
!     	  cout <<  "\tH-tree input delay (ns): " ;
!           for (i = 0; i<dvs_levels; i++)
!         	  cout<<fr->uca_q[i]->tag_array2.delay_route_to_bank * 1e9  <<"; ";
!           cout << endl;
! 
!       } else {
!     	  cout <<  "\tH-tree delay outside banks (ns) : " <<
!     	          fr->tag_array2.delay_route_to_bank * 1e9;
!       }
  
!       cout <<  "\tH-tree input delay (inside a bank) (ns) : ";
! 	  if (dvs)
! 	  {
! 		for (i = 0; i<dvs_levels; i++)
! 			cout<<fr->uca_q[i]->tag_array2.delay_input_htree * 1e9  <<"; ";
! 	  }
! 	  else {
! 		cout <<  fr->tag_array2.delay_input_htree * 1e9;
! 	  }
! 	  cout << endl;
! 
! 	  if(dvs)
! 	  {
! 		  cout <<  "\tDecoder + wordline delay (ns): ";
! 		  for (i = 0; i<dvs_levels; i++)
! 		  cout << fr->uca_q[i]->tag_array2.delay_row_predecode_driver_and_block * 1e9 +
! 		          fr->uca_q[i]->tag_array2.delay_row_decoder * 1e9 << ";";
! 		  cout << endl;
! 	  } else {
! 		  cout <<  "\tDecoder + wordline delay (ns): " <<
! 			fr->tag_array2.delay_row_predecode_driver_and_block * 1e9 +
! 			fr->tag_array2.delay_row_decoder * 1e9 << endl;
! 	  }
! 
!       cout <<  "\tBitline delay (ns): ";
!       if(dvs) {
! 		for (i = 0; i<dvs_levels; i++)
! 			cout<<fr->uca_q[i]->tag_array2.delay_bitlines * 1e9  <<"; ";
! 		cout << endl;
!       } else {
!        cout << fr->tag_array2.delay_bitlines/1e-9 << endl;
!       }
  
!       cout <<  "\tSense Amplifier delay (ns): ";
!       if(dvs) {
!        	for (i = 0; i<dvs_levels; i++)
!         	cout<<fr->uca_q[i]->tag_array2.delay_sense_amp * 1e9  <<"; ";
!     	 cout  << endl;
!       } else
!          cout << fr->tag_array2.delay_sense_amp * 1e9 << endl;
! 
!       cout <<  "\tComparator delay (ns): ";
!       if(dvs) {
! 		for (i = 0; i<dvs_levels; i++)
! 			cout<<fr->uca_q[i]->tag_array2.delay_comparator * 1e9  <<"; ";
! 		cout << endl;
!       } else {
!        cout << fr->tag_array2.delay_comparator * 1e9 << endl;
!       }
  
!       cout <<  "\tH-tree output delay (inside a bank) (ns): ";
!       if(dvs) {
!         	for (i = 0; i<dvs_levels; i++)
!         		cout<<fr->uca_q[i]->tag_array2.delay_subarray_output_driver * 1e9 +
! 					fr->uca_q[i]->tag_array2.delay_dout_htree * 1e9  <<"; ";
!     	 cout << endl;
!       } else {
!         cout << fr->tag_array2.delay_subarray_output_driver * 1e9 +
!         fr->tag_array2.delay_dout_htree * 1e9 << endl;
!       }
      }
  
      /* Energy/Power stats */
      cout << endl << endl << "Power Components:" << endl << endl;
!     if (!(g_ip->pure_cam || g_ip->fully_assoc))
!     {
! 		if(dvs) {
! 			 cout << "  Data array: \n Total dynamic read energy/access  (nJ): " ;
! 			for (i = 0; i<dvs_levels; i++)
! 				cout <<  fr->uca_q[i]->data_array2.power.readOp.dynamic * 1e9 << "; ";
! 			cout << endl;
! 
! 			cout << "Total dynamic write energy/access  (nJ): " ;
! 					for (i = 0; i<dvs_levels; i++)
! 						cout <<  fr->uca_q[i]->data_array2.power.writeOp.dynamic * 1e9 << "; ";
! 			cout << endl;
! 		} else {
! 			cout << "  Data array: \n Total dynamic read energy/access  (nJ): " <<
! 			  fr->data_array2.power.readOp.dynamic * 1e9 << endl;
! 			   cout << "Total dynamic write energy/access (nJ): " <<
! 				 fr->data_array2.power.writeOp.dynamic * 1e9 << endl;
! 		}
! 		if(dvs) {
! 			cout << "\tTotal leakage read/write power of a bank (mW): ";
! 			for (i = 0; i<dvs_levels; i++)
! 			cout <<fr->uca_q[i]->data_array2.power.readOp.leakage * 1e3 << "; ";
! 				 cout << endl;
! 		   } else
! 			   cout << "\tTotal leakage read/write power of a bank (mW): " <<
! 			fr->data_array2.power.readOp.leakage * 1e3 << endl;
! 
! 		if(dvs) {
! 			cout << "\tTotal energy in H-tree outside banks (that includes both "
! 				  "address and data transfer) (nJ): ";
! 			for (i = 0; i<dvs_levels; i++)
! 				cout << (fr->uca_q[i]->data_array2.power_routing_to_bank.readOp.dynamic)*1e9 << "; ";
! 			cout << endl;
! 		   } else
! 			cout << "\tTotal energy in H-tree outside banks (that includes both "
! 			  "address and data transfer) (nJ): " <<
! 				(/*fr->data_array2.power_addr_input_htree.readOp.dynamic +
! 				 fr->data_array2.power_data_output_htree.readOp.dynamic +*/
! 				 fr->data_array2.power_routing_to_bank.readOp.dynamic) * 1e9 << endl;
! 
! 		if(dvs) {
! 			cout << "\tInput H-tree inside bank Energy (nJ): " ;
! 			for (i = 0; i<dvs_levels; i++)
! 				cout <<  (fr->uca_q[i]->data_array2.power_addr_input_htree.readOp.dynamic) * 1e9 << "; ";
! 			cout << endl;
! 		   } else
! 			cout << "\tInput H-tree inside bank Energy (nJ): " <<
! 			(fr->data_array2.power_addr_input_htree.readOp.dynamic) * 1e9 << endl;
! 
! 		if(dvs) {
! 			 cout << "\tOutput Htree Energy inside bank Energy (nJ): " ;
! 			for (i = 0; i<dvs_levels; i++)
! 				cout <<  fr->uca_q[i]->data_array2.power_data_output_htree.readOp.dynamic * 1e9 << "; ";
! 			cout << endl;
! 		   } else
! 			cout << "\tOutput Htree Energy inside bank Energy (nJ): " <<
! 			  fr->data_array2.power_data_output_htree.readOp.dynamic * 1e9 << endl;
! 
! 		if(dvs) {
! 			 cout <<  "\tDecoder (nJ): " ;
! 			for (i = 0; i<dvs_levels; i++)
! 				cout <<  fr->uca_q[i]->data_array2.power_row_predecoder_drivers.readOp.dynamic * 1e9 +
! 				  fr->uca_q[i]->data_array2.power_row_predecoder_blocks.readOp.dynamic * 1e9 << "; ";
! 			cout << endl;
! 		   } else
! 			cout <<  "\tDecoder (nJ): " <<
! 			  fr->data_array2.power_row_predecoder_drivers.readOp.dynamic * 1e9 +
! 			  fr->data_array2.power_row_predecoder_blocks.readOp.dynamic * 1e9 << endl;
! 
! 		if(dvs) {
! 			cout <<  "\tWordline (nJ): ";
! 			for (i = 0; i<dvs_levels; i++)
! 				cout <<  fr->uca_q[i]->data_array2.power_row_decoders.readOp.dynamic * 1e9 <<  "; ";
! 			cout << endl;
! 		   } else
! 			cout <<  "\tWordline (nJ): " <<
! 			  fr->data_array2.power_row_decoders.readOp.dynamic * 1e9 << endl;
! 
! 		if(dvs) {
! 			cout <<  "\tBitline mux & associated drivers (nJ): ";
! 			for (i = 0; i<dvs_levels; i++)
! 				cout <<  fr->uca_q[i]->data_array2.power_bit_mux_predecoder_drivers.readOp.dynamic * 1e9 +
! 				  fr->uca_q[i]->data_array2.power_bit_mux_predecoder_blocks.readOp.dynamic * 1e9 +
! 				  fr->uca_q[i]->data_array2.power_bit_mux_decoders.readOp.dynamic * 1e9 << "; ";
! 			cout << endl;
! 		   } else
! 			cout <<  "\tBitline mux & associated drivers (nJ): " <<
! 			  fr->data_array2.power_bit_mux_predecoder_drivers.readOp.dynamic * 1e9 +
! 			  fr->data_array2.power_bit_mux_predecoder_blocks.readOp.dynamic * 1e9 +
! 			  fr->data_array2.power_bit_mux_decoders.readOp.dynamic * 1e9 << endl;
! 
! 		if(dvs) {
! 			cout <<  "\tSense amp mux & associated drivers (nJ): ";
! 			for (i = 0; i<dvs_levels; i++)
! 				cout <<  fr->uca_q[i]->data_array2.power_senseamp_mux_lev_1_predecoder_drivers.readOp.dynamic * 1e9 +
! 				  fr->uca_q[i]->data_array2.power_senseamp_mux_lev_1_predecoder_blocks.readOp.dynamic * 1e9 +
! 				  fr->uca_q[i]->data_array2.power_senseamp_mux_lev_1_decoders.readOp.dynamic * 1e9  +
! 				  fr->uca_q[i]->data_array2.power_senseamp_mux_lev_2_predecoder_drivers.readOp.dynamic * 1e9 +
! 				  fr->uca_q[i]->data_array2.power_senseamp_mux_lev_2_predecoder_blocks.readOp.dynamic * 1e9 +
! 				  fr->uca_q[i]->data_array2.power_senseamp_mux_lev_2_decoders.readOp.dynamic * 1e9 << "; ";
! 			cout << endl;
! 		   } else
! 			cout <<  "\tSense amp mux & associated drivers (nJ): " <<
! 			  fr->data_array2.power_senseamp_mux_lev_1_predecoder_drivers.readOp.dynamic * 1e9 +
! 			  fr->data_array2.power_senseamp_mux_lev_1_predecoder_blocks.readOp.dynamic * 1e9 +
! 			  fr->data_array2.power_senseamp_mux_lev_1_decoders.readOp.dynamic * 1e9  +
! 			  fr->data_array2.power_senseamp_mux_lev_2_predecoder_drivers.readOp.dynamic * 1e9 +
! 			  fr->data_array2.power_senseamp_mux_lev_2_predecoder_blocks.readOp.dynamic * 1e9 +
! 			  fr->data_array2.power_senseamp_mux_lev_2_decoders.readOp.dynamic * 1e9 << endl;
! 
! 		if(dvs) {
! 			cout <<  "\tBitlines (nJ): " ;
! 			for (i = 0; i<dvs_levels; i++)
! 				cout << fr->uca_q[i]->data_array2.power_bitlines.readOp.dynamic * 1e9 << "; ";
! 			cout << endl;
! 		   } else
! 			cout <<  "\tBitlines (nJ): " <<
! 			  fr->data_array2.power_bitlines.readOp.dynamic * 1e9 << endl;
! 
! 		if(dvs) {
! 			cout <<  "\tSense amplifier energy (nJ): " ;
! 			for (i = 0; i<dvs_levels; i++)
! 				cout <<   fr->uca_q[i]->data_array2.power_sense_amps.readOp.dynamic * 1e9 << "; ";
! 			cout << endl;
! 		   } else
! 			cout <<  "\tSense amplifier energy (nJ): " <<
! 			  fr->data_array2.power_sense_amps.readOp.dynamic * 1e9 << endl;
! 
! 		if(dvs) {
! 			 cout <<  "\tSub-array output driver (nJ): ";
! 			for (i = 0; i<dvs_levels; i++)
! 				cout <<  fr->uca_q[i]->data_array2.power_output_drivers_at_subarray.readOp.dynamic * 1e9 << "; ";
! 			cout << endl;
! 		   } else
! 				cout <<  "\tSub-array output driver (nJ): " <<
! 				  fr->data_array2.power_output_drivers_at_subarray.readOp.dynamic * 1e9 << endl;
! 	}
  
!     if (g_ip->pure_cam||g_ip->fully_assoc)
      {
!     	if (g_ip->pure_cam) cout << "  CAM array:"<<endl;
!     	if (g_ip->fully_assoc)  cout << "  Fully associative array:"<<endl;
! 
! 		if (dvs)
! 		{
! 			cout << "  Total dynamic associative search energy/access  (nJ): ";
! 			for (i = 0; i<dvs_levels; i++)
! 				cout<<fr->uca_q[i]->data_array2.power.searchOp.dynamic * 1e9  <<"; ";
! 			cout<< endl;
! 		}
! 		else
! 	    	cout << "  Total dynamic associative search energy/access  (nJ): " <<
! 	    	    			fr->data_array2.power.searchOp.dynamic * 1e9 ;
! 
! 		if (dvs)
! 		 {
! 			cout << "\tTotal energy in H-tree outside banks(that includes both "
! 					"match key and data transfer) (nJ): ";
! 			for (i = 0; i<dvs_levels; i++)
! 				cout<<fr->uca_q[i]->data_array2.power_routing_to_bank.searchOp.dynamic * 1e9 <<"; ";
! 			cout<< endl;
! 		 }
! 		else
! 			cout << "\tTotal energy in H-tree outside banks(that includes both "
! 					"match key and data transfer) (nJ): " <<
! 					(fr->data_array2.power_routing_to_bank.searchOp.dynamic) * 1e9;
! 
! 		 if (dvs)
! 		 {
! 			 cout << "\tMatch Key input Htree inside bank Energy (nJ): " ;
! 			 for (i = 0; i<dvs_levels; i++)
! 				cout<<fr->uca_q[i]->data_array2.power_htree_in_search.searchOp.dynamic * 1e9 <<"; ";
! 			cout<< endl;
! 		 }
! 		 else
! 			 cout << "\tMatch Key input Htree inside bank Energy (nJ): " <<
! 			     	    			(fr->data_array2.power_htree_in_search.searchOp.dynamic ) * 1e9 ;
! 
! 		 if (dvs)
! 		 {
! 			cout << "\tResult output Htrees inside bank Energy (nJ): " ;
! 			for (i = 0; i<dvs_levels; i++)
! 				cout<<fr->uca_q[i]->data_array2.power_htree_out_search.searchOp.dynamic * 1e9 <<"; ";
! 			 cout<< endl;
! 		 }
! 		 else
! 				cout << "\tResult output Htrees inside bank Energy (nJ): " <<
! 						(fr->data_array2.power_htree_out_search.searchOp.dynamic) * 1e9 ;
! 
! 		cout <<  "\tSearchlines (nJ): " <<
! 				fr->data_array2.power_searchline.searchOp.dynamic * 1e9 +
! 				fr->data_array2.power_searchline_precharge.searchOp.dynamic * 1e9 ;
! 		 if (dvs)
! 		 {
! 				cout <<  "\tSearchlines (nJ): ";
! 			for (i = 0; i<dvs_levels; i++)
! 				cout<<fr->uca_q[i]->data_array2.power_searchline.searchOp.dynamic * 1e9 +
! 					  fr->uca_q[i]->data_array2.power_searchline_precharge.searchOp.dynamic * 1e9 <<"; ";
! 				 cout<< endl;
! 		 }
! 		 else
! 				cout <<  "\tSearchlines (nJ): " <<
! 						fr->data_array2.power_searchline.searchOp.dynamic * 1e9 +
! 						fr->data_array2.power_searchline_precharge.searchOp.dynamic * 1e9 ;
! 
! 		 if (dvs)
! 		 {
! 				cout <<  "\tMatchlines  (nJ): ";
! 			for (i = 0; i<dvs_levels; i++)
! 				cout<<fr->uca_q[i]->data_array2.power_matchlines.searchOp.dynamic * 1e9 +
! 					  fr->uca_q[i]->data_array2.power_matchline_precharge.searchOp.dynamic * 1e9 <<"; ";
! 			cout<< endl;
! 		}
! 		 else
! 				cout <<  "\tMatchlines  (nJ): " <<
! 						fr->data_array2.power_matchlines.searchOp.dynamic * 1e9 +
! 						fr->data_array2.power_matchline_precharge.searchOp.dynamic * 1e9;
! 
! 		if (g_ip->fully_assoc)
! 		{
! 			 if (dvs)
! 			 {
! 					cout <<  "\tData portion wordline (nJ): " ;
! 				for (i = 0; i<dvs_levels; i++)
! 					cout<<fr->uca_q[i]->data_array2.power_matchline_to_wordline_drv.searchOp.dynamic * 1e9 <<"; ";
! 				 cout<< endl;
! 			 }
! 			 else
! 					cout <<  "\tData portion wordline (nJ): " <<
! 							fr->data_array2.power_matchline_to_wordline_drv.searchOp.dynamic * 1e9 ;
! 
! 			 if (dvs)
! 			 {
! 				cout <<  "\tData Bitlines (nJ): " ;
! 				for (i = 0; i<dvs_levels; i++)
! 					cout<<(fr->uca_q[i]->data_array2.power_bitlines.searchOp.dynamic * 1e9 +
! 						   fr->uca_q[i]->data_array2.power_prechg_eq_drivers.searchOp.dynamic * 1e9) <<"; ";
! 				cout<< endl;
! 			}
! 			else
! 					cout <<  "\tData Bitlines (nJ): " <<
! 							fr->data_array2.power_bitlines.searchOp.dynamic * 1e9 +
! 							fr->data_array2.power_prechg_eq_drivers.searchOp.dynamic * 1e9;
! 
! 			 if (dvs)
! 			 {
! 				cout <<  "\tSense amplifier energy (nJ): " ;
! 				for (i = 0; i<dvs_levels; i++)
! 					cout<<fr->uca_q[i]->data_array2.power_sense_amps.searchOp.dynamic * 1e9 <<"; ";
! 				 cout<< endl;
! 			 }
! 			 else
! 				 cout <<  "\tSense amplifier energy (nJ): " <<
! 						fr->data_array2.power_sense_amps.searchOp.dynamic * 1e9 ;
! 		}
! 
! 		 if (dvs)
! 		 {
! 				cout <<  "\tSub-array output driver (nJ): " ;
! 			for (i = 0; i<dvs_levels; i++)
! 				cout<<fr->uca_q[i]->data_array2.power_output_drivers_at_subarray.searchOp.dynamic * 1e9 <<"; ";
! 			cout<< endl;
! 		}
! 		 else
! 				cout <<  "\tSub-array output driver (nJ): " <<
! 						fr->data_array2.power_output_drivers_at_subarray.searchOp.dynamic * 1e9 ;
! 
! 		 if (dvs)
! 		 {
! 				cout <<endl<< "  Total dynamic read energy/access  (nJ): " ;
! 			for (i = 0; i<dvs_levels; i++)
! 				cout<<fr->uca_q[i]->data_array2.power.readOp.dynamic * 1e9 <<"; ";
! 			cout<< endl;
! 		}
! 		 else
! 				cout <<endl<< "  Total dynamic read energy/access  (nJ): " <<
! 						fr->data_array2.power.readOp.dynamic * 1e9;
! 
! 
! 		 if (dvs)
! 		 {
! 				cout << "\tTotal energy in H-tree outside banks(that includes both "
! 						"address and data transfer) (nJ): " ;
! 
! 			for (i = 0; i<dvs_levels; i++)
! 				cout<<fr->uca_q[i]->data_array2.power_routing_to_bank.readOp.dynamic * 1e9 <<"; ";
! 		 		 cout<< endl;
! 		 }
! 		 else
! 				cout << "\tTotal energy in H-tree outside banks(that includes both "
! 						"address and data transfer) (nJ): " <<
! 						(fr->data_array2.power_routing_to_bank.readOp.dynamic) * 1e9;
! 
! 			if (dvs)
! 			{
! 				cout << "\tInput Htree inside bank Energy (nJ): ";
! 
! 				for (i = 0; i<dvs_levels; i++)
! 					cout<<fr->uca_q[i]->data_array2.power_addr_input_htree.readOp.dynamic * 1e9 <<"; ";
! 					 cout<< endl;
! 			} else
! 				cout << "\tInput Htree inside bank Energy (nJ): " <<
! 							(fr->data_array2.power_addr_input_htree.readOp.dynamic ) * 1e9 ;
! 
! 			cout << "\tOutput Htree inside bank Energy (nJ): " <<
! 					fr->data_array2.power_data_output_htree.readOp.dynamic * 1e9 ;
! 			if (dvs)
! 			{
! 				cout << "\tOutput Htree inside bank Energy (nJ): " ;
! 
! 				for (i = 0; i<dvs_levels; i++)
! 					cout<<fr->uca_q[i]->data_array2.power_data_output_htree.readOp.dynamic * 1e9 <<"; ";
! 					 cout<< endl;
! 			} else
! 				cout << "\tOutput Htree inside bank Energy (nJ): " <<
! 						fr->data_array2.power_data_output_htree.readOp.dynamic * 1e9 ;
! 
! 			if (dvs)
! 			{
! 				cout <<  "\tDecoder (nJ): " ;
! 
! 				for (i = 0; i<dvs_levels; i++)
! 					cout<<(fr->uca_q[i]->data_array2.power_row_predecoder_drivers.readOp.dynamic * 1e9 +
! 						   fr->uca_q[i]->data_array2.power_row_predecoder_blocks.readOp.dynamic * 1e9) <<"; ";
! 					 cout<< endl;
! 			} else
! 				cout <<  "\tDecoder (nJ): " <<
! 						fr->data_array2.power_row_predecoder_drivers.readOp.dynamic * 1e9 +
! 						fr->data_array2.power_row_predecoder_blocks.readOp.dynamic * 1e9;
! 
! 			if (dvs)
! 			{
! 				cout <<  "\tWordline (nJ): " ;
! 
! 				for (i = 0; i<dvs_levels; i++)
! 					cout<<fr->uca_q[i]->data_array2.power_row_decoders.readOp.dynamic * 1e9 <<"; ";
! 					 cout<< endl;
! 			} else
! 				cout <<  "\tWordline (nJ): " <<
! 						fr->data_array2.power_row_decoders.readOp.dynamic * 1e9 ;
! 
! 	        if (dvs)
! 	        {
! 				cout <<  "\tBitline mux & associated drivers (nJ): " ;
! 
! 	        	for (i = 0; i<dvs_levels; i++)
! 	        		cout<<(fr->uca_q[i]->data_array2.power_bit_mux_predecoder_drivers.readOp.dynamic * 1e9 +
! 	            			fr->uca_q[i]->data_array2.power_bit_mux_predecoder_blocks.readOp.dynamic * 1e9 +
! 	            			fr->uca_q[i]->data_array2.power_bit_mux_decoders.readOp.dynamic * 1e9)
! 	            			<<"; ";
! 		        cout<< endl;
! 	        }
! 	        else
! 				cout <<  "\tBitline mux & associated drivers (nJ): " <<
! 	    			fr->data_array2.power_bit_mux_predecoder_drivers.readOp.dynamic * 1e9 +
! 	    			fr->data_array2.power_bit_mux_predecoder_blocks.readOp.dynamic * 1e9 +
! 	    			fr->data_array2.power_bit_mux_decoders.readOp.dynamic * 1e9;
! 
! 	        if (dvs)
! 	        {
! 		    	cout <<  "\tSense amp mux & associated drivers (nJ): " ;
! 
! 	        	for (i = 0; i<dvs_levels; i++)
! 	        		cout<<( fr->uca_q[i]->data_array2.power_senseamp_mux_lev_1_predecoder_drivers.readOp.dynamic * 1e9 +
! 	            			fr->uca_q[i]->data_array2.power_senseamp_mux_lev_1_predecoder_blocks.readOp.dynamic * 1e9 +
! 	            			fr->uca_q[i]->data_array2.power_senseamp_mux_lev_1_decoders.readOp.dynamic * 1e9  +
! 	            			fr->uca_q[i]->data_array2.power_senseamp_mux_lev_2_predecoder_drivers.readOp.dynamic * 1e9 +
! 	            			fr->uca_q[i]->data_array2.power_senseamp_mux_lev_2_predecoder_blocks.readOp.dynamic * 1e9 +
! 	            			fr->uca_q[i]->data_array2.power_senseamp_mux_lev_2_decoders.readOp.dynamic * 1e9)
! 	            			<<"; ";
! 	        	cout<< endl;
! 	        }
! 	        else
! 		    	cout <<  "\tSense amp mux & associated drivers (nJ): " <<
! 		    			fr->data_array2.power_senseamp_mux_lev_1_predecoder_drivers.readOp.dynamic * 1e9 +
! 		    			fr->data_array2.power_senseamp_mux_lev_1_predecoder_blocks.readOp.dynamic * 1e9 +
! 		    			fr->data_array2.power_senseamp_mux_lev_1_decoders.readOp.dynamic * 1e9  +
! 		    			fr->data_array2.power_senseamp_mux_lev_2_predecoder_drivers.readOp.dynamic * 1e9 +
! 		    			fr->data_array2.power_senseamp_mux_lev_2_predecoder_blocks.readOp.dynamic * 1e9 +
! 		    			fr->data_array2.power_senseamp_mux_lev_2_decoders.readOp.dynamic * 1e9;
! 
! 	        if (dvs)
! 	        {
! 		        cout <<  "\tBitlines (nJ): " ;
! 
! 	        	for (i = 0; i<dvs_levels; i++)
! 	        		cout<<(fr->uca_q[i]->data_array2.power_bitlines.readOp.dynamic * 1e9 +
! 	    			       fr->uca_q[i]->data_array2.power_prechg_eq_drivers.readOp.dynamic* 1e9) <<"; ";
! 		        cout<< endl;
! 	        }
! 	        else
! 		        cout <<  "\tBitlines (nJ): " <<
! 		    			fr->data_array2.power_bitlines.readOp.dynamic * 1e9 +
! 		    			fr->data_array2.power_prechg_eq_drivers.readOp.dynamic * 1e9;
! 
! 	        if (dvs)
! 	        {
! 		    	cout <<  "\tSense amplifier energy (nJ): " ;
! 
! 	        	for (i = 0; i<dvs_levels; i++)
! 	        		cout<<fr->uca_q[i]->data_array2.power_sense_amps.readOp.dynamic * 1e9 <<"; ";
! 		        cout<< endl;
! 	        }
! 	        else
! 		    	cout <<  "\tSense amplifier energy (nJ): " <<
! 		    			fr->data_array2.power_sense_amps.readOp.dynamic * 1e9 ;
! 
! 	        if (dvs)
! 	        {
! 		    	cout <<  "\tSub-array output driver (nJ): ";
! 
! 	        	for (i = 0; i<dvs_levels; i++)
! 	        		cout<<fr->uca_q[i]->data_array2.power_output_drivers_at_subarray.readOp.dynamic * 1e9 <<"; ";
! 		        cout<< endl;
! 	        }
! 	        else
! 		    	cout <<  "\tSub-array output driver (nJ): " <<
! 		    			fr->data_array2.power_output_drivers_at_subarray.readOp.dynamic * 1e9 ;
! 
! 
! 	        if (dvs)
! 	        {
! 		    	cout << endl <<"  Total leakage power of a bank, including its network outside (mW): " ;
! 
! 	        	for (i = 0; i<dvs_levels; i++)
! 	        		cout<< (fr->uca_q[i]->data_array2.power.readOp.leakage) * 1e3 <<"; ";
! 	        	cout<< endl;
! 	        }
! 	        else
! 		    	cout << endl <<"  Total leakage power of a bank, including its network outside (mW): " <<
! 		    			 (fr->data_array2.power.readOp.leakage)*1e3; //CAM/FA does not support PG yet
! 
!     }
! 
! //    if (g_ip->is_cache && !g_ip->is_main_mem)
!     if ((!(g_ip->pure_ram|| g_ip->pure_cam || g_ip->fully_assoc)) && !g_ip->is_main_mem)
!     {
!     	 if(dvs) {
!     		 cout << endl << "  Tag array: \n Total dynamic read energy/access (nJ): ";
!     	    	for (i = 0; i<dvs_levels; i++)
!     	    		cout <<  fr->uca_q[i]->tag_array2.power.readOp.dynamic * 1e9 << "; ";
!     	    	cout << endl;
! 
!     	    	cout << "Total dynamic write energy/access (nJ): ";
!     	    	    	    	for (i = 0; i<dvs_levels; i++)
!     	    	    	    		cout <<  fr->uca_q[i]->tag_array2.power.writeOp.dynamic * 1e9 << "; ";
!     	    	    	    	cout << endl;
!     	    } else {
! 				cout << endl << "  Tag array: \n Total dynamic read energy/access (nJ): " <<
! 				fr->tag_array2.power.readOp.dynamic * 1e9 << endl;
! 				 cout << "Total dynamic write energy/access (nJ): " <<
!              fr->tag_array2.power.writeOp.dynamic * 1e9 << endl;
! 			}
!     	 if(dvs) {
!     		 cout << "\tTotal leakage read/write power of a bank (mW): " ;
!     	    	for (i = 0; i<dvs_levels; i++)
!     	    		cout <<  fr->uca_q[i]->tag_array2.power.readOp.leakage * 1e3 << "; ";
!     	    	cout << endl;
!     	    } else
! 			  cout << "\tTotal leakage read/write power of a bank (mW): " <<
! 				  fr->tag_array2.power.readOp.leakage * 1e3 << endl;
! 
!     	 if(dvs) {
!     		 cout << "\tTotal energy in H-tree outside banks (that includes both "
!     		         "address and data transfer) (nJ): ";
!     	    	for (i = 0; i<dvs_levels; i++)
!     	    		cout <<  (fr->uca_q[i]->tag_array2.power_routing_to_bank.readOp.dynamic) * 1e9 << "; ";
!     	    	cout << endl;
!     	    } else
! 			  cout << "\tTotal energy in H-tree outside banks (that includes both "
! 				"address and data transfer) (nJ): " <<
! 				  (/*fr->tag_array2.power_addr_input_htree.readOp.dynamic +
! 				   fr->tag_array2.power_data_output_htree.readOp.dynamic +*/
! 				   fr->tag_array2.power_routing_to_bank.readOp.dynamic) * 1e9 << endl;
! 
!     	 if(dvs) {
!     		 cout << "\tInput H-tree inside banks Energy (nJ): " ;
!     	    	for (i = 0; i<dvs_levels; i++)
!     	    		cout <<  (fr->uca_q[i]->tag_array2.power_addr_input_htree.readOp.dynamic) * 1e9 << "; ";
!     	    	cout << endl;
!     	    } else
! 			  cout << "\tInput H-tree inside banks Energy (nJ): " <<
! 			   (fr->tag_array2.power_addr_input_htree.readOp.dynamic) * 1e9 << endl;
! 
!     	 if(dvs) {
!     		 cout << "\tOutput Htree Energy (nJ): ";
!     	    	for (i = 0; i<dvs_levels; i++)
!     	    		cout <<   fr->uca_q[i]->tag_array2.power_data_output_htree.readOp.dynamic * 1e9 << "; ";
!     	    	cout << endl;
!     	    } else
! 			  cout << "\tOutput Htree Energy (nJ): " <<
! 				fr->tag_array2.power_data_output_htree.readOp.dynamic * 1e9 << endl;
! 
!     	 if(dvs) {
!     		 cout <<  "\tDecoder (nJ): " ;
!     	    	for (i = 0; i<dvs_levels; i++)
!     	    		cout << fr->uca_q[i]->tag_array2.power_row_predecoder_drivers.readOp.dynamic * 1e9 +
!     	    		        fr->uca_q[i]->tag_array2.power_row_predecoder_blocks.readOp.dynamic * 1e9 << "; ";
!     	    	cout << endl;
!     	    } else
! 			  cout <<  "\tDecoder (nJ): " <<
! 				fr->tag_array2.power_row_predecoder_drivers.readOp.dynamic * 1e9 +
! 				fr->tag_array2.power_row_predecoder_blocks.readOp.dynamic * 1e9 << endl;
! 
!     	 if(dvs) {
!     		 cout <<  "\tWordline (nJ): " ;
!     	    	for (i = 0; i<dvs_levels; i++)
!     	    		cout << fr->uca_q[i]->tag_array2.power_row_decoders.readOp.dynamic * 1e9 << "; ";
!     	    	cout << endl;
!     	    } else
! 			  cout <<  "\tWordline (nJ): " <<
! 				fr->tag_array2.power_row_decoders.readOp.dynamic * 1e9 << endl;
! 
!     	 if(dvs) {
!     		 cout <<  "\tBitline mux & associated drivers (nJ): " ;
!     	    	for (i = 0; i<dvs_levels; i++)
! 					cout <<  fr->uca_q[i]->tag_array2.power_bit_mux_predecoder_drivers.readOp.dynamic * 1e9 +
! 					fr->uca_q[i]->tag_array2.power_bit_mux_predecoder_blocks.readOp.dynamic * 1e9 +
! 					fr->uca_q[i]->tag_array2.power_bit_mux_decoders.readOp.dynamic * 1e9 << "; ";
!     	    		 cout << endl;
!     	    } else
! 			  cout <<  "\tBitline mux & associated drivers (nJ): " <<
! 				fr->tag_array2.power_bit_mux_predecoder_drivers.readOp.dynamic * 1e9 +
! 				fr->tag_array2.power_bit_mux_predecoder_blocks.readOp.dynamic * 1e9 +
! 				fr->tag_array2.power_bit_mux_decoders.readOp.dynamic * 1e9 << endl;
! 
!     	 if(dvs) {
!     		 cout <<  "\tSense amp mux & associated drivers (nJ): ";
!     	    	for (i = 0; i<dvs_levels; i++)
!     	    		cout << fr->uca_q[i]->tag_array2.power_senseamp_mux_lev_1_predecoder_drivers.readOp.dynamic * 1e9 +
! 			        fr->uca_q[i]->tag_array2.power_senseamp_mux_lev_1_predecoder_blocks.readOp.dynamic * 1e9 +
! 			        fr->uca_q[i]->tag_array2.power_senseamp_mux_lev_1_decoders.readOp.dynamic * 1e9  +
! 			        fr->uca_q[i]->tag_array2.power_senseamp_mux_lev_2_predecoder_drivers.readOp.dynamic * 1e9 +
! 			        fr->uca_q[i]->tag_array2.power_senseamp_mux_lev_2_predecoder_blocks.readOp.dynamic * 1e9 +
! 			        fr->uca_q[i]->tag_array2.power_senseamp_mux_lev_2_decoders.readOp.dynamic * 1e9 << "; ";
!     	    	cout << endl;
!     	    } else
! 			  cout <<  "\tSense amp mux & associated drivers (nJ): " <<
! 				fr->tag_array2.power_senseamp_mux_lev_1_predecoder_drivers.readOp.dynamic * 1e9 +
! 				fr->tag_array2.power_senseamp_mux_lev_1_predecoder_blocks.readOp.dynamic * 1e9 +
! 				fr->tag_array2.power_senseamp_mux_lev_1_decoders.readOp.dynamic * 1e9  +
! 				fr->tag_array2.power_senseamp_mux_lev_2_predecoder_drivers.readOp.dynamic * 1e9 +
! 				fr->tag_array2.power_senseamp_mux_lev_2_predecoder_blocks.readOp.dynamic * 1e9 +
! 				fr->tag_array2.power_senseamp_mux_lev_2_decoders.readOp.dynamic * 1e9 << endl;
! 
!     	 if(dvs) {
!     		 cout <<  "\tBitlines (nJ): " ;
!     	    	for (i = 0; i<dvs_levels; i++)
!     	    		cout <<  fr->uca_q[i]->tag_array2.power_bitlines.readOp.dynamic * 1e9 << "; ";
!     	    	cout << endl;
!     	    } else
! 			  cout <<  "\tBitlines (nJ): " <<
! 				fr->tag_array2.power_bitlines.readOp.dynamic * 1e9 << endl;
! 
!     	 if(dvs) {
!     		 cout <<  "\tSense amplifier energy (nJ): " ;
!     	    	for (i = 0; i<dvs_levels; i++)
!     	    		cout << fr->uca_q[i]->tag_array2.power_sense_amps.readOp.dynamic * 1e9 << "; ";
!     	    	cout << endl;
!     	    } else
! 			  cout <<  "\tSense amplifier energy (nJ): " <<
! 				fr->tag_array2.power_sense_amps.readOp.dynamic * 1e9 << endl;
! 
!     	 if(dvs) {
!     		 cout <<  "\tSub-array output driver (nJ): " ;
!     	    	for (i = 0; i<dvs_levels; i++)
!     	    		cout <<   fr->uca_q[i]->tag_array2.power_output_drivers_at_subarray.readOp.dynamic * 1e9 << "; ";
!     	    	cout << endl;
!     	    } else
! 			  cout <<  "\tSub-array output driver (nJ): " <<
! 				fr->tag_array2.power_output_drivers_at_subarray.readOp.dynamic * 1e9 << endl;
! 
!     	           if (dvs)
!     	           {
!     	        	   cout << "\tTotal leakage power in H-tree outside a bank (that includes both "
!     	        			   "address and data network) without power gating((mW)): " ;
!     	        	   for (i = 0; i<dvs_levels; i++)
!     	        		   cout<<(fr->uca_q[i]->tag_array2.power_routing_to_bank.readOp.leakage) * 1e3 <<"; ";
!         	           cout<< endl;
!     	           }
!     	           else
!     	        	   cout << "\tTotal leakage power in H-tree outside a bank (that includes both "
!     	        	       	   "address and data network) without power gating((mW)): " <<
!     	        	       	  (fr->tag_array2.power_routing_to_bank.readOp.leakage) * 1e3;
! 
      }
  
      cout << endl << endl <<  "Area Components:" << endl << endl;
      /* Data array area stats */
!     if(dvs) {
!     	cout <<  "  Data array: \n Area (mm2): ";
!        	for (i = 0; i<dvs_levels; i++)
!        		cout << fr->uca_q[i]->data_array2.area * 1e-6 << "; ";
!        	cout << endl;
!        } else
!     	   cout <<  "  Data array: \n Area (mm2): " << fr->data_array2.area * 1e-6 << endl;
! 
!     if(dvs) {
!     	 cout <<  "\tHeight (mm): ";
!        	for (i = 0; i<dvs_levels; i++)
!        		cout <<   fr->uca_q[i]->data_array2.all_banks_height*1e-3 << "; ";
!        	cout << endl;
!        } else
! 		cout <<  "\tHeight (mm): " <<
! 		  fr->data_array2.all_banks_height*1e-3 << endl;
! 
!     if(dvs) {
!     	cout <<  "\tWidth (mm): ";
!        	for (i = 0; i<dvs_levels; i++)
!        		cout <<  fr->uca_q[i]->data_array2.all_banks_width*1e-3 << "; ";
!        	cout << endl;
!        } else
! 		cout <<  "\tWidth (mm): " <<
! 		  fr->data_array2.all_banks_width*1e-3 << endl;
! 
      if (g_ip->print_detail) {
!     	 if(dvs) {
!     		 cout <<  "\tArea efficiency (Memory cell area/Total area) : ";
!     	    	for (i = 0; i<dvs_levels; i++)
!     	    		cout << fr->uca_q[i]->data_array2.area_efficiency << " %" << "; ";
!     	    	cout << endl;
!     	    } else
! 			  cout <<  "\tArea efficiency (Memory cell area/Total area) : " <<
! 				fr->data_array2.area_efficiency << " %" << endl;
! 
!     	 if(dvs) {
!     		 cout << "\t\tMAT Height (mm): " ;
!     	    	for (i = 0; i<dvs_levels; i++)
!     	    		cout << fr->uca_q[i]->data_array2.mat_height*1e-3 << "; ";
!     	    	cout << endl;
!     	    } else
! 			  cout << "\t\tMAT Height (mm): " <<
! 				fr->data_array2.mat_height*1e-3 << endl;
! 
!     	 if(dvs) {
!     		 cout << "\t\tMAT Length (mm): ";
!     	    	for (i = 0; i<dvs_levels; i++)
!     	    		cout << fr->uca_q[i]->data_array2.mat_length*1e-3 << "; ";
!     	    	cout << endl;
!     	    } else
! 			  cout << "\t\tMAT Length (mm): " <<
! 				fr->data_array2.mat_length*1e-3 << endl;
! 
!     	 if(dvs) {
!     		 cout << "\t\tSubarray Height (mm): ";
!     	    	for (i = 0; i<dvs_levels; i++)
!     	    		cout <<  fr->uca_q[i]->data_array2.subarray_height*1e-3 << "; ";
!     	    	cout << endl;
!     	    } else
! 			  cout << "\t\tSubarray Height (mm): " <<
! 				fr->data_array2.subarray_height*1e-3 << endl;
! 
!     	 if(dvs) {
!     		 cout << "\t\tSubarray Length (mm): ";
!     	    	for (i = 0; i<dvs_levels; i++)
!     	    		cout << fr->uca_q[i]->data_array2.subarray_length*1e-3 << "; ";
!     	    	cout << endl;
!     	    } else
! 			  cout << "\t\tSubarray Length (mm): " <<
! 				fr->data_array2.subarray_length*1e-3 << endl;
      }
  
      /* Tag array area stats */
!     if ((!(g_ip->pure_ram|| g_ip->pure_cam || g_ip->fully_assoc)) && !g_ip->is_main_mem)
      {
!     	 if(dvs) {
!     		 cout << endl << "  Tag array: \nArea (mm2): ";
!     	    	for (i = 0; i<dvs_levels; i++)
!     	    		cout << fr->uca_q[i]->tag_array2.area * 1e-6 << "; ";
!    	    		 cout << endl;
!     	    } else
!     	    	cout << endl << "  Tag array: \nArea (mm2): " << fr->tag_array2.area * 1e-6 << endl;
! 
!     	 if(dvs) {
!     		 cout <<  "\tHeight (mm): " ;
! 			for (i = 0; i<dvs_levels; i++)
! 				cout << fr->uca_q[i]->tag_array2.all_banks_height*1e-3 << "; ";
! 			cout << endl;
!     	    } else
! 			  cout <<  "\tHeight (mm): " <<
! 				fr->tag_array2.all_banks_height*1e-3 << endl;
! 
!     	 if(dvs) {
!     		 cout <<  "\tWidth (mm): ";
!     	    	for (i = 0; i<dvs_levels; i++)
!     	    		cout << fr->uca_q[i]->tag_array2.all_banks_width*1e-3 << "; ";
!     	    	cout << endl;
!     	    } else
! 			  cout <<  "\tWidth (mm): " <<
! 				fr->tag_array2.all_banks_width*1e-3 << endl;
! 
        if (g_ip->print_detail)
        {
!     	  if(dvs) {
!     		  cout <<  "\tArea efficiency (Memory cell area/Total area) : ";
!     	     	for (i = 0; i<dvs_levels; i++)
!     	     		cout <<  fr->uca_q[i]->tag_array2.area_efficiency << " %" << "; ";
!     	     	cout << endl;
!     	     } else
! 				cout <<  "\tArea efficiency (Memory cell area/Total area) : " <<
! 				  fr->tag_array2.area_efficiency << " %" << endl;
! 
!     	  if(dvs) {
!     		  cout << "\t\tMAT Height (mm): " ;
!     	     	for (i = 0; i<dvs_levels; i++)
!     	     		cout <<  fr->uca_q[i]->tag_array2.mat_height*1e-3 << "; ";
!     	     	cout << endl;
!     	     } else
! 				cout << "\t\tMAT Height (mm): " <<
! 				  fr->tag_array2.mat_height*1e-3 << endl;
! 
!     	  if(dvs) {
!     		  cout << "\t\tMAT Length (mm): " ;
!     	     	for (i = 0; i<dvs_levels; i++)
!     	     		cout <<  fr->uca_q[i]->tag_array2.mat_length*1e-3 << "; ";
!     	     	cout << endl;
!     	     } else
! 				cout << "\t\tMAT Length (mm): " <<
! 				  fr->tag_array2.mat_length*1e-3 << endl;
! 
!     	  if(dvs) {
!     		  cout << "\t\tSubarray Height (mm): ";
!     	     	for (i = 0; i<dvs_levels; i++)
!     	     		cout <<  fr->uca_q[i]->tag_array2.subarray_height*1e-3 << "; ";
!     		  cout << endl;
!     	     } else
! 				cout << "\t\tSubarray Height (mm): " <<
! 				  fr->tag_array2.subarray_height*1e-3 << endl;
! 
!     	  if(dvs) {
!     		  cout << "\t\tSubarray Length (mm): ";
!     	     	for (i = 0; i<dvs_levels; i++)
!     	     		cout << fr->uca_q[i]->tag_array2.subarray_length*1e-3 << "; ";
!     	     	cout << endl;
!     	     } else
! 				cout << "\t\tSubarray Length (mm): " <<
! 				  fr->tag_array2.subarray_length*1e-3 << endl;
        }
      }
!     //Wire wpr; //TODO: this must change, since this changes the wire value during dvs loop.
!     //Wire::print_wire();//move outside output UCA
    }
  }
+ //Divya end
  
  /***** Alireza - BEGIN *****/
  void output_summary_of_results(uca_org_t *fr) {
***************
*** 1539,1546 ****
    cout << "Cache size        : " << cache_size << cache_size_unit << endl; // unit. -Alireza
    cout << "Technology        : " << g_ip->F_sz_nm << "nm" << endl; // changed to nm. -Alireza
    cout << "Transistor type   : " << (g_ip->is_finfet ? "FinFET" : "CMOS" ) << endl; // Alireza
!   cout << "Operating voltage : " << (g_ip->is_near_threshold ? "Near-threshold" : "Super-threshold" ) << endl; // Alireza
!   if (g_ip->sram_cell_design.getType()==std_6T) { // Alireza
      cout << "SRAM cell type    : " << "Standard 6T" << endl;
    } else if (g_ip->sram_cell_design.getType()==std_8T) {
      cout << "SRAM cell type    : " << "Standard 8T" << endl;
--- 2842,2850 ----
    cout << "Cache size        : " << cache_size << cache_size_unit << endl; // unit. -Alireza
    cout << "Technology        : " << g_ip->F_sz_nm << "nm" << endl; // changed to nm. -Alireza
    cout << "Transistor type   : " << (g_ip->is_finfet ? "FinFET" : "CMOS" ) << endl; // Alireza
! //  cout << "Operating voltage : " << (g_ip->is_near_threshold ? "Near-threshold" : "Super-threshold" ) << endl; // Alireza
!   cout << "Operating voltage             : " << g_ip->vdd << endl; // Alireza
!    if (g_ip->sram_cell_design.getType()==std_6T) { // Alireza
      cout << "SRAM cell type    : " << "Standard 6T" << endl;
    } else if (g_ip->sram_cell_design.getType()==std_8T) {
      cout << "SRAM cell type    : " << "Standard 8T" << endl;
***************
*** 1570,1601 ****
  
      cout << "Data Array Leakage Power Components:" << endl;
      cout << "\tTotal leakage power: " <<
!         fr->data_array2->power.readOp.leakage * 1e3 << "mW" << endl;
      cout << "\tBank leakage power: " <<
!         fr->data_array2->leak_power_bank * 1e3 << "mW" << endl;
      cout << "\tMat leakage power: " <<
!         fr->data_array2->leak_power_mat * 1e3 << "mW" << endl;
      cout << "\tMemory array leakage power: " <<
!         fr->data_array2->leak_power_mem_array * 1e3 << "mW" << endl;
      cout << "\tSRAM cell leakage power: " <<
!         fr->data_array2->leak_power_sram_cell * 1e9 << "nW" << endl;
  
      cout << endl << "Subarray Statistics:" << endl;
      cout << "\tSubarray - Number of rows: " <<
!         fr->data_array2->subarray_num_rows << endl;
      cout << "\tSubarray - Number of columns: " <<
!         fr->data_array2->subarray_num_cols << endl;
      cout << "\tNumber of subarrays per Mat: " <<
!         fr->data_array2->num_subarrays_per_mat << endl;
  		  
    cout << "-------------------------------------------------------------\n";
    
!   cout << "Best Ndwl     : " << fr->data_array2->Ndwl << endl;
!   cout << "Best Ndbl     : " << fr->data_array2->Ndbl << endl;
!   cout << "Best Nspd     : " << fr->data_array2->Nspd << endl;
!   cout << "Best Ndcm     : " << fr->data_array2->deg_bl_muxing << endl;
!   cout << "Best Ndsam L1 : " << fr->data_array2->Ndsam_lev_1 << endl;
!   cout << "Best Ndsam L2 : " << fr->data_array2->Ndsam_lev_2 << endl;
    
    cout << "-------------------------------------------------------------\n";
  }
--- 2874,2905 ----
  
      cout << "Data Array Leakage Power Components:" << endl;
      cout << "\tTotal leakage power: " <<
!         fr->data_array2.power.readOp.leakage * 1e3 << "mW" << endl;
      cout << "\tBank leakage power: " <<
!         fr->data_array2.leak_power_bank * 1e3 << "mW" << endl;
      cout << "\tMat leakage power: " <<
!         fr->data_array2.leak_power_mat * 1e3 << "mW" << endl;
      cout << "\tMemory array leakage power: " <<
!         fr->data_array2.leak_power_mem_array * 1e3 << "mW" << endl;
      cout << "\tSRAM cell leakage power: " <<
!         fr->data_array2.leak_power_sram_cell * 1e9 << "nW" << endl;
  
      cout << endl << "Subarray Statistics:" << endl;
      cout << "\tSubarray - Number of rows: " <<
!         fr->data_array2.subarray_num_rows << endl;
      cout << "\tSubarray - Number of columns: " <<
!         fr->data_array2.subarray_num_cols << endl;
      cout << "\tNumber of subarrays per Mat: " <<
!         fr->data_array2.num_subarrays_per_mat << endl;
  		  
    cout << "-------------------------------------------------------------\n";
    
!   cout << "Best Ndwl     : " << fr->data_array2.Ndwl << endl;
!   cout << "Best Ndbl     : " << fr->data_array2.Ndbl << endl;
!   cout << "Best Nspd     : " << fr->data_array2.Nspd << endl;
!   cout << "Best Ndcm     : " << fr->data_array2.deg_bl_muxing << endl;
!   cout << "Best Ndsam L1 : " << fr->data_array2.Ndsam_lev_1 << endl;
!   cout << "Best Ndsam L2 : " << fr->data_array2.Ndsam_lev_2 << endl;
    
    cout << "-------------------------------------------------------------\n";
  }
***************
*** 1616,1618 ****
--- 2920,3333 ----
  
  /****** Alireza - END ******/
  
+ //divya adding 14-11-2021
+ //McPAT's plain interface, please keep !!!
+ uca_org_t cacti_interface(InputParameter  * const local_interface)
+ {
+   uca_org_t fin_res;
+   fin_res.valid = false;
+   double Ioffs[5];
+ 
+   g_ip = local_interface;
+ //  cout << "io.cc::cacti_interface, techsize: " << g_ip->F_sz_um << ", wire: " << g_ip->wire_F_sz_um << ", finfet: " << g_ip->is_finfet << ", ncfet: " << g_ip->is_ncfet <<
+ //		  ", itrs: " << g_ip->is_itrs2012 << ", asap7: " << g_ip->is_asap7 << ", projection: " << g_ip->ic_proj_type << ", vdd: " << g_ip->vdd << endl;
+ //  cout << "io.cc ndbl: " << g_ip->ndbl << ", ndwl: " << g_ip->ndwl <<
+ //		  ", nspd: " << g_ip->nspd << ", ndcm: " << g_ip->nspd << ", sam1: " << g_ip->ndsam1 << ", sam2: " << g_ip->ndsam2 << endl;
+ 
+ //  cout << "is finfet: " << g_ip->is_finfet << ", vdd: " << g_ip->vdd <<  endl;
+   //Divya adding 22-11-2021
+   //fix the parameters for finfet and ncfet as appropriate
+   if(g_ip->is_finfet) {
+ 
+ 	  //Fixing SRAM cells to 6T1 SRAM model
+ 	  g_ip->sram_cell_design.setType(std_6T);
+ 	  g_ip->Nfins[0] = 1;	// access transistor fins
+ 	  g_ip->Nfins[1] = 1;	// pup fins
+ 	  g_ip->Nfins[2] = 1; 	// pdn fins
+ 
+ 	  //Dual Gate control is being set to false
+ 	  g_ip->sram_cell_design.setDGcontrol(false);
+ //	  cout << "is ncfet: " << g_ip->is_ncfet << ", vdd: " << g_ip->vdd <<  endl;
+ 
+ 	  //Fixing the transistor parameters acdng to ncfet/finfet type, instead of reading transistor.xml files
+ 	  if(g_ip->is_ncfet) {	//for NCFET
+ 		  g_ip->Lphys[0] = 0.02;	//20-nm access transistor
+ 		  g_ip->Lphys[1] = 0.02;	//20-nm pup
+ 		  g_ip->Lphys[2] = 0.02;	//20-nm pdn
+ 
+ 		  //NCFET Ioff currents acdng to voltage
+ 		  if(g_ip->vdd == 0.8) {
+ 			  Ioffs[0] = 5.836957e-10;	//n-type acc transistor
+ 			  Ioffs[1] = 6.39565e-10;	//p-type pup transistor
+ 			  Ioffs[2] = 5.836957e-10;	//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.7) {
+ 			  Ioffs[0] = 6.880435e-10;	//n-type acc transistor
+ 			  Ioffs[1] = 7.836957e-10;	//p-type pup transistor
+ 			  Ioffs[2] = 6.880435e-10;	//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.6) {
+ 			  Ioffs[0] = 8.119565e-10;	//n-type acc transistor
+ 			  Ioffs[1] = 1.0e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 8.119565e-10;	//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.5) {
+ //			  cout << "0.5v ioff \n";
+ 			  Ioffs[0] = 1.0e-09;		//n-type acc transistor
+ 			  Ioffs[1] = 1.184783e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 1.0e-09;		//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.4) {
+ 			  Ioffs[0] = 1.119565e-09;	//n-type acc transistor
+ 			  Ioffs[1] = 1.456522e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 1.119565e-09;	//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.3) {
+ 			  Ioffs[0] = 1.304348e-09;	//n-type acc transistor
+ 			  Ioffs[1] = 1.771739e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 1.304348e-09;	//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.2) {
+ 			  Ioffs[0] = 1.51087e-09;	//n-type acc transistor
+ 			  Ioffs[1] = 2.163043e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 1.51087e-09;	//n-type pdn transistor
+ 		  } else
+ 				cerr << "ERROR: Invalid transistor type!\nSupported transistor types: 'finfet', 'cmos'.\n";
+ 	  }
+ 	  else {	//for FinFET
+ 		  g_ip->Lphys[0] = 0.02;	//20-nm access transistor
+ 		  g_ip->Lphys[1] = 0.02;	//20-nm pup
+ 		  g_ip->Lphys[2] = 0.02;	//20-nm pdn
+ 
+ 		  //FinFET Ioff currents acdng to voltage
+ 		  if(g_ip->vdd == 0.8) {
+ 			  Ioffs[0] = 6.684783e-09;	//n-type acc transistor
+ 			  Ioffs[1] = 6.478261e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 6.684783e-09;	//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.7) {
+ 			  Ioffs[0] = 5.336957e-09;	//n-type acc transistor
+ 			  Ioffs[1] = 5.130435e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 5.336957e-09;	//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.6) {
+ 			  Ioffs[0] = 4.217391e-09;	//n-type acc transistor
+ 			  Ioffs[1] = 4.054348e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 4.217391e-09;	//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.5) {
+ 			  Ioffs[0] = 3.304348e-09;		//n-type acc transistor
+ 			  Ioffs[1] = 3.195652e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 3.304348e-09;		//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.4) {
+ 			  Ioffs[0] = 2.565217e-09;	//n-type acc transistor
+ 			  Ioffs[1] = 2.5e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 2.565217e-09;	//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.3) {
+ 			  Ioffs[0] = 2.0e-09;	//n-type acc transistor
+ 			  Ioffs[1] = 2.0e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 2.0e-09;	//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.2) {
+ 			  Ioffs[0] = 1.489133e-09;	//n-type acc transistor
+ 			  Ioffs[1] = 1.532609e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 1.489133e-09;	//n-type pdn transistor
+ 		  } else
+ 				cerr << "ERROR: Invalid transistor type!\nSupported transistor types: 'finfet', 'cmos'.\n";
+ 	  }
+ 	  g_ip->sram_cell_design.setTransistorParams(g_ip->Nfins, g_ip->Lphys, Ioffs);
+   }
+ //divya end
+ 
+   if (g_ip->print_input_args)
+ 	  g_ip->display_ip();
+   if (!g_ip->error_checking()) exit(0);
+ 
+ //  init_tech_params(g_ip->F_sz_um, false);
+   init_tech_params(g_ip->F_sz_um, g_ip->wire_F_sz_um, false); //Divya added wire_technology
+ 
+   Wire winit; // Do not delete this line. It initializes wires.
+ 
+ 
+ #ifdef ENABLE_CACHE
+   static DB *dbp = NULL;
+ 
+   if (dbp == NULL)
+   {
+     char filename[1024];
+     snprintf(filename, 1024, "%s/mcpat-%s.db", getenv("TMPDIR") ? getenv("TMPDIR") : "/tmp", getenv("USER"));
+     db_create(&dbp, NULL, 0);
+     dbp->open(dbp, NULL, filename, NULL, DB_HASH, DB_CREATE, 0);
+   }
+ 
+   DBT key, data;
+   memset(&key, 0, sizeof(DBT));
+   memset(&data, 0, sizeof(DBT));
+ 
+   size_t o1 = offsetof(InputParameter, first),
+          o2 = offsetof(InputParameter, last);
+ 
+   // Create a clean copy of our input parameters, with zeroes on all unused locations
+   InputParameter clean_ip;
+   memset((char*)&clean_ip + o1, 0, o2 - o1); // Set everything to zero
+   clean_ip = *g_ip; // Copies over actual (used) data
+ 
+   key.data = (char*)&clean_ip + o1;
+   key.size = o2 - o1;
+ 
+   if (DB_NOTFOUND == dbp->get(dbp, NULL, &key, &data, 0) /* Not found in DB */
+       || sizeof(fin_res) != data.size /* Or from a different version */)
+   {
+      solve(&fin_res);
+ 
+     // If found (but size is wrong): delete it
+     if (DB_NOTFOUND != dbp->get(dbp, NULL, &key, &data, 0))
+       dbp->del(dbp, NULL, &key, 0);
+ 
+     data.data = &fin_res;
+     data.size = sizeof(fin_res);
+     int res = dbp->put(dbp, NULL, &key, &data, DB_NOOVERWRITE);
+     if (res)
+       printf("DB write error: %d\n", res);
+     dbp->sync(dbp, 0);
+   }
+   else
+   {
+     assert(sizeof(fin_res) == data.size);
+     memcpy(&fin_res, data.data, sizeof(fin_res));
+   }
+ #else
+   solve(&fin_res);
+ #endif
+ 
+ //  if (g_ip->is_dvs)
+   if (!g_ip->dvs_voltage.empty())
+   {
+ 	  update_dvs(&fin_res);
+   }
+ 
+   return fin_res;
+ }
+ 
+ //McPAT's plain interface, please keep !!!
+ uca_org_t init_interface(InputParameter* const local_interface)
+ {
+   uca_org_t fin_res;
+   fin_res.valid = false;
+   double Ioffs[5];
+ 
+   g_ip = local_interface;
+ 
+   //Divya adding 22-11-2021
+   //fix the parameters for finfet and ncfet as appropriate
+   if(g_ip->is_finfet) {
+ 	  //Fixing SRAM cells to 6T1 SRAM model
+ 	  g_ip->sram_cell_design.setType(std_6T);
+ 	  g_ip->Nfins[0] = 1;	// access transistor fins
+ 	  g_ip->Nfins[1] = 1;	// pup fins
+ 	  g_ip->Nfins[2] = 1; 	// pdn fins
+ 
+ 	  //Dual Gate control is being set to false
+ 	  g_ip->sram_cell_design.setDGcontrol(false);
+ 
+ 	  //Fixing the transistor parameters acdng to ncfet/finfet type, instead of reading transistor.xml files
+ 	  if(g_ip->is_ncfet) {	//for NCFET
+ 		  g_ip->Lphys[0] = 0.02;	//20-nm access transistor
+ 		  g_ip->Lphys[1] = 0.02;	//20-nm pup
+ 		  g_ip->Lphys[2] = 0.02;	//20-nm pdn
+ 
+ 		  //NCFET Ioff currents acdng to voltage
+ 		  if(g_ip->vdd == 0.8) {
+ 			  Ioffs[0] = 5.836957e-10;	//n-type acc transistor
+ 			  Ioffs[1] = 6.39565e-10;	//p-type pup transistor
+ 			  Ioffs[2] = 5.836957e-10;	//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.7) {
+ 			  Ioffs[0] = 6.880435e-10;	//n-type acc transistor
+ 			  Ioffs[1] = 7.836957e-10;	//p-type pup transistor
+ 			  Ioffs[2] = 6.880435e-10;	//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.6) {
+ 			  Ioffs[0] = 8.119565e-10;	//n-type acc transistor
+ 			  Ioffs[1] = 1.0e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 8.119565e-10;	//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.5) {
+ 			  Ioffs[0] = 1.0e-09;		//n-type acc transistor
+ 			  Ioffs[1] = 1.184783e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 1.0e-09;		//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.4) {
+ 			  Ioffs[0] = 1.119565e-09;	//n-type acc transistor
+ 			  Ioffs[1] = 1.456522e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 1.119565e-09;	//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.3) {
+ 			  Ioffs[0] = 1.304348e-09;	//n-type acc transistor
+ 			  Ioffs[1] = 1.771739e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 1.304348e-09;	//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.2) {
+ 			  Ioffs[0] = 1.51087e-09;	//n-type acc transistor
+ 			  Ioffs[1] = 2.163043e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 1.51087e-09;	//n-type pdn transistor
+ 		  } else
+ 				cerr << "ERROR: Invalid transistor type!\nSupported transistor types: 'finfet', 'cmos'.\n";
+ 	  }
+ 	  else {	//for FinFET
+ 		  g_ip->Lphys[0] = 0.02;	//20-nm access transistor
+ 		  g_ip->Lphys[1] = 0.02;	//20-nm pup
+ 		  g_ip->Lphys[2] = 0.02;	//20-nm pdn
+ 
+ 		  //FinFET Ioff currents acdng to voltage
+ 		  if(g_ip->vdd == 0.8) {
+ 			  Ioffs[0] = 6.684783e-09;	//n-type acc transistor
+ 			  Ioffs[1] = 6.478261e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 6.684783e-09;	//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.7) {
+ 			  Ioffs[0] = 5.336957e-09;	//n-type acc transistor
+ 			  Ioffs[1] = 5.130435e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 5.336957e-09;	//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.6) {
+ 			  Ioffs[0] = 4.217391e-09;	//n-type acc transistor
+ 			  Ioffs[1] = 4.054348e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 4.217391e-09;	//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.5) {
+ 			  Ioffs[0] = 3.304348e-09;		//n-type acc transistor
+ 			  Ioffs[1] = 3.195652e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 3.304348e-09;		//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.4) {
+ 			  Ioffs[0] = 2.565217e-09;	//n-type acc transistor
+ 			  Ioffs[1] = 2.5e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 2.565217e-09;	//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.3) {
+ 			  Ioffs[0] = 2.0e-09;	//n-type acc transistor
+ 			  Ioffs[1] = 2.0e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 2.0e-09;	//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.2) {
+ 			  Ioffs[0] = 1.489133e-09;	//n-type acc transistor
+ 			  Ioffs[1] = 1.532609e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 1.489133e-09;	//n-type pdn transistor
+ 		  } else
+ 				cerr << "ERROR: Invalid transistor type!\nSupported transistor types: 'finfet', 'cmos'.\n";
+ 	  }
+ 	  g_ip->sram_cell_design.setTransistorParams(g_ip->Nfins, g_ip->Lphys, Ioffs);
+ 
+ 	//divya end
+   }
+   g_ip->error_checking();
+ 
+ //  cout << "io.cc::init_interface, techsize: " << g_ip->F_sz_um << ", wire: " << g_ip->wire_F_sz_um << ", finfet: " << g_ip->is_finfet << ", ncfet: " << g_ip->is_ncfet <<
+ //		  ", itrs: " << g_ip->is_itrs2012 << ", asap7: " << g_ip->is_asap7 << ", projection: " << g_ip->ic_proj_type << ", vdd: " << g_ip->vdd << endl;
+ 
+   //  init_tech_params(g_ip->F_sz_um, false);
+   init_tech_params(g_ip->F_sz_um, g_ip->wire_F_sz_um, false); //Divya added wire_technology
+   Wire winit; // Do not delete this line. It initializes wires.
+ 
+   return fin_res;
+ }
+ 
+ 
+ void reconfigure(InputParameter *local_interface, uca_org_t *fin_res)
+ {
+ 	double Ioffs[5];
+ 
+   // Copy the InputParameter to global interface (g_ip) and do error checking.
+   g_ip = local_interface;
+   cout << "io.cc::reconfigure, techsize: " << g_ip->F_sz_um << ", wire: " << g_ip->wire_F_sz_um << ", finfet: " << g_ip->is_finfet << ", ncfet: " << g_ip->is_ncfet <<
+ 		  ", itrs: " << g_ip->is_itrs2012 << ", asap7: " << g_ip->is_asap7 << ", projection: " << g_ip->ic_proj_type << ", vdd: " << g_ip->vdd << endl;
+ 
+   if(g_ip->is_finfet) {
+   //Divya adding 22-11-2021
+   //fix the parameters for finfet and ncfet as appropriate
+ 
+ 	  //Fixing SRAM cells to 6T1 SRAM model
+ 	  g_ip->sram_cell_design.setType(std_6T);
+ 	  g_ip->Nfins[0] = 1;	// access transistor fins
+ 	  g_ip->Nfins[1] = 1;	// pup fins
+ 	  g_ip->Nfins[2] = 1; 	// pdn fins
+ 
+ 	  //Dual Gate control is being set to false
+ 	  g_ip->sram_cell_design.setDGcontrol(false);
+ 
+ 	  //Fixing the transistor parameters acdng to ncfet/finfet type, instead of reading transistor.xml files
+ 	  if(g_ip->is_ncfet) {	//for NCFET
+ 		  g_ip->Lphys[0] = 0.02;	//20-nm access transistor
+ 		  g_ip->Lphys[1] = 0.02;	//20-nm pup
+ 		  g_ip->Lphys[2] = 0.02;	//20-nm pdn
+ 
+ 		  //NCFET Ioff currents acdng to voltage
+ 		  if(g_ip->vdd == 0.8) {
+ 			  Ioffs[0] = 5.836957e-10;	//n-type acc transistor
+ 			  Ioffs[1] = 6.39565e-10;	//p-type pup transistor
+ 			  Ioffs[2] = 5.836957e-10;	//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.7) {
+ 			  Ioffs[0] = 6.880435e-10;	//n-type acc transistor
+ 			  Ioffs[1] = 7.836957e-10;	//p-type pup transistor
+ 			  Ioffs[2] = 6.880435e-10;	//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.6) {
+ 			  Ioffs[0] = 8.119565e-10;	//n-type acc transistor
+ 			  Ioffs[1] = 1.0e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 8.119565e-10;	//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.5) {
+ 			  Ioffs[0] = 1.0e-09;		//n-type acc transistor
+ 			  Ioffs[1] = 1.184783e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 1.0e-09;		//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.4) {
+ 			  Ioffs[0] = 1.119565e-09;	//n-type acc transistor
+ 			  Ioffs[1] = 1.456522e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 1.119565e-09;	//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.3) {
+ 			  Ioffs[0] = 1.304348e-09;	//n-type acc transistor
+ 			  Ioffs[1] = 1.771739e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 1.304348e-09;	//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.2) {
+ 			  Ioffs[0] = 1.51087e-09;	//n-type acc transistor
+ 			  Ioffs[1] = 2.163043e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 1.51087e-09;	//n-type pdn transistor
+ 		  } else
+ 				cerr << "ERROR: Invalid transistor type!\nSupported transistor types: 'finfet', 'cmos'.\n";
+ 	  }
+ 	  else {	//for FinFET
+ 		  g_ip->Lphys[0] = 0.02;	//20-nm access transistor
+ 		  g_ip->Lphys[1] = 0.02;	//20-nm pup
+ 		  g_ip->Lphys[2] = 0.02;	//20-nm pdn
+ 
+ 		  //FinFET Ioff currents acdng to voltage
+ 		  if(g_ip->vdd == 0.8) {
+ 			  Ioffs[0] = 6.684783e-09;	//n-type acc transistor
+ 			  Ioffs[1] = 6.478261e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 6.684783e-09;	//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.7) {
+ 			  Ioffs[0] = 5.336957e-09;	//n-type acc transistor
+ 			  Ioffs[1] = 5.130435e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 5.336957e-09;	//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.6) {
+ 			  Ioffs[0] = 4.217391e-09;	//n-type acc transistor
+ 			  Ioffs[1] = 4.054348e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 4.217391e-09;	//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.5) {
+ 			  Ioffs[0] = 3.304348e-09;		//n-type acc transistor
+ 			  Ioffs[1] = 3.195652e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 3.304348e-09;		//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.4) {
+ 			  Ioffs[0] = 2.565217e-09;	//n-type acc transistor
+ 			  Ioffs[1] = 2.5e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 2.565217e-09;	//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.3) {
+ 			  Ioffs[0] = 2.0e-09;	//n-type acc transistor
+ 			  Ioffs[1] = 2.0e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 2.0e-09;	//n-type pdn transistor
+ 		  } else if(g_ip->vdd == 0.2) {
+ 			  Ioffs[0] = 1.489133e-09;	//n-type acc transistor
+ 			  Ioffs[1] = 1.532609e-09;	//p-type pup transistor
+ 			  Ioffs[2] = 1.489133e-09;	//n-type pdn transistor
+ 		  } else
+ 				cerr << "ERROR: Invalid transistor type!\nSupported transistor types: 'finfet', 'cmos'.\n";
+ 	  }
+ 	  g_ip->sram_cell_design.setTransistorParams(g_ip->Nfins, g_ip->Lphys, Ioffs);
+ 
+ 	  g_ip->F_sz_um 		= 0.014;	//14-nm in um
+ 	  g_ip->wire_F_sz_um 	= 0.007;	//7nm in um
+ 	  g_ip->is_asap7		= true;
+ 	  g_ip->ic_proj_type	= 0;		//0 for aggressive
+   }
+   //divya end
+ 
+   g_ip->error_checking();
+ 
+   // Initialize technology parameters
+ //  init_tech_params(g_ip->F_sz_um,false);
+   init_tech_params(g_ip->F_sz_um, g_ip->wire_F_sz_um, false); //Divya added wire_technology
+ 
+   Wire winit; // Do not delete this line. It initializes wires.
+ 
+   // This corresponds to solve() in the initialization process.
+   update_dvs(fin_res);
+ }
+ //divya adding end
+ 
Only in FN-CACTI: io_orig.cc
diff -crB pcacti_xml/main.cc FN-CACTI/main.cc
*** pcacti_xml/main.cc	2014-07-03 09:47:14.000000000 +0200
--- FN-CACTI/main.cc	2023-04-05 13:37:58.380153000 +0200
***************
*** 134,140 ****
                               atoi(argv[53]),
                               atoi(argv[54]));
    }
!   
  
    return 0;
  }
--- 134,140 ----
                               atoi(argv[53]),
                               atoi(argv[54]));
    }
!   result.cleanup();
  
    return 0;
  }
diff -crB pcacti_xml/mat.cc FN-CACTI/mat.cc
*** pcacti_xml/mat.cc	2014-07-03 09:48:20.000000000 +0200
--- FN-CACTI/mat.cc	2023-04-05 13:29:32.711897000 +0200
***************
*** 46,88 ****
  Mat::Mat(const DynamicParameter & dyn_p)
   :dp(dyn_p),
    power_subarray_out_drv(),
!   delay_fa_decoder(0), delay_before_decoder(0), delay_bitline(0),
    delay_wl_reset(0), delay_bl_restore(0),
    subarray(dp, g_ip->fully_assoc),
    power_bitline(), per_bitline_read_energy(0),
    deg_bl_muxing(dp.deg_bl_muxing), 
    num_act_mats_hor_dir(dyn_p.num_act_mats_hor_dir),
!   delay_writeback(0), cell(subarray.cell), is_dram(dyn_p.is_dram),
    num_mats(dp.num_mats),
    power_sa(), delay_sa(0),
    leak_power_sense_amps_closed_page_state(0),
    leak_power_sense_amps_open_page_state(0),
    delay_subarray_out_drv(0), 
!   delay_comparator(0), power_comparator(), num_do_b_mat(dyn_p.num_do_b_mat),
    num_subarrays_per_mat(dp.num_subarrays/dp.num_mats),
!   num_subarrays_per_row(dp.Ndwl/dp.num_mats_h_dir)
  {
    assert(num_subarrays_per_mat <= 4);
    assert(num_subarrays_per_row <= 2);
!   bool is_fa = (g_ip->fully_assoc) ? true : false;
  
    if (dp.use_inp_params == 1) {
      RWP = g_ip->num_rw_ports;
      ERP = g_ip->num_rd_ports;
      EWP = g_ip->num_wr_ports;
    }
    else {
      RWP = g_ip->num_rw_ports;
      ERP = g_ip->num_rd_ports;
      EWP = g_ip->num_wr_ports;
    }
  
!   double number_sa_subarray        = subarray.num_cols / deg_bl_muxing;
!   int    num_dec_signals           = (is_fa) ? 1 : subarray.num_rows;
    double C_ld_bit_mux_dec_out      = 0;
    double C_ld_sa_mux_lev_1_dec_out = 0;
    double C_ld_sa_mux_lev_2_dec_out = 0;
!   double R_wire_wl_drv_out      = subarray.num_cols * cell.w * g_tp.wire_local.R_per_um;
    double R_wire_bit_mux_dec_out = num_subarrays_per_row * subarray.num_cols * g_tp.wire_inside_mat.R_per_um * cell.w;
    double R_wire_sa_mux_dec_out  = num_subarrays_per_row * subarray.num_cols * g_tp.wire_inside_mat.R_per_um * cell.w;
  
--- 46,134 ----
  Mat::Mat(const DynamicParameter & dyn_p)
   :dp(dyn_p),
    power_subarray_out_drv(),
!   delay_fa_decoder(0), delay_cam(0),
!   delay_before_decoder(0), delay_bitline(0),
    delay_wl_reset(0), delay_bl_restore(0),
+   delay_searchline(0), delay_matchchline(0),
+   delay_cam_sl_restore(0), delay_cam_ml_reset(0),
+   delay_fa_ram_wl(0),delay_hit_miss_reset(0),
+   delay_hit_miss(0),
    subarray(dp, g_ip->fully_assoc),
    power_bitline(), per_bitline_read_energy(0),
    deg_bl_muxing(dp.deg_bl_muxing), 
    num_act_mats_hor_dir(dyn_p.num_act_mats_hor_dir),
!   delay_writeback(0),
!   cell(subarray.cell), cam_cell(subarray.cam_cell),
!   is_dram(dyn_p.is_dram),
!   pure_cam(dyn_p.pure_cam),
    num_mats(dp.num_mats),
    power_sa(), delay_sa(0),
    leak_power_sense_amps_closed_page_state(0),
    leak_power_sense_amps_open_page_state(0),
    delay_subarray_out_drv(0), 
!   delay_comparator(0), power_comparator(),
!   num_do_b_mat(dyn_p.num_do_b_mat), num_so_b_mat(dyn_p.num_so_b_mat),
    num_subarrays_per_mat(dp.num_subarrays/dp.num_mats),
!   num_subarrays_per_row(dp.Ndwl/dp.num_mats_h_dir),
!   array_leakage(0),
!   wl_leakage(0),
!   cl_leakage(0)
  {
    assert(num_subarrays_per_mat <= 4);
    assert(num_subarrays_per_row <= 2);
!   is_fa = (g_ip->fully_assoc) ? true : false;
!   camFlag = (is_fa || pure_cam);//although cam_cell.w = cell.w for fa, we still differentiate them.
! 
!   if (is_fa || pure_cam)
! 	  num_subarrays_per_row = num_subarrays_per_mat>2?num_subarrays_per_mat/2:num_subarrays_per_mat;
  
    if (dp.use_inp_params == 1) {
      RWP = g_ip->num_rw_ports;
      ERP = g_ip->num_rd_ports;
      EWP = g_ip->num_wr_ports;
+     SCHP = g_ip->num_search_ports;
    }
    else {
      RWP = g_ip->num_rw_ports;
      ERP = g_ip->num_rd_ports;
      EWP = g_ip->num_wr_ports;
+     SCHP = g_ip->num_search_ports;
+   }
+ 
+   double number_sa_subarray;	//        = subarray.num_cols / deg_bl_muxing;
+   if (!is_fa && !pure_cam)
+   {
+ 	  number_sa_subarray = subarray.num_cols / deg_bl_muxing;
+   }
+   else if (is_fa && !pure_cam)
+   {
+ 	  number_sa_subarray =  (subarray.num_cols_fa_cam + subarray.num_cols_fa_ram) / deg_bl_muxing;
+   }
+ 
+   else
+   {
+ 	  number_sa_subarray =  (subarray.num_cols_fa_cam) / deg_bl_muxing;
    }
  
!   int    num_dec_signals           = subarray.num_rows;	//(is_fa) ? 1 : subarray.num_rows;
    double C_ld_bit_mux_dec_out      = 0;
    double C_ld_sa_mux_lev_1_dec_out = 0;
    double C_ld_sa_mux_lev_2_dec_out = 0;
!   double R_wire_wl_drv_out;	//      = subarray.num_cols * cell.w * g_tp.wire_local.R_per_um;
! 
!   if (!is_fa && !pure_cam)
! 	{
! 		R_wire_wl_drv_out = subarray.num_cols * cell.w * g_tp.wire_local.R_per_um;
! 	}
! 	else if (is_fa && !pure_cam)
! 	{
! 		R_wire_wl_drv_out = (subarray.num_cols_fa_cam * cam_cell.w + subarray.num_cols_fa_ram * cell.w) * g_tp.wire_local.R_per_um ;
! 	}
! 	else
! 	{
! 		R_wire_wl_drv_out = (subarray.num_cols_fa_cam * cam_cell.w ) * g_tp.wire_local.R_per_um;
! 	}
! 
    double R_wire_bit_mux_dec_out = num_subarrays_per_row * subarray.num_cols * g_tp.wire_inside_mat.R_per_um * cell.w;
    double R_wire_sa_mux_dec_out  = num_subarrays_per_row * subarray.num_cols * g_tp.wire_inside_mat.R_per_um * cell.w;
  
***************
*** 117,177 ****
        num_dec_signals,
        false,
        subarray.C_wl,
!       subarray.C_rwl, // Alireza: for 8T SRAM cell
        R_wire_wl_drv_out,
        is_fa,
        is_dram,
        true,
!       cell);
!   if (is_fa && (!dp.is_tag))
    {
      row_dec->exist = true;
    }
    bit_mux_dec = new Decoder(
        deg_bl_muxing,
        false,
        C_ld_bit_mux_dec_out,
!       0, // Alireza
        R_wire_bit_mux_dec_out,
        is_fa,
        is_dram,
        false,
!       cell);
    sa_mux_lev_1_dec = new Decoder(
        dp.deg_senseamp_muxing_non_associativity,
        dp.number_way_select_signals_mat ? true : false,
        C_ld_sa_mux_lev_1_dec_out,
!       0, // Alireza
        R_wire_sa_mux_dec_out,
        is_fa,
        is_dram,
        false,
!       cell);
    sa_mux_lev_2_dec = new Decoder(
        dp.Ndsam_lev_2,
        false,
        C_ld_sa_mux_lev_2_dec_out,
!       0, // Alireza
        R_wire_sa_mux_dec_out,
        is_fa,
        is_dram,
        false,
!       cell);
  
    PredecBlk * r_predec_blk1 = new PredecBlk(
        num_dec_signals,
        row_dec,
!       num_subarrays_per_row * subarray.num_rows * g_tp.wire_inside_mat.C_per_um * cell.h,
!       subarray.num_rows * g_tp.wire_inside_mat.R_per_um * cell.h,
!       num_subarrays_per_mat,
        is_dram,
        true);
    PredecBlk * r_predec_blk2 = new PredecBlk(
        num_dec_signals,
        row_dec,
!       num_subarrays_per_row * subarray.num_rows * g_tp.wire_inside_mat.C_per_um * cell.h,
!       subarray.num_rows * g_tp.wire_inside_mat.R_per_um * cell.h,
!       num_subarrays_per_mat,
        is_dram,
        false);
    PredecBlk * b_mux_predec_blk1 = new PredecBlk(deg_bl_muxing, bit_mux_dec, 0, 0, 1, is_dram, true);
--- 163,250 ----
        num_dec_signals,
        false,
        subarray.C_wl,
! //      subarray.C_rwl, // Alireza: for 8T SRAM cell
        R_wire_wl_drv_out,
        is_fa,
        is_dram,
        true,
! 	  camFlag? cam_cell:cell);
! 
! /*  if (is_fa && (!dp.is_tag))
    {
      row_dec->exist = true;
    }
+ */
    bit_mux_dec = new Decoder(
        deg_bl_muxing,
        false,
        C_ld_bit_mux_dec_out,
!  //     0, // Alireza
        R_wire_bit_mux_dec_out,
        is_fa,
        is_dram,
        false,
! 	  camFlag? cam_cell:cell);
! 
    sa_mux_lev_1_dec = new Decoder(
        dp.deg_senseamp_muxing_non_associativity,
        dp.number_way_select_signals_mat ? true : false,
        C_ld_sa_mux_lev_1_dec_out,
! //      0, // Alireza
        R_wire_sa_mux_dec_out,
        is_fa,
        is_dram,
        false,
! 	  camFlag? cam_cell:cell);
    sa_mux_lev_2_dec = new Decoder(
        dp.Ndsam_lev_2,
        false,
        C_ld_sa_mux_lev_2_dec_out,
!  //     0, // Alireza
        R_wire_sa_mux_dec_out,
        is_fa,
        is_dram,
        false,
! 	  camFlag? cam_cell:cell);
! //divya added begin 10-11-2021
!   double C_wire_predec_blk_out;
!   double R_wire_predec_blk_out;
! 
!   if (!is_fa && !pure_cam)
!   {
! 	  C_wire_predec_blk_out  = num_subarrays_per_row * subarray.num_rows * g_tp.wire_inside_mat.C_per_um * cell.h;
! 	  R_wire_predec_blk_out  = num_subarrays_per_row * subarray.num_rows * g_tp.wire_inside_mat.R_per_um * cell.h;
! 	  //subarray.num_rows * g_tp.wire_inside_mat.R_per_um * cell.h, -> earlier R didnt include num_subarrays_per_row,
! 	  //MCPAT-CACTI and CACTI7 included it, this may cause change in results. check.
!   }
!   else //for pre-decode block's load is same for both FA and CAM
!   {
! 	  C_wire_predec_blk_out  = subarray.num_rows * g_tp.wire_inside_mat.C_per_um * cam_cell.h;
! 	  R_wire_predec_blk_out  = subarray.num_rows * g_tp.wire_inside_mat.R_per_um * cam_cell.h;
!    }
! 
!   if (is_fa||pure_cam)
! 	  num_dec_signals += _log2(num_subarrays_per_mat);
! //divya end
  
    PredecBlk * r_predec_blk1 = new PredecBlk(
        num_dec_signals,
        row_dec,
! //     num_subarrays_per_row * subarray.num_rows * g_tp.wire_inside_mat.C_per_um * cell.h,
! //      subarray.num_rows * g_tp.wire_inside_mat.R_per_um * cell.h,
! 	  C_wire_predec_blk_out,
! 	  R_wire_predec_blk_out,
! 	  num_subarrays_per_mat,
        is_dram,
        true);
    PredecBlk * r_predec_blk2 = new PredecBlk(
        num_dec_signals,
        row_dec,
! //      num_subarrays_per_row * subarray.num_rows * g_tp.wire_inside_mat.C_per_um * cell.h,
! //      subarray.num_rows * g_tp.wire_inside_mat.R_per_um * cell.h,
! 	  C_wire_predec_blk_out,
! 	  R_wire_predec_blk_out,
! 	  num_subarrays_per_mat,
        is_dram,
        false);
    PredecBlk * b_mux_predec_blk1 = new PredecBlk(deg_bl_muxing, bit_mux_dec, 0, 0, 1, is_dram, true);
***************
*** 200,210 ****
    sa_mux_lev_2_predec = new Predec(sa_mux_lev_2_predec_blk_drv1, sa_mux_lev_2_predec_blk_drv2);
  
    subarray_out_wire   = new Wire(g_ip->wt, subarray.area.h);
!   bl_precharge_eq_drv = new Driver(
        subarray.num_cols * gate_C(2 * g_tp.w_pmos_bl_precharge + g_tp.w_pmos_bl_eq, 0, is_dram, false, false),
        subarray.num_cols * cell.w * g_tp.wire_outside_mat.C_per_um,
        subarray.num_cols * cell.w * g_tp.wire_outside_mat.R_per_um,
        is_dram);
  
    double area_row_decoder = row_dec->area.get_area() * subarray.num_rows * (RWP + ERP + EWP);
    double w_row_decoder    = area_row_decoder / subarray.area.get_h();
--- 273,326 ----
    sa_mux_lev_2_predec = new Predec(sa_mux_lev_2_predec_blk_drv1, sa_mux_lev_2_predec_blk_drv2);
  
    subarray_out_wire   = new Wire(g_ip->wt, subarray.area.h);
! //  cout << "g_ip->wt : " << g_ip->wt << ", subarray.h : "<< subarray.area.h << endl;
! 
! /*  bl_precharge_eq_drv = new Driver(
        subarray.num_cols * gate_C(2 * g_tp.w_pmos_bl_precharge + g_tp.w_pmos_bl_eq, 0, is_dram, false, false),
        subarray.num_cols * cell.w * g_tp.wire_outside_mat.C_per_um,
        subarray.num_cols * cell.w * g_tp.wire_outside_mat.R_per_um,
        is_dram);
+ */
+   double driver_c_gate_load;
+   double driver_c_wire_load;
+   double driver_r_wire_load;
+ 
+   if (is_fa || pure_cam)
+   {   //Although CAM and RAM use different bl pre-charge driver, assuming the precharge p size is the same
+ 	  driver_c_gate_load =  (subarray.num_cols_fa_cam )* gate_C(2 * g_tp.w_pmos_bl_precharge + g_tp.w_pmos_bl_eq, 0, is_dram, false, false);
+ 	  driver_c_wire_load =  subarray.num_cols_fa_cam * cam_cell.w * g_tp.wire_outside_mat.C_per_um;
+ 	  driver_r_wire_load =  subarray.num_cols_fa_cam * cam_cell.w * g_tp.wire_outside_mat.R_per_um;
+ 	  cam_bl_precharge_eq_drv = new Driver(
+ 			  driver_c_gate_load,
+ 			  driver_c_wire_load,
+ 			  driver_r_wire_load,
+ 			  is_dram);
+ 
+ 	  if (!pure_cam)
+ 	  {
+ 		  //This is only used for fully assoc not pure CAM
+ 		  driver_c_gate_load =  (subarray.num_cols_fa_ram )* gate_C(2 * g_tp.w_pmos_bl_precharge + g_tp.w_pmos_bl_eq, 0, is_dram, false, false);
+ 		  driver_c_wire_load =  subarray.num_cols_fa_ram * cell.w * g_tp.wire_outside_mat.C_per_um;
+ 		  driver_r_wire_load =  subarray.num_cols_fa_ram * cell.w * g_tp.wire_outside_mat.R_per_um;
+ 		  bl_precharge_eq_drv = new Driver(
+ 				  driver_c_gate_load,
+ 				  driver_c_wire_load,
+ 				  driver_r_wire_load,
+ 				  is_dram);
+ 	  }
+   }
+ 
+   else
+   {
+ 	  driver_c_gate_load =  subarray.num_cols * gate_C(2 * g_tp.w_pmos_bl_precharge + g_tp.w_pmos_bl_eq, 0, is_dram, false, false);
+ 	  driver_c_wire_load =  subarray.num_cols * cell.w * g_tp.wire_outside_mat.C_per_um;
+ 	  driver_r_wire_load =  subarray.num_cols * cell.w * g_tp.wire_outside_mat.R_per_um;
+ 	  bl_precharge_eq_drv = new Driver(
+ 			  driver_c_gate_load,
+ 			  driver_c_wire_load,
+ 			  driver_r_wire_load,
+ 			  is_dram);
+   }
  
    double area_row_decoder = row_dec->area.get_area() * subarray.num_rows * (RWP + ERP + EWP);
    double w_row_decoder    = area_row_decoder / subarray.area.get_h();
***************
*** 214,220 ****
  
    double h_subarray_out_drv = subarray_out_wire->area.get_area() *
      (subarray.num_cols / (deg_bl_muxing * dp.Ndsam_lev_1 * dp.Ndsam_lev_2)) / subarray.area.get_w();
! 
    if (!(is_fa && dp.is_tag))
    {
      h_subarray_out_drv *= (RWP + ERP);
--- 330,341 ----
  
    double h_subarray_out_drv = subarray_out_wire->area.get_area() *
      (subarray.num_cols / (deg_bl_muxing * dp.Ndsam_lev_1 * dp.Ndsam_lev_2)) / subarray.area.get_w();
! /*
!   cout << "subarray_out_wire->area.get_area(): " << subarray_out_wire->area.get_area() <<
! 		  ", subarray.num_cols: " << subarray.num_cols <<
! 		  ", subarray.area.get_w(): " << subarray.area.get_w() << endl;
! */
! /*
    if (!(is_fa && dp.is_tag))
    {
      h_subarray_out_drv *= (RWP + ERP);
***************
*** 223,228 ****
--- 344,351 ----
    {
      h_subarray_out_drv  = 0;
    }
+ */
+   h_subarray_out_drv *= (RWP + ERP + SCHP);
  
    double h_comparators                = 0.0;
    double w_row_predecode_output_wires = 0.0;
***************
*** 236,254 ****
      h_comparators *= (RWP + ERP);
    }
  
!   if (!is_fa)
!   {
      int branch_effort_predec_blk1_out = (1 << r_predec_blk2->number_input_addr_bits);
      int branch_effort_predec_blk2_out = (1 << r_predec_blk1->number_input_addr_bits);
      w_row_predecode_output_wires   = (branch_effort_predec_blk1_out + branch_effort_predec_blk2_out) *
        g_tp.wire_inside_mat.pitch * (RWP + ERP + EWP);
!   }
  
    double h_non_cell_area = (num_subarrays_per_mat / num_subarrays_per_row) *
                             (h_bit_mux_sense_amp_precharge_sa_mux_write_driver_write_mux +
                              h_subarray_out_drv + h_comparators);
    double w_non_cell_area = MAX(w_row_predecode_output_wires, num_subarrays_per_row * w_row_decoder);
! 
    if (deg_bl_muxing > 1)
    {
      h_bit_mux_dec_out_wires = deg_bl_muxing * g_tp.wire_inside_mat.pitch * (RWP + ERP);
--- 359,388 ----
      h_comparators *= (RWP + ERP);
    }
  
! //  if (!is_fa)
! //  {
      int branch_effort_predec_blk1_out = (1 << r_predec_blk2->number_input_addr_bits);
      int branch_effort_predec_blk2_out = (1 << r_predec_blk1->number_input_addr_bits);
      w_row_predecode_output_wires   = (branch_effort_predec_blk1_out + branch_effort_predec_blk2_out) *
        g_tp.wire_inside_mat.pitch * (RWP + ERP + EWP);
! //  }
  
    double h_non_cell_area = (num_subarrays_per_mat / num_subarrays_per_row) *
                             (h_bit_mux_sense_amp_precharge_sa_mux_write_driver_write_mux +
                              h_subarray_out_drv + h_comparators);
    double w_non_cell_area = MAX(w_row_predecode_output_wires, num_subarrays_per_row * w_row_decoder);
! /*
!   cout << "\n h_bit_mux_sense_amp_precharge_sa_mux_write_driver_write_mux: " << h_bit_mux_sense_amp_precharge_sa_mux_write_driver_write_mux <<
!   		", h_comparators: " << h_comparators <<
! 			", h_subarray_out_drv: " << h_subarray_out_drv << endl;
! 
!   cout << "w_row_predecode_output_wires: " << w_row_predecode_output_wires <<
! 		  "\n ,w_row_decoder: " << w_row_decoder <<
! 		  "\n ,row_dec->area.get_area(): " << row_dec->area.get_area() <<
! 		  "\n ,branch_effort_predec_blk1_out: " << branch_effort_predec_blk1_out <<
! 		  "\n, branch_effort_predec_blk2_out: " << branch_effort_predec_blk2_out <<
! 		  "\n ,g_tp.wire_inside_mat.pitch: " << g_tp.wire_inside_mat.pitch << endl;
! */
    if (deg_bl_muxing > 1)
    {
      h_bit_mux_dec_out_wires = deg_bl_muxing * g_tp.wire_inside_mat.pitch * (RWP + ERP);
***************
*** 261,272 ****
    {
      h_senseamp_mux_dec_out_wires += dp.Ndsam_lev_2 * g_tp.wire_inside_mat.pitch * (RWP + ERP);
    }
! 
    if (!g_ip->ver_htree_wires_over_array)
    {
!     double h_addr_datain_wires = (dp.number_addr_bits_mat + dp.number_way_select_signals_mat +
                                    (dp.num_di_b_mat + dp.num_do_b_mat)/num_subarrays_per_row) *
                                   g_tp.wire_inside_mat.pitch * (RWP + ERP + EWP);
      //h_non_cell_area = 2 * h_bit_mux_sense_amp_precharge_sa_mux +
      //MAX(h_addr_datain_wires, 2 * h_subarray_out_drv);
      h_non_cell_area = (h_bit_mux_sense_amp_precharge_sa_mux_write_driver_write_mux + h_comparators +
--- 395,415 ----
    {
      h_senseamp_mux_dec_out_wires += dp.Ndsam_lev_2 * g_tp.wire_inside_mat.pitch * (RWP + ERP);
    }
!   double h_addr_datain_wires;
! //  cout << "g_ip->ver_htree_wires_over_array: " << g_ip->ver_htree_wires_over_array << endl;
    if (!g_ip->ver_htree_wires_over_array)
    {
!     h_addr_datain_wires = (dp.number_addr_bits_mat + dp.number_way_select_signals_mat +
                                    (dp.num_di_b_mat + dp.num_do_b_mat)/num_subarrays_per_row) *
                                   g_tp.wire_inside_mat.pitch * (RWP + ERP + EWP);
+ 
+     if (is_fa || pure_cam)
+     {
+     	h_addr_datain_wires = (dp.number_addr_bits_mat + dp.number_way_select_signals_mat +     //TODO: revisit
+     			              (dp.num_di_b_mat+ dp.num_do_b_mat )/num_subarrays_per_row) *
+     			               g_tp.wire_inside_mat.pitch * (RWP + ERP + EWP) +
+     			               (dp.num_si_b_mat + dp.num_so_b_mat )/num_subarrays_per_row * g_tp.wire_inside_mat.pitch * SCHP;
+     }
      //h_non_cell_area = 2 * h_bit_mux_sense_amp_precharge_sa_mux +
      //MAX(h_addr_datain_wires, 2 * h_subarray_out_drv);
      h_non_cell_area = (h_bit_mux_sense_amp_precharge_sa_mux_write_driver_write_mux + h_comparators +
***************
*** 274,279 ****
--- 417,429 ----
                        h_addr_datain_wires +
                        h_bit_mux_dec_out_wires +
                        h_senseamp_mux_dec_out_wires;
+ /*    cout << "\n h_bit_mux_sense_amp_precharge_sa_mux_write_driver_write_mux: " << h_bit_mux_sense_amp_precharge_sa_mux_write_driver_write_mux <<
+     		", h_comparators: " << h_comparators <<
+ 			", h_subarray_out_drv: " << h_subarray_out_drv <<
+     		", h_addr_datain_wires: " << h_addr_datain_wires <<
+     		", h_bit_mux_dec_out_wires : " << h_bit_mux_dec_out_wires <<
+     		", h_senseamp_mux_dec_out_wires : " << h_senseamp_mux_dec_out_wires << endl;
+ */
    }
  
    // double area_rectangle_center_mat = h_non_cell_area * w_non_cell_area;
***************
*** 297,321 ****
                                        bit_mux_dec->area.get_area() +
                                        sa_mux_lev_1_dec->area.get_area() +
                                        sa_mux_lev_2_dec->area.get_area()) * (RWP + ERP + EWP);
  
    double area_efficiency_mat;
  
!   if (!is_fa) 
!   {
!     area.h = (num_subarrays_per_mat / num_subarrays_per_row) * subarray.area.get_h() + h_non_cell_area;
      area.w = num_subarrays_per_row * subarray.area.get_w() + w_non_cell_area;
      area.w = (area.h*area.w + area_mat_center_circuitry) / area.h;
      area_efficiency_mat = subarray.area.get_area() * num_subarrays_per_mat * 100.0 / area.get_area();
!   }
!   else
!   {
!     area.h = (num_subarrays_per_mat / num_subarrays_per_row) * subarray.area.get_h() + h_non_cell_area;
!     area.w = subarray.area.get_w() + w_non_cell_area;
!     area.w = (area.h*area.w + area_mat_center_circuitry) / area.h;
!     area_efficiency_mat = subarray.area.get_area() * num_subarrays_per_row * 100.0 / area.get_area();
!   }
! }
  
  
  
  Mat::~Mat()
--- 447,512 ----
                                        bit_mux_dec->area.get_area() +
                                        sa_mux_lev_1_dec->area.get_area() +
                                        sa_mux_lev_2_dec->area.get_area()) * (RWP + ERP + EWP);
+ /*
+   cout << "r_predec_blk_drv1->area.get_area() : " << r_predec_blk_drv1->area.get_area() <<
+ 		  ", b_mux_predec_blk_drv1->area.get_area() : " << b_mux_predec_blk_drv1->area.get_area() <<
+ 		  ", sa_mux_lev_1_predec_blk_drv1->area.get_area() : " << sa_mux_lev_1_predec_blk_drv1->area.get_area() <<
+ 		  ", sa_mux_lev_2_predec_blk_drv1->area.get_area() : " << sa_mux_lev_2_predec_blk_drv1->area.get_area() <<
+ 		  ", way_sel_drv1->area.get_area() : " <<  way_sel_drv1->area.get_area() <<
+ 		  ", r_predec_blk_drv2->area.get_area() : " << r_predec_blk_drv2->area.get_area() <<
+ 		  ", b_mux_predec_blk_drv2->area.get_area() : " << b_mux_predec_blk_drv2->area.get_area() <<
+ 		  ", sa_mux_lev_1_predec_blk_drv2->area.get_area() : " << sa_mux_lev_1_predec_blk_drv2->area.get_area() <<
+ 		  ", sa_mux_lev_2_predec_blk_drv2->area.get_area() : "<< sa_mux_lev_2_predec_blk_drv2->area.get_area() <<
+ 		  ", r_predec_blk1->area.get_area() : " << r_predec_blk1->area.get_area() <<
+ 		  ", b_mux_predec_blk1->area.get_area() : " << b_mux_predec_blk1->area.get_area() <<
+ 		  ", sa_mux_lev_1_predec_blk1->area.get_area() : "<< sa_mux_lev_1_predec_blk1->area.get_area() <<
+ 		  ",  sa_mux_lev_2_predec_blk1->area.get_area() : "<<  sa_mux_lev_2_predec_blk1->area.get_area() <<
+ 		  ", r_predec_blk2->area.get_area() : "<< r_predec_blk2->area.get_area() <<
+ 		  ", b_mux_predec_blk2->area.get_area() : "<< b_mux_predec_blk2->area.get_area() <<
+ 		  ", sa_mux_lev_1_predec_blk2->area.get_area() : " << sa_mux_lev_1_predec_blk2->area.get_area() <<
+ 		  ", sa_mux_lev_2_predec_blk2->area.get_area() : "<< sa_mux_lev_2_predec_blk2->area.get_area() <<
+ 		  ", bit_mux_dec->area.get_area() : "<< bit_mux_dec->area.get_area() <<
+ 		  ", sa_mux_lev_1_dec->area.get_area() : "<< sa_mux_lev_1_dec->area.get_area() <<
+ 		  ", sa_mux_lev_2_dec->area.get_area() : "<< sa_mux_lev_2_dec->area.get_area() << endl;
+ */
  
    double area_efficiency_mat;
  
! //  if (!is_fa)
! //  {
!   assert(num_subarrays_per_mat/num_subarrays_per_row>0);
! 
! 	area.h = (num_subarrays_per_mat / num_subarrays_per_row) * subarray.area.get_h() + h_non_cell_area;
      area.w = num_subarrays_per_row * subarray.area.get_w() + w_non_cell_area;
+ //    cout << "area.h : " << area.h << ", area.w ; " << area.w << endl;
      area.w = (area.h*area.w + area_mat_center_circuitry) / area.h;
      area_efficiency_mat = subarray.area.get_area() * num_subarrays_per_mat * 100.0 / area.get_area();
! /*
!     cout << " num_subarrays_per_mat : " << num_subarrays_per_mat
!     		<< ", num_subarrays_per_row : " << num_subarrays_per_row <<
!     			  ", subarray.area.get_h() : " << subarray.area.get_h()
! 				  << ", h_non_cell_area : " << h_non_cell_area
! 				  << " mat.area.h : "<< area.h << endl;
!     cout << "num_subarrays_per_row : " << num_subarrays_per_row
!     		<< ", subarray.area.get_w() :" << subarray.area.get_w() <<
!     		", w_non_cell_area : " << w_non_cell_area
! 			<< " , area_mat_center_circuitry : " << area_mat_center_circuitry
! 			<< ", area.w : "<< area.w << endl;
! 
!     cout << " h_bit_mux_sense_amp_precharge_sa_mux_write_driver_write_mux : " << h_bit_mux_sense_amp_precharge_sa_mux_write_driver_write_mux <<
!     		", h_subarray_out_drv : " << h_subarray_out_drv << ", h_comparators : " << h_comparators <<
! 			",w_row_predecode_output_wires : " << w_row_predecode_output_wires << ", w_row_decoder : " << w_row_decoder << endl;
!     cout << "subarray_out_wire->area.get_area() : "<< subarray_out_wire->area.get_area() << ", subarray.num_cols : " << subarray.num_cols <<
!          ", deg_bl_muxing : " << deg_bl_muxing << ", dp.Ndsam_lev_1 : " << dp.Ndsam_lev_1 << ", dp.Ndsam_lev_2 : " << dp.Ndsam_lev_2 <<
! 		 ", subarray.area.get_w() : " << subarray.area.get_w() << endl;
! 
!     cout << "row_dec->area.get_area() : "<< row_dec->area.get_area() << ", subarray.num_rows : " << subarray.num_rows << endl;
! */
! //    cout << "area_mat_center_circuitry : " << area_mat_center_circuitry << endl << endl;
  
+     assert(area.h>0);
+     assert(area.w>0);
+ }
  
  
  Mat::~Mat()
***************
*** 353,375 ****
    delete sa_mux_lev_2_predec;
  
    delete subarray_out_wire;
!   delete bl_precharge_eq_drv;
! }
  
  
  
  double Mat::compute_delays(double inrisetime)
  {
!   bool is_fa = (g_ip->fully_assoc) ? true : false;
  
    // delay calculation for tags of fully associative cache
    if (is_fa && dp.is_tag)
    {
!     delay_fa_tag(
          dp.tagbits,
          dp.Ndbl,
          is_dram);
    }
    else
    {
      bl_precharge_eq_drv->compute_delay(0);
--- 544,634 ----
    delete sa_mux_lev_2_predec;
  
    delete subarray_out_wire;
!   if (!pure_cam)
!     delete bl_precharge_eq_drv;
  
+   if (is_fa || pure_cam)
+   {
+     delete sl_precharge_eq_drv ;
+     delete sl_data_drv ;
+     delete cam_bl_precharge_eq_drv;
+     delete ml_precharge_drv;
+     delete ml_to_ram_wl_drv;
+   }
+ }
  
  
  double Mat::compute_delays(double inrisetime)
  {
! /*  bool is_fa = (g_ip->fully_assoc) ? true : false;
  
    // delay calculation for tags of fully associative cache
    if (is_fa && dp.is_tag)
    {
!     delay_fa_tag1(
          dp.tagbits,
          dp.Ndbl,
          is_dram);
    }
+ */
+ 	int k;
+ 	double rd, C_intrinsic, C_ld, tf, R_bl_precharge,r_b_metal, R_bl, C_bl;
+ 	double outrisetime_search, outrisetime, row_dec_outrisetime;
+ 
+ 	//divya updated for FA and CAM acdng to MCPAT-CACTI 10-11-2021
+     // delay calculation for tags of fully associative cache
+ 	if (is_fa || pure_cam)
+ 	{
+ 		//Compute search access time
+ 		outrisetime_search = compute_cam_delay(inrisetime);
+ 		if (is_fa)
+ 		{
+ 			bl_precharge_eq_drv->compute_delay(0);
+ 			k = ml_to_ram_wl_drv->number_gates - 1;
+ 			rd = tr_R_on(ml_to_ram_wl_drv->width_n[k], NCH, 1, is_dram, false, true);
+ 			C_intrinsic = drain_C_(ml_to_ram_wl_drv->width_n[k], PCH, 1, 1, 4*cell.h, is_dram, false, true) +
+ 			drain_C_(ml_to_ram_wl_drv->width_n[k], NCH, 1, 1, 4*cell.h, is_dram, false, true);
+ 			C_ld = ml_to_ram_wl_drv->c_gate_load+ ml_to_ram_wl_drv->c_wire_load;
+ 			tf = rd * (C_intrinsic + C_ld) + ml_to_ram_wl_drv->r_wire_load * C_ld / 2;
+ 			delay_wl_reset = horowitz(0, tf, 0.5, 0.5, RISE);
+ 
+ 			R_bl_precharge = tr_R_on(g_tp.w_pmos_bl_precharge, PCH, 1, is_dram, false, false);
+ 			r_b_metal = cam_cell.h * g_tp.wire_local.R_per_um;//dummy rows in sram are filled in
+ 			R_bl = subarray.num_rows * r_b_metal;
+ 			C_bl = subarray.C_bl;
+ 			delay_bl_restore = bl_precharge_eq_drv->delay +
+ 			         log((g_tp.sram.Vbitpre - 0.1 * dp.V_b_sense) / (g_tp.sram.Vbitpre - dp.V_b_sense))*
+ 			         (R_bl_precharge * C_bl + R_bl * C_bl / 2);
+ 
+ 			outrisetime_search = compute_bitline_delay(outrisetime_search);
+ 			outrisetime_search = compute_sa_delay(outrisetime_search);
+ 		}
+ 			outrisetime_search = compute_subarray_out_drv(outrisetime_search);
+ 			subarray_out_wire->set_in_rise_time(outrisetime_search);
+ 			outrisetime_search = subarray_out_wire->signal_rise_time();
+ 			delay_subarray_out_drv_htree = delay_subarray_out_drv + subarray_out_wire->delay;
+ 
+ 			//TODO: this is just for compute plain read/write energy for fa and cam, plain read/write access timing need to be revisited.
+ 			outrisetime = r_predec->compute_delays(inrisetime);
+ 			row_dec_outrisetime = row_dec->compute_delays(outrisetime);
+ 
+ 			outrisetime = b_mux_predec->compute_delays(inrisetime);
+ 			bit_mux_dec->compute_delays(outrisetime);
+ 
+ 			outrisetime = sa_mux_lev_1_predec->compute_delays(inrisetime);
+ 			sa_mux_lev_1_dec->compute_delays(outrisetime);
+ 
+ 			outrisetime = sa_mux_lev_2_predec->compute_delays(inrisetime);
+ 			sa_mux_lev_2_dec->compute_delays(outrisetime);
+ 
+ 			if (pure_cam)
+ 			{
+ 			  outrisetime = compute_bitline_delay(row_dec_outrisetime);
+ 			  outrisetime = compute_sa_delay(outrisetime);
+ 			}
+ 			return outrisetime_search;
+     }
+ 
    else
    {
      bl_precharge_eq_drv->compute_delay(0);
***************
*** 383,388 ****
--- 642,656 ----
                             drain_C_(row_dec->w_dec_n[k], NCH, 1, 1, 4*cell.h, is_dram, false, true);
        double C_ld = row_dec->C_ld_dec_out;
        double tf = rd * (C_intrinsic + C_ld) + row_dec->R_wire_dec_out * C_ld / 2;
+ /*      cout << "C_intrinsic reduced reason : row_dec->w_dec_p[k] : " << row_dec->w_dec_p[k] <<
+     		  ", row_dec->w_dec_n[k] : " << row_dec->w_dec_n[k] << ", PCH : " << PCH << ", NCH :: " << NCH <<
+ 			  ", cell.h : " << cell.h << endl;
+ 
+       cout << "drain_C_(row_dec->w_dec_p[k], PCH, 1, 1, 4*cell.h, is_dram, false, true): " << drain_C_(row_dec->w_dec_p[k], PCH, 1, 1, 4*cell.h, is_dram, false, true) <<
+     		  ", drain_C_(row_dec->w_dec_n[k], NCH, 1, 1, 4*cell.h, is_dram, false, true): " << drain_C_(row_dec->w_dec_n[k], NCH, 1, 1, 4*cell.h, is_dram, false, true) << endl;
+       cout << "rd : " << rd << ", C_intrinsic : " << C_intrinsic << ", C_ld : " << C_ld << ", row_dec->R_wire_dec_out " << row_dec->R_wire_dec_out <<
+       " , tf " << tf << endl;
+ */
        delay_wl_reset = horowitz(0, tf, 0.5, 0.5, RISE);
      }
  
***************
*** 401,432 ****
          log((g_tp.sram.Vbitpre - 0.1 * dp.V_b_sense) / (g_tp.sram.Vbitpre - dp.V_b_sense))*
          (R_bl_precharge * C_bl + R_bl * C_bl / 2);
      }
    }
-   
-   double outrisetime;
-   double row_dec_outrisetime;
  
    outrisetime = r_predec->compute_delays(inrisetime);
    row_dec_outrisetime = row_dec->compute_delays(outrisetime);
  
    outrisetime = b_mux_predec->compute_delays(inrisetime);
    bit_mux_dec->compute_delays(outrisetime);
  
    outrisetime = sa_mux_lev_1_predec->compute_delays(inrisetime);
    sa_mux_lev_1_dec->compute_delays(outrisetime);
  
    outrisetime = sa_mux_lev_2_predec->compute_delays(inrisetime);
    sa_mux_lev_2_dec->compute_delays(outrisetime);
  
    outrisetime = compute_bitline_delay(row_dec_outrisetime);
    outrisetime = compute_sa_delay(outrisetime);
    outrisetime = compute_subarray_out_drv(outrisetime);
    subarray_out_wire->set_in_rise_time(outrisetime);
    outrisetime = subarray_out_wire->signal_rise_time();
  
    delay_subarray_out_drv_htree = delay_subarray_out_drv + subarray_out_wire->delay;
  
!   if (dp.is_tag == true && g_ip->fully_assoc == false)
    {
      compute_comparator_delay(0);
    }
--- 669,733 ----
          log((g_tp.sram.Vbitpre - 0.1 * dp.V_b_sense) / (g_tp.sram.Vbitpre - dp.V_b_sense))*
          (R_bl_precharge * C_bl + R_bl * C_bl / 2);
      }
+ /*    cout << " delay_bl_restore : " << delay_bl_restore << "bl_precharge_eq_drv->delay : " << bl_precharge_eq_drv->delay <<
+   		  	 ",  log((g_tp.sram.Vbitpre - 0.1 * dp.V_b_sense) / (g_tp.sram.Vbitpre - dp.V_b_sense)) : " <<  log((g_tp.sram.Vbitpre - 0.1 * dp.V_b_sense) / (g_tp.sram.Vbitpre - dp.V_b_sense)) <<
+   			 ", R_bl_precharge : " << R_bl_precharge << ", C_bl : " << C_bl << ", R_bl : " << R_bl << endl;
+ */
    }
  
    outrisetime = r_predec->compute_delays(inrisetime);
+ //  cout << "1 predecoder delay: " << r_predec->delay << endl;
+ 
    row_dec_outrisetime = row_dec->compute_delays(outrisetime);
+ //  cout << "2 row_dec outrise time : " << outrisetime <<
+ //		  ", row_dec_outrisetime : " << row_dec_outrisetime <<
+ //		  ", row_dec->delay : " << row_dec->delay << endl;
  
    outrisetime = b_mux_predec->compute_delays(inrisetime);
+  // cout << "3 b_mux_predec inrise time : " << inrisetime << " outrise time : " << outrisetime <<
+ //		  ", b_mux_predec->delay : " << b_mux_predec->delay << endl;
+ 
    bit_mux_dec->compute_delays(outrisetime);
+ //  cout << "4 bit_mux_dec outrise time : " << outrisetime <<
+ //		  ", bit_mux_dec->delay : " << bit_mux_dec->delay << endl;
  
    outrisetime = sa_mux_lev_1_predec->compute_delays(inrisetime);
+ //  cout << "5 sa_mux_lev_1_predec inrise time : " << inrisetime  << ", outrise time : " << outrisetime <<
+ //		  ", sa_mux_lev_1_predec->delay : " << sa_mux_lev_1_predec->delay << endl;
+ 
    sa_mux_lev_1_dec->compute_delays(outrisetime);
+ //  cout << "6 sa_mux_lev_1_dec outrise time : " << outrisetime <<
+ //		  ", sa_mux_lev_1_dec->delay : " << sa_mux_lev_1_dec->delay << endl;
  
    outrisetime = sa_mux_lev_2_predec->compute_delays(inrisetime);
+ //  cout << "7 sa_mux_lev_2_predec inrise time : " << inrisetime  << ", outrise time : " << outrisetime <<
+ //		  ", sa_mux_lev_2_predec->delay : " << sa_mux_lev_2_predec->delay << endl;
+ 
    sa_mux_lev_2_dec->compute_delays(outrisetime);
+ //  cout << "8 " << outrisetime <<
+ //		  ", sa_mux_lev_2_dec->delay : " << sa_mux_lev_2_dec->delay << endl;
  
    outrisetime = compute_bitline_delay(row_dec_outrisetime);
+ //  cout << "9 compute_bitline_delay outrise time : " << row_dec_outrisetime <<
+ //		  ", compute_bitline_delay->delay : " << outrisetime << endl;
+ 
    outrisetime = compute_sa_delay(outrisetime);
+ //  cout << "10 compute_sa_delay outrise time : " << outrisetime  << endl;
+ 
    outrisetime = compute_subarray_out_drv(outrisetime);
+ //  cout << "11 compute_subarray_out_drv outrise time : " << outrisetime << endl;
+ 
    subarray_out_wire->set_in_rise_time(outrisetime);
+ //  cout << "12 subarray_out_wire outrise time : " << outrisetime << endl;
+ 
    outrisetime = subarray_out_wire->signal_rise_time();
+ //  cout << "13 subarray_out_wire signal rise time : " << outrisetime << endl;
  
    delay_subarray_out_drv_htree = delay_subarray_out_drv + subarray_out_wire->delay;
+ //  cout << "14 delay_subarray_out_drv: " << delay_subarray_out_drv <<
+ //		  ", subarray_out_wire->delay: " << subarray_out_wire->delay << endl;
  
!   if (dp.is_tag == true && dp.fully_assoc == false)
    {
      compute_comparator_delay(0);
    }
***************
*** 443,466 ****
  
  double Mat::compute_bit_mux_sa_precharge_sa_mux_wr_drv_wr_mux_h()
  {
! 
!   double height = compute_tr_width_after_folding(g_tp.w_pmos_bl_precharge, cell.w / (2 *(RWP + ERP))) + 
!     compute_tr_width_after_folding(g_tp.w_pmos_bl_eq, cell.w / (RWP + ERP));  // precharge circuitry
! 
    if (deg_bl_muxing > 1)
    {
      height += compute_tr_width_after_folding(g_tp.w_nmos_b_mux, cell.w / (2 *(RWP + ERP)));  // col mux tr height
      // height += deg_bl_muxing * g_tp.wire_inside_mat.pitch * (RWP + ERP);  // bit mux dec out wires height
    }
  
    height += height_sense_amplifier(cell.w * deg_bl_muxing / (RWP + ERP));  // sense_amp_height
  
    if (dp.Ndsam_lev_1 > 1)
    {
      height += compute_tr_width_after_folding(
!         g_tp.w_nmos_sa_mux, cell.w * deg_bl_muxing / (RWP + ERP));  // sense_amp_mux_height
      //height_senseamp_mux_decode_output_wires =  Ndsam * wire_inside_mat_pitch * (RWP + ERP);
    }
  
    if (dp.Ndsam_lev_2 > 1)
    {
--- 744,771 ----
  
  double Mat::compute_bit_mux_sa_precharge_sa_mux_wr_drv_wr_mux_h()
  {
! //	cout << "sa err g_tp.w_pmos_bl_precharge: " << g_tp.w_pmos_bl_precharge << ", camflag: " << camFlag
! //			<< ", cell.w :" << cell.w << ", ports: " << 2*(RWP+ERP+SCHP)<<"\n";
!   double height = compute_tr_width_after_folding(g_tp.w_pmos_bl_precharge, camFlag? cam_cell.w:cell.w / (2 *(RWP + ERP + SCHP))) +
!     compute_tr_width_after_folding(g_tp.w_pmos_bl_eq, camFlag? cam_cell.w:cell.w / (RWP + ERP + SCHP));  // precharge circuitry
! //  cout << "err1 \n";
    if (deg_bl_muxing > 1)
    {
      height += compute_tr_width_after_folding(g_tp.w_nmos_b_mux, cell.w / (2 *(RWP + ERP)));  // col mux tr height
      // height += deg_bl_muxing * g_tp.wire_inside_mat.pitch * (RWP + ERP);  // bit mux dec out wires height
    }
+ //  cout << "err2 \n";
  
    height += height_sense_amplifier(cell.w * deg_bl_muxing / (RWP + ERP));  // sense_amp_height
+ //  cout << "err3 \n";
  
    if (dp.Ndsam_lev_1 > 1)
    {
      height += compute_tr_width_after_folding(
!         g_tp.w_nmos_sa_mux, cell.w * dp.Ndsam_lev_1 / (RWP + ERP));  // sense_amp_mux_height
      //height_senseamp_mux_decode_output_wires =  Ndsam * wire_inside_mat_pitch * (RWP + ERP);
    }
+ //  cout << "err4 \n";
  
    if (dp.Ndsam_lev_2 > 1)
    {
***************
*** 473,478 ****
--- 778,784 ----
          pmos_to_nmos_sz_ratio(is_dram) * g_tp.min_w_nmos_, cell.w * dp.Ndsam_lev_2 / (RWP + ERP));
      height += 2 * compute_tr_width_after_folding(g_tp.min_w_nmos_, cell.w * dp.Ndsam_lev_2 / (RWP + ERP));
    }
+ //  cout << "err5 \n";
  
    // TODO: this should be uncommented...
    /*if (deg_bl_muxing * dp.Ndsam_lev_1 * dp.Ndsam_lev_2 > 1)
***************
*** 491,497 ****
  
  
  
! void Mat::delay_fa_tag(
      int tagbits,
      int Ntbl,
      bool is_dram)
--- 797,803 ----
  
  
  
! void Mat::delay_fa_tag1(
      int tagbits,
      int Ntbl,
      bool is_dram)
***************
*** 604,610 ****
--- 910,1244 ----
    power_fa_decoder.readOp.dynamic = dynPower;
  }
  
+ //divya adding 10-11-2021 acdng to MCPAT-CACTI
+ double Mat::compute_cam_delay(double inrisetime)
+ {
+ 
+   double out_time_ramp, this_delay;
+   double Rwire, tf, c_intrinsic, rd, Cwire, c_gate_load;
+ 
+   double Wdecdrivep, Wdecdriven, Wfadriven, Wfadrivep, Wfadrive2n, Wfadrive2p, Wfadecdrive1n, Wfadecdrive1p,
+     Wfadecdrive2n, Wfadecdrive2p, Wfadecdriven, Wfadecdrivep, Wfaprechn, Wfaprechp,
+     Wdummyn, Wdummyinvn, Wdummyinvp, Wfainvn, Wfainvp, Waddrnandn, Waddrnandp,
+     Wfanandn, Wfanandp, Wfanorn, Wfanorp, Wdecnandn, Wdecnandp, W_hit_miss_n, W_hit_miss_p;
+ 
+   double c_matchline_metal, r_matchline_metal, c_searchline_metal, r_searchline_metal,  dynSearchEng;
+   int Htagbits;
+ 
+   double driver_c_gate_load;
+   double driver_c_wire_load;
+   double driver_r_wire_load;
+   //double searchline_precharge_time;
+ 
+   double leak_power_cc_inverters_sram_cell         = 0;
+   double leak_power_acc_tr_RW_or_WR_port_sram_cell = 0;
+   double leak_power_RD_port_sram_cell              = 0;
+   double leak_power_SCHP_port_sram_cell            = 0;
+   double leak_comparator_cam_cell                  =0;
+ 
+   double gate_leak_comparator_cam_cell          = 0;
+   double gate_leak_power_cc_inverters_sram_cell = 0;
+   double gate_leak_power_RD_port_sram_cell      = 0;
+   double gate_leak_power_SCHP_port_sram_cell    = 0;
+ 
+   c_matchline_metal   = cam_cell.get_w() * g_tp.wire_local.C_per_um;
+   c_searchline_metal  = cam_cell.get_h() * g_tp.wire_local.C_per_um;
+   r_matchline_metal   = cam_cell.get_w() * g_tp.wire_local.R_per_um;
+   r_searchline_metal  = cam_cell.get_h() * g_tp.wire_local.R_per_um;
+ 
+   dynSearchEng = 0.0;
+   delay_matchchline = 0.0;
+   double p_to_n_sizing_r = pmos_to_nmos_sz_ratio(is_dram);
+   bool linear_scaling = false;
+ 
+   if (linear_scaling)
+   {
+ 	  Wdecdrivep    =  450 * g_ip->F_sz_um;//this was 360 micron for the 0.8 micron process
+ 	  Wdecdriven    =  300 * g_ip->F_sz_um;//this was 240 micron for the 0.8 micron process
+ 	  Wfadriven     = 62.5 * g_ip->F_sz_um;//this was  50 micron for the 0.8 micron process
+ 	  Wfadrivep     =  125 * g_ip->F_sz_um;//this was 100 micron for the 0.8 micron process
+ 	  Wfadrive2n    =  250 * g_ip->F_sz_um;//this was 200 micron for the 0.8 micron process
+ 	  Wfadrive2p    =  500 * g_ip->F_sz_um;//this was 400 micron for the 0.8 micron process
+ 	  Wfadecdrive1n = 6.25 * g_ip->F_sz_um;//this was   5 micron for the 0.8 micron process
+ 	  Wfadecdrive1p = 12.5 * g_ip->F_sz_um;//this was  10 micron for the 0.8 micron process
+ 	  Wfadecdrive2n =   25 * g_ip->F_sz_um;//this was  20 micron for the 0.8 micron process
+ 	  Wfadecdrive2p =   50 * g_ip->F_sz_um;//this was  40 micron for the 0.8 micron process
+ 	  Wfadecdriven  = 62.5 * g_ip->F_sz_um;//this was  50 micron for the 0.8 micron process
+ 	  Wfadecdrivep  =  125 * g_ip->F_sz_um;//this was 100 micron for the 0.8 micron process
+ 	  Wfaprechn     =  7.5 * g_ip->F_sz_um;//this was   6 micron for the 0.8 micron process
+ 	  Wfainvn       = 12.5 * g_ip->F_sz_um;//this was  10 micron for the 0.8 micron process
+ 	  Wfainvp       =   25 * g_ip->F_sz_um;//this was  20 micron for the 0.8 micron process
+ 	  Wfanandn      =   25 * g_ip->F_sz_um;//this was  20 micron for the 0.8 micron process
+ 	  Wfanandp      = 37.5 * g_ip->F_sz_um;//this was  30 micron for the 0.8 micron process
+ 	  Wdecnandn     = 12.5 * g_ip->F_sz_um;//this was  10 micron for the 0.8 micron process
+ 	  Wdecnandp     = 37.5 * g_ip->F_sz_um;//this was  30 micron for the 0.8 micron process
+ 
+ 	  Wfaprechp     = 12.5 * g_ip->F_sz_um;//this was  10 micron for the 0.8 micron process
+ 	  Wdummyn       = 12.5 * g_ip->F_sz_um;//this was  10 micron for the 0.8 micron process
+ 	  Wdummyinvn    =   75 * g_ip->F_sz_um;//this was  60 micron for the 0.8 micron process
+ 	  Wdummyinvp    =  100 * g_ip->F_sz_um;//this was  80 micron for the 0.8 micron process
+ 	  Waddrnandn    = 62.5 * g_ip->F_sz_um;//this was  50 micron for the 0.8 micron process
+ 	  Waddrnandp    = 62.5 * g_ip->F_sz_um;//this was  50 micron for the 0.8 micron process
+ 	  Wfanorn       = 6.25 * g_ip->F_sz_um;//this was   5 micron for the 0.8 micron process
+ 	  Wfanorp       = 12.5 * g_ip->F_sz_um;//this was  10 micron for the 0.8 micron process
+ 	  W_hit_miss_n    = Wdummyn;
+ 	  W_hit_miss_p    = g_tp.min_w_nmos_*p_to_n_sizing_r;
+ 	  //TODO: this number should updated using new layout; from the NAND to output NOR should be computed using logical effort
+   }
+   else
+   {
+ 	  Wdecdrivep    =  450 * g_ip->F_sz_um;//this was 360 micron for the 0.8 micron process
+ 	  Wdecdriven    =  300 * g_ip->F_sz_um;//this was 240 micron for the 0.8 micron process
+ 	  Wfadriven     = 62.5 * g_ip->F_sz_um;//this was  50 micron for the 0.8 micron process
+ 	  Wfadrivep     =  125 * g_ip->F_sz_um;//this was 100 micron for the 0.8 micron process
+ 	  Wfadrive2n    =  250 * g_ip->F_sz_um;//this was 200 micron for the 0.8 micron process
+ 	  Wfadrive2p    =  500 * g_ip->F_sz_um;//this was 400 micron for the 0.8 micron process
+ 	  Wfadecdrive1n = 6.25 * g_ip->F_sz_um;//this was   5 micron for the 0.8 micron process
+ 	  Wfadecdrive1p = 12.5 * g_ip->F_sz_um;//this was  10 micron for the 0.8 micron process
+ 	  Wfadecdrive2n =   25 * g_ip->F_sz_um;//this was  20 micron for the 0.8 micron process
+ 	  Wfadecdrive2p =   50 * g_ip->F_sz_um;//this was  40 micron for the 0.8 micron process
+ 	  Wfadecdriven  = 62.5 * g_ip->F_sz_um;//this was  50 micron for the 0.8 micron process
+ 	  Wfadecdrivep  =  125 * g_ip->F_sz_um;//this was 100 micron for the 0.8 micron process
+ 	  Wfaprechn     =  7.5 * g_ip->F_sz_um;//this was   6 micron for the 0.8 micron process
+ 	  Wfainvn       = 12.5 * g_ip->F_sz_um;//this was  10 micron for the 0.8 micron process
+ 	  Wfainvp       =   25 * g_ip->F_sz_um;//this was  20 micron for the 0.8 micron process
+ 	  Wfanandn      =   25 * g_ip->F_sz_um;//this was  20 micron for the 0.8 micron process
+ 	  Wfanandp      = 37.5 * g_ip->F_sz_um;//this was  30 micron for the 0.8 micron process
+ 	  Wdecnandn     = 12.5 * g_ip->F_sz_um;//this was  10 micron for the 0.8 micron process
+ 	  Wdecnandp     = 37.5 * g_ip->F_sz_um;//this was  30 micron for the 0.8 micron process
+ 
+ 	  Wfaprechp     = g_tp.w_pmos_bl_precharge;//this was  10 micron for the 0.8 micron process
+ 	  Wdummyn       = g_tp.cam.cell_nmos_w;
+ 	  Wdummyinvn    =   75 * g_ip->F_sz_um;//this was  60 micron for the 0.8 micron process
+ 	  Wdummyinvp    =  100 * g_ip->F_sz_um;//this was  80 micron for the 0.8 micron process
+ 	  Waddrnandn    = 62.5 * g_ip->F_sz_um;//this was  50 micron for the 0.8 micron process
+ 	  Waddrnandp    = 62.5 * g_ip->F_sz_um;//this was  50 micron for the 0.8 micron process
+ 	  Wfanorn       = 6.25 * g_ip->F_sz_um;//this was   5 micron for the 0.8 micron process
+ 	  Wfanorp       = 12.5 * g_ip->F_sz_um;//this was  10 micron for the 0.8 micron process
+ 	  W_hit_miss_n    = Wdummyn;
+ 	  W_hit_miss_p    = g_tp.min_w_nmos_*p_to_n_sizing_r;
+   }
+   Htagbits = (int)(ceil ((double) (subarray.num_cols_fa_cam) / 2.0));
+ 
+   /* First stage, searchline is precharged. searchline data driver drives the searchline to open (if miss) the comparators.
+      search_line_delay, search_line_power, search_line_restore_delay for cycle time computation.
+      From the driver(am and an) to the comparators in all the rows including the dummy row,
+      Assuming that comparators in both the normal matching line and the dummy matching line have the same sizing */
+ 
+   //Searchline precharge circuitry is same as that of bitline. However, no sharing between search ports and r/w ports
+   //Searchline precharge routes horizontally
+   driver_c_gate_load = subarray.num_cols_fa_cam * gate_C(2 * g_tp.w_pmos_bl_precharge + g_tp.w_pmos_bl_eq, 0, is_dram, false, false);
+   driver_c_wire_load = subarray.num_cols_fa_cam * cam_cell.w * g_tp.wire_outside_mat.C_per_um;
+   driver_r_wire_load = subarray.num_cols_fa_cam * cam_cell.w * g_tp.wire_outside_mat.R_per_um;
+ 
+   sl_precharge_eq_drv = new Driver(
+       driver_c_gate_load,
+ 	  driver_c_wire_load,
+       driver_r_wire_load,
+       is_dram);
+   //searchline data driver ; subarray.num_rows + 1 is because of the dummy row
+   //data drv should only have gate_C not 2*gate_C since the two searchlines are differential--same as bitlines
+   driver_c_gate_load = (subarray.num_rows + 1) * gate_C(Wdummyn, 0, is_dram, false, false);
+   driver_c_wire_load = (subarray.num_rows + 1) * c_searchline_metal;
+   driver_r_wire_load = (subarray.num_rows + 1) * r_searchline_metal;
+   sl_data_drv = new Driver(
+       driver_c_gate_load,
+ 	  driver_c_wire_load,
+       driver_r_wire_load,
+       is_dram);
+ 
+   sl_precharge_eq_drv->compute_delay(0);
+   double R_bl_precharge = tr_R_on(g_tp.w_pmos_bl_precharge, PCH, 1, is_dram, false, false);//Assuming CAM and SRAM have same Pre_eq_dr
+   double r_b_metal = cam_cell.h * g_tp.wire_local.R_per_um;
+   double R_bl = (subarray.num_rows + 1) * r_b_metal;
+   double C_bl = subarray.C_bl_cam;
+   delay_cam_sl_restore = sl_precharge_eq_drv->delay
+                          + log(g_tp.cam.Vbitpre)* (R_bl_precharge * C_bl + R_bl * C_bl / 2);
+ 
+   out_time_ramp = sl_data_drv->compute_delay(inrisetime);//After entering one mat, start to consider the inrisetime from 0(0 is passed from outside)
+ 
+   //matchline ops delay
+   delay_matchchline += sl_data_drv->delay;
+ 
+   /* second stage, from the trasistors in the comparators(both normal row and dummy row) to the NAND gates that combins both half*/
+   //matchline delay, matchline power, matchline_reset for cycle time computation,
+ 
+   ////matchline precharge circuitry routes vertically
+   //There are two matchline precharge driver chains per subarray.
+   driver_c_gate_load = (subarray.num_rows + 1) * gate_C(Wfaprechp, 0, is_dram);
+   driver_c_wire_load = (subarray.num_rows + 1) * c_searchline_metal;
+   driver_r_wire_load = (subarray.num_rows + 1) * r_searchline_metal;
+ 
+   ml_precharge_drv = new Driver(
+ 						  driver_c_gate_load,
+   	                      driver_c_wire_load,
+                           driver_r_wire_load,
+                           is_dram);
+ 
+   ml_precharge_drv->compute_delay(0);
+ 
+ 
+   rd =  tr_R_on(Wdummyn, NCH, 2, is_dram);
+   c_intrinsic = Htagbits*(2*drain_C_(Wdummyn, NCH, 2, 1, g_tp.cell_h_def, is_dram)//TODO: the cell_h_def should be revisit
+ 				  + drain_C_(Wfaprechp, PCH, 1, 1, g_tp.cell_h_def, is_dram)/Htagbits);//since each halve only has one precharge tx per matchline
+ 
+   Cwire = c_matchline_metal * Htagbits;
+   Rwire = r_matchline_metal * Htagbits;
+   c_gate_load = gate_C(Waddrnandn + Waddrnandp, 0, is_dram);
+ 
+   double R_ml_precharge = tr_R_on(Wfaprechp, PCH, 1, is_dram);
+   //double r_ml_metal = cam_cell.w * g_tp.wire_local.R_per_um;
+   double R_ml = Rwire;
+   double C_ml = Cwire + c_intrinsic;
+   delay_cam_ml_reset = ml_precharge_drv->delay
+                            + log(g_tp.cam.Vbitpre)* (R_ml_precharge * C_ml + R_ml * C_ml / 2);//TODO: latest CAM has sense amps on matchlines too
+ 
+   //matchline ops delay
+   tf = rd * (c_intrinsic + Cwire / 2 + c_gate_load) + Rwire * (Cwire / 2 + c_gate_load);
+   this_delay = horowitz(out_time_ramp, tf, VTHFA2, VTHFA3, FALL);
+   delay_matchchline += this_delay;
+   out_time_ramp = this_delay / VTHFA3;
+ 
+   dynSearchEng += ((c_intrinsic + Cwire + c_gate_load)*(subarray.num_rows +1)) //+ 2*drain_C_(Wdummyn, NCH, 2, 1, g_tp.cell_h_def, is_dram))//TODO: need to be precise
+ 					  * g_tp.peri_global.Vdd * g_tp.peri_global.Vdd *2;//* Ntbl;//each subarry has two halves
+ 
+   /* third stage, from the NAND2 gates to the drivers in the dummy row */
+   rd = tr_R_on(Waddrnandn, NCH, 2, is_dram);
+   c_intrinsic = drain_C_(Waddrnandn, NCH, 2, 1, g_tp.cell_h_def, is_dram) +
+                 drain_C_(Waddrnandp, PCH, 1, 1, g_tp.cell_h_def, is_dram)*2;
+   c_gate_load = gate_C(Wdummyinvn + Wdummyinvp, 0, is_dram);
+   tf = rd * (c_intrinsic + c_gate_load);
+   this_delay = horowitz(out_time_ramp, tf, VTHFA3, VTHFA4, RISE);
+   out_time_ramp = this_delay / (1 - VTHFA4);
+   delay_matchchline += this_delay;
+ 
+   //only the dummy row has the extra inverter between NAND and NOR gates
+   dynSearchEng += (c_intrinsic* (subarray.num_rows+1)+ c_gate_load*2) * g_tp.peri_global.Vdd * g_tp.peri_global.Vdd;//  * Ntbl;
+ 
+   /* fourth stage, from the driver in dummy matchline to the NOR2 gate which drives the wordline of the data portion */
+   rd = tr_R_on(Wdummyinvn, NCH, 1, is_dram);
+   c_intrinsic = drain_C_(Wdummyinvn, NCH, 1, 1, g_tp.cell_h_def, is_dram) + drain_C_(Wdummyinvp, NCH, 1, 1, g_tp.cell_h_def, is_dram);
+   Cwire = c_matchline_metal * Htagbits +  c_searchline_metal * (subarray.num_rows+1)/2;
+   Rwire = r_matchline_metal * Htagbits +  r_searchline_metal * (subarray.num_rows+1)/2;
+   c_gate_load = gate_C(Wfanorn + Wfanorp, 0, is_dram);
+   tf = rd * (c_intrinsic + Cwire + c_gate_load) + Rwire * (Cwire / 2 + c_gate_load);
+   this_delay = horowitz (out_time_ramp, tf, VTHFA4, VTHFA5, FALL);
+   out_time_ramp = this_delay / VTHFA5;
+   delay_matchchline += this_delay;
+ 
+   dynSearchEng += (c_intrinsic + Cwire + subarray.num_rows*c_gate_load) * g_tp.peri_global.Vdd * g_tp.peri_global.Vdd;//* Ntbl;
+ 
+   /*final statge from the NOR gate to drive the wordline of the data portion */
+ 
+   //searchline data driver There are two matchline precharge driver chains per subarray.
+   driver_c_gate_load = gate_C(W_hit_miss_n, 0, is_dram, false, false);//nmos of the pull down logic
+   driver_c_wire_load = subarray.C_wl_ram;
+   driver_r_wire_load = subarray.R_wl_ram;
+ 
+   ml_to_ram_wl_drv = new Driver(
+ 						  driver_c_gate_load,
+   	                      driver_c_wire_load,
+                           driver_r_wire_load,
+                           is_dram);
+ 
+   rd = tr_R_on(Wfanorn, NCH, 1, is_dram);
+   c_intrinsic = 2* drain_C_(Wfanorn, NCH, 1, 1, g_tp.cell_h_def, is_dram) + drain_C_(Wfanorp, NCH, 1, 1, g_tp.cell_h_def, is_dram);
+   c_gate_load = gate_C(ml_to_ram_wl_drv->width_n[0] + ml_to_ram_wl_drv->width_p[0], 0, is_dram);
+   tf = rd * (c_intrinsic + c_gate_load);
+   this_delay = horowitz (out_time_ramp, tf, 0.5, 0.5, RISE);
+   out_time_ramp = this_delay / (1-0.5);
+   delay_matchchline += this_delay;
+ 
+   out_time_ramp   = ml_to_ram_wl_drv->compute_delay(out_time_ramp);
+ 
+   //c_gate_load energy is computed in ml_to_ram_wl_drv
+   dynSearchEng  += (c_intrinsic) * g_tp.peri_global.Vdd * g_tp.peri_global.Vdd;//* Ntbl;
+ 
+   /* peripheral-- hitting logic "CMOS VLSI Design Fig11.51*/
+   /*Precharge the hitting logic */
+   c_intrinsic = 2*drain_C_(W_hit_miss_p, NCH, 2, 1, g_tp.cell_h_def, is_dram);
+   Cwire = c_searchline_metal * subarray.num_rows;
+   Rwire = r_searchline_metal * subarray.num_rows;
+   c_gate_load = drain_C_(W_hit_miss_n, NCH, 1, 1, g_tp.cell_h_def, is_dram)* subarray.num_rows;
+ 
+   rd = tr_R_on(W_hit_miss_p, PCH, 1, is_dram, false, false);
+   //double r_ml_metal = cam_cell.w * g_tp.wire_local.R_per_um;
+   double R_hit_miss = Rwire;
+   double C_hit_miss = Cwire + c_intrinsic;
+   delay_hit_miss_reset = log(g_tp.cam.Vbitpre)* (rd * C_hit_miss + R_hit_miss * C_hit_miss / 2);
+   dynSearchEng  += (c_intrinsic + Cwire + c_gate_load) * g_tp.peri_global.Vdd * g_tp.peri_global.Vdd;
+ 
+   /*hitting logic evaluation */
+   c_intrinsic = 2*drain_C_(W_hit_miss_n, NCH, 2, 1, g_tp.cell_h_def, is_dram);
+   Cwire = c_searchline_metal * subarray.num_rows;
+   Rwire = r_searchline_metal * subarray.num_rows;
+   c_gate_load = drain_C_(W_hit_miss_n, NCH, 1, 1, g_tp.cell_h_def, is_dram)* subarray.num_rows;
+ 
+   rd = tr_R_on(W_hit_miss_n, PCH, 1, is_dram, false, false);
+   tf = rd * (c_intrinsic + Cwire / 2 + c_gate_load) + Rwire * (Cwire / 2 + c_gate_load);
+ 
+   delay_hit_miss = horowitz(0, tf, 0.5, 0.5, FALL);
+ 
+   if (is_fa)
+       delay_matchchline += MAX(ml_to_ram_wl_drv->delay, delay_hit_miss);
+ 
+   dynSearchEng  += (c_intrinsic + Cwire + c_gate_load) * g_tp.peri_global.Vdd * g_tp.peri_global.Vdd;
+ 
+   /* TODO: peripheral-- Priority Encoder, usually this is not necessary in processor components*/
+ 
+   power_matchline.searchOp.dynamic = dynSearchEng;
+ 
+   double Iport, Iport_erp, Icell;
+   double Icell_comparator = cmos_Isub_leakage(Wdummyn, Wdummyn, 1, inv, false, true)*2;//approx XOR with Inv
+ 
+   //leakage in one subarray
+   if(!g_ip->is_finfet) {
+ 	  Iport     = cmos_Isub_leakage(g_tp.cam.cell_a_w, 0,  1, nmos, false, true);//TODO: how much is the idle time? just by *2?
+ 	  Iport_erp = cmos_Isub_leakage(g_tp.cam.cell_a_w, 0,  2, nmos, false, true);
+ 	  Icell     = cmos_Isub_leakage(g_tp.cam.cell_nmos_w, g_tp.cam.cell_pmos_w, 1, inv, false, true)*2;
+ 	  Icell_comparator = cmos_Isub_leakage(Wdummyn, Wdummyn, 1, inv, false, true)*2;//approx XOR with Inv
+ 
+ 	  leak_power_cc_inverters_sram_cell         = Icell * g_tp.cam_cell.Vdd;
+ 		leak_comparator_cam_cell                  = Icell_comparator * g_tp.cam_cell.Vdd;
+ 		leak_power_acc_tr_RW_or_WR_port_sram_cell = Iport * g_tp.cam_cell.Vdd;
+ 		leak_power_RD_port_sram_cell              = Iport_erp * g_tp.cam_cell.Vdd;
+ 		leak_power_SCHP_port_sram_cell            = 0;//search port and r/w port are sperate, therefore no access txs in search ports
+   }
+ /* Divya 13-11-2021 : Including the leakage power equations used for sram. Else Pleak of cam is more than sram cache/fa cache
+ */
+   else {
+   leak_power_cc_inverters_sram_cell =
+ 		 g_ip->sram_cell_design.getPleakCCInv(g_tp.cam_cell.Vdd, g_tp.cam_cell.H_fin, g_tp.cam_cell.W_fin); //Divya changing this as W_fin != 2*H_fin and W_fin value is given
+   leak_power_acc_tr_RW_or_WR_port_sram_cell =
+       g_ip->sram_cell_design.getPleakAccTx(g_tp.cam_cell.Vdd, g_tp.cam_cell.H_fin, g_tp.cam_cell.W_fin);   //Divya changing this as W_fin != 2*H_fin and W_fin value is given
+   leak_power_RD_port_sram_cell =
+     leak_power_acc_tr_RW_or_WR_port_sram_cell * NAND2_LEAK_STACK_FACTOR;
+   }
+ 
+   leak_comparator_cam_cell                  = Icell_comparator * g_tp.cam_cell.Vdd;
+   leak_power_SCHP_port_sram_cell            = 0;//search port and r/w port are sperate, therefore no access txs in search ports
+ 
+   power_matchline.searchOp.leakage += leak_power_cc_inverters_sram_cell +
+     leak_comparator_cam_cell +
+     leak_power_acc_tr_RW_or_WR_port_sram_cell +
+     leak_power_acc_tr_RW_or_WR_port_sram_cell * (RWP + EWP - 1) +
+     leak_power_RD_port_sram_cell * ERP +
+     leak_power_SCHP_port_sram_cell*SCHP;
+ //  power_matchline.searchOp.leakage += leak_comparator_cam_cell;
+   power_matchline.searchOp.leakage *= (subarray.num_rows+1) * subarray.num_cols_fa_cam;//TODO:dumy line precise
+ //  power_matchline.searchOp.leakage += (subarray.num_rows+1) * cmos_Ileak(0, Wfaprechp) * g_tp.cam_cell.Vdd;	//cmos_Isub_leakage(0, Wfaprechp, 1, pmos) * g_tp.cam_cell.Vdd;
+ //  power_matchline.searchOp.leakage += (subarray.num_rows+1) * cmos_Ileak(Waddrnandn, Waddrnandp) * g_tp.cam_cell.Vdd;	//cmos_Isub_leakage(Waddrnandn, Waddrnandp, 2, nand) * g_tp.cam_cell.Vdd;
+ // power_matchline.searchOp.leakage += (subarray.num_rows+1) * cmos_Ileak(Wfanorn, Wfanorp) * g_tp.cam_cell.Vdd;	//cmos_Isub_leakage(Wfanorn, Wfanorp,2, nor) * g_tp.cam_cell.Vdd;
+   power_matchline.searchOp.leakage += (subarray.num_rows+1) * cmos_Isub_leakage(0, Wfaprechp, 1, pmos) * g_tp.cam_cell.Vdd;
+   power_matchline.searchOp.leakage += (subarray.num_rows+1) * cmos_Isub_leakage(Waddrnandn, Waddrnandp, 2, nand) * g_tp.cam_cell.Vdd;
+   power_matchline.searchOp.leakage += (subarray.num_rows+1) * cmos_Isub_leakage(Wfanorn, Wfanorp,2, nor) * g_tp.cam_cell.Vdd;
+ 
+   //In idle states, the hit/miss txs are closed (on) therefore no Isub
+   power_matchline.searchOp.leakage += 0;// subarray.num_rows * cmos_Isub_leakage(W_hit_miss_n, 0,1, nmos) * g_tp.cam_cell.Vdd+
+      // + cmos_Isub_leakage(0, W_hit_miss_p,1, pmos) * g_tp.cam_cell.Vdd;
  
+    return out_time_ramp;
+ }
  
  double Mat::width_write_driver_or_write_mux()
  {
***************
*** 635,644 ****
    double V_b_pre, v_th_mem_cell, V_wl;
    double tstep;
    double dynRdEnergy = 0.0, dynWriteEnergy = 0.0;
!   double R_cell_pull_down, R_cell_acc, r_dev;
    int deg_senseamp_muxing = dp.Ndsam_lev_1 * dp.Ndsam_lev_2;
  
!   double R_b_metal = cell.h * g_tp.wire_local.R_per_um;
    double R_bl      = subarray.num_rows * R_b_metal;
    double C_bl      = subarray.C_bl;
  
--- 1269,1279 ----
    double V_b_pre, v_th_mem_cell, V_wl;
    double tstep;
    double dynRdEnergy = 0.0, dynWriteEnergy = 0.0;
!   double blfloating_c =0.0;
!   double R_cell_pull_down=0.0, R_cell_acc =0.0, r_dev=0.0;
    int deg_senseamp_muxing = dp.Ndsam_lev_1 * dp.Ndsam_lev_2;
  
!   double R_b_metal = camFlag? cam_cell.h:cell.h * g_tp.wire_local.R_per_um;
    double R_bl      = subarray.num_rows * R_b_metal;
    double C_bl      = subarray.C_bl;
  
***************
*** 664,694 ****
      V_wl = g_tp.sram_cell.Vdd;
      R_cell_pull_down = tr_R_on(g_tp.sram.cell_nmos_w, NCH, 1, false, true);
      R_cell_acc = tr_R_on(g_tp.sram.cell_a_w, NCH, 1, false, true);
      //Leakage current of an SRAM cell
!     // Alireza - Begin
!     ///double Iport = cmos_Ileak(g_tp.sram.cell_a_w, 0,  false, true); 
!     ///double Icell = cmos_Ileak(g_tp.sram.cell_nmos_w, g_tp.sram.cell_pmos_w, false, true);
!     ///leak_power_cc_inverters_sram_cell = Icell * g_tp.sram_cell.Vdd;
!     ///leak_power_acc_tr_RW_or_WR_port_sram_cell = Iport * g_tp.sram_cell.Vdd;
!     leak_power_cc_inverters_sram_cell = 
!       g_ip->sram_cell_design.getPleakCCInv(g_tp.sram_cell.Vdd, g_tp.sram_cell.H_fin);
!     leak_power_acc_tr_RW_or_WR_port_sram_cell = 
!       g_ip->sram_cell_design.getPleakAccTx(g_tp.sram_cell.Vdd, g_tp.sram_cell.H_fin);
!     // Alireza - End
!     leak_power_RD_port_sram_cell = 
!       leak_power_acc_tr_RW_or_WR_port_sram_cell * NAND2_LEAK_STACK_FACTOR;
    }
! 
! 
!   double C_drain_bit_mux = drain_C_(g_tp.w_nmos_b_mux, NCH, 1, 0, cell.w / (2 *(RWP + ERP + RWP)), is_dram);
    double R_bit_mux = tr_R_on(g_tp.w_nmos_b_mux, NCH, 1, is_dram);
!   double C_drain_sense_amp_iso = drain_C_(g_tp.w_iso, PCH, 1, 0, cell.w * deg_bl_muxing / (RWP + ERP), is_dram);
    double R_sense_amp_iso = tr_R_on(g_tp.w_iso, PCH, 1, is_dram);
    double C_sense_amp_latch = gate_C(g_tp.w_sense_p + g_tp.w_sense_n, 0, is_dram) +
!     drain_C_(g_tp.w_sense_n, NCH, 1, 0, cell.w * deg_bl_muxing / (RWP + ERP), is_dram) + 
!     drain_C_(g_tp.w_sense_p, PCH, 1, 0, cell.w * deg_bl_muxing / (RWP + ERP), is_dram);
!   double C_drain_sense_amp_mux = drain_C_(g_tp.w_nmos_sa_mux, NCH, 1, 0, cell.w * deg_bl_muxing / (RWP + ERP), is_dram);
! 
    if (is_dram) 
    {
      double fraction = dp.V_b_sense / ((g_tp.dram_cell_Vdd/2) * g_tp.dram_cell_C /(g_tp.dram_cell_C + C_bl));
--- 1299,1345 ----
      V_wl = g_tp.sram_cell.Vdd;
      R_cell_pull_down = tr_R_on(g_tp.sram.cell_nmos_w, NCH, 1, false, true);
      R_cell_acc = tr_R_on(g_tp.sram.cell_a_w, NCH, 1, false, true);
+ 
      //Leakage current of an SRAM cell
!     if(!g_ip->is_finfet) {
!         double Iport     = cmos_Isub_leakage(g_tp.sram.cell_a_w, 0,  1, nmos,false, true);//TODO: how much is the idle time? just by *2?
!         double Iport_erp = cmos_Isub_leakage(g_tp.sram.cell_a_w, 0,  2, nmos,false, true);
!         double Icell     = cmos_Isub_leakage(g_tp.sram.cell_nmos_w, g_tp.sram.cell_pmos_w, 1, inv,false, true)*2;//two invs per cell
!         leak_power_cc_inverters_sram_cell = Icell * g_tp.sram_cell.Vdd;
!     	leak_power_acc_tr_RW_or_WR_port_sram_cell = Iport * g_tp.sram_cell.Vdd;
!         leak_power_RD_port_sram_cell              = Iport_erp *  g_tp.sram_cell.Vdd;
!     }
!     else{
! 		leak_power_cc_inverters_sram_cell =
! 			 g_ip->sram_cell_design.getPleakCCInv(g_tp.sram_cell.Vdd, g_tp.sram_cell.H_fin, g_tp.sram_cell.W_fin); //Divya changing this as W_fin != 2*H_fin and W_fin value is given
! 		leak_power_acc_tr_RW_or_WR_port_sram_cell =
! 			g_ip->sram_cell_design.getPleakAccTx(g_tp.sram_cell.Vdd, g_tp.sram_cell.H_fin, g_tp.sram_cell.W_fin);   //Divya changing this as W_fin != 2*H_fin and W_fin value is given
! 		leak_power_RD_port_sram_cell =
! 				leak_power_acc_tr_RW_or_WR_port_sram_cell * NAND2_LEAK_STACK_FACTOR;
!     }
    }
! /*
!   cout << "V-b-pre: " << V_b_pre << ", vth: " << v_th_mem_cell << ", v-wl: " << V_wl << ", vbsense: " << dp.V_b_sense
! 		  << ", R_cell_pd: " << R_cell_pull_down <<", rcell_acc: " << R_cell_acc
! 		  << ", leak_power_cc_inverters_sram_cell: " << leak_power_cc_inverters_sram_cell <<
! 		  ", leak_power_acc_tr_RW_or_WR_port_sram_cell: "<< leak_power_acc_tr_RW_or_WR_port_sram_cell
! 		  <<", leak_power_RD_port_sram_cell: " << leak_power_RD_port_sram_cell << endl;
!   cout << "g_tp.sram.cell_a_w: " << g_tp.sram.cell_a_w << ", g_tp.sram.cell_nmos_w: " << g_tp.sram.cell_nmos_w <<
! 		  ", g_tp.sram.cell_pmos_w: " << g_tp.sram.cell_pmos_w << endl;
! */
!   double C_drain_bit_mux = drain_C_(g_tp.w_nmos_b_mux, NCH, 1, 0, camFlag? cam_cell.w:cell.w / (2 *(RWP + ERP + SCHP)), is_dram);
    double R_bit_mux = tr_R_on(g_tp.w_nmos_b_mux, NCH, 1, is_dram);
!   double C_drain_sense_amp_iso = drain_C_(g_tp.w_iso, PCH, 1, 0, camFlag? cam_cell.w:cell.w * deg_bl_muxing / (RWP + ERP + SCHP), is_dram);
    double R_sense_amp_iso = tr_R_on(g_tp.w_iso, PCH, 1, is_dram);
    double C_sense_amp_latch = gate_C(g_tp.w_sense_p + g_tp.w_sense_n, 0, is_dram) +
!     drain_C_(g_tp.w_sense_n, NCH, 1, 0, camFlag? cam_cell.w:cell.w * deg_bl_muxing / (RWP + ERP + SCHP), is_dram) +
!     drain_C_(g_tp.w_sense_p, PCH, 1, 0, camFlag? cam_cell.w:cell.w * deg_bl_muxing / (RWP + ERP + SCHP), is_dram);
!   double C_drain_sense_amp_mux = drain_C_(g_tp.w_nmos_sa_mux, NCH, 1, 0, camFlag? cam_cell.w:cell.w * deg_bl_muxing / (RWP + ERP + SCHP), is_dram);
! /*
!   cout << "C_drain_bit_mux: " << C_drain_bit_mux << ", R_bit_mux: " << R_bit_mux << ", C_drain_sense_amp_iso: " << C_drain_sense_amp_iso <<
! 		  ", R_sense_amp_iso: " << R_sense_amp_iso <<", C_sense_amp_latch: "<< C_sense_amp_latch << ", C_drain_sense_amp_mux: "<< C_drain_sense_amp_mux
! 		  << endl;
!  */
    if (is_dram) 
    {
      double fraction = dp.V_b_sense / ((g_tp.dram_cell_Vdd/2) * g_tp.dram_cell_C /(g_tp.dram_cell_C + C_bl));
***************
*** 697,705 ****
        (g_tp.dram_cell_C + (C_bl + 2*C_drain_sense_amp_iso + C_sense_amp_latch + C_drain_sense_amp_mux));
      delay_writeback = tstep;
      dynRdEnergy += (C_bl + 2*C_drain_sense_amp_iso + C_sense_amp_latch + C_drain_sense_amp_mux) * 
!       (g_tp.dram_cell_Vdd / 2) * g_tp.dram_cell_Vdd * subarray.num_cols * num_subarrays_per_mat;
      dynWriteEnergy += (C_bl + 2*C_drain_sense_amp_iso + C_sense_amp_latch) * 
!       (g_tp.dram_cell_Vdd / 2) * g_tp.dram_cell_Vdd * subarray.num_cols * num_subarrays_per_mat * num_act_mats_hor_dir;
      per_bitline_read_energy = (C_bl + 2*C_drain_sense_amp_iso + C_sense_amp_latch + C_drain_sense_amp_mux) *
        (g_tp.dram_cell_Vdd / 2) * g_tp.dram_cell_Vdd;
    }
--- 1348,1356 ----
        (g_tp.dram_cell_C + (C_bl + 2*C_drain_sense_amp_iso + C_sense_amp_latch + C_drain_sense_amp_mux));
      delay_writeback = tstep;
      dynRdEnergy += (C_bl + 2*C_drain_sense_amp_iso + C_sense_amp_latch + C_drain_sense_amp_mux) * 
!       (g_tp.dram_cell_Vdd / 2) * g_tp.dram_cell_Vdd /* subarray.num_cols * num_subarrays_per_mat*/;
      dynWriteEnergy += (C_bl + 2*C_drain_sense_amp_iso + C_sense_amp_latch) * 
!       (g_tp.dram_cell_Vdd / 2) * g_tp.dram_cell_Vdd /* subarray.num_cols * num_subarrays_per_mat */ * num_act_mats_hor_dir*100;
      per_bitline_read_energy = (C_bl + 2*C_drain_sense_amp_iso + C_sense_amp_latch + C_drain_sense_amp_mux) *
        (g_tp.dram_cell_Vdd / 2) * g_tp.dram_cell_Vdd;
    }
***************
*** 714,725 ****
          R_bl * (C_bl/2 + 2*C_drain_bit_mux + 2*C_drain_sense_amp_iso + C_sense_amp_latch + C_drain_sense_amp_mux) +
          R_bit_mux * (C_drain_bit_mux + 2*C_drain_sense_amp_iso + C_sense_amp_latch + C_drain_sense_amp_mux) +
          R_sense_amp_iso * (C_drain_sense_amp_iso + C_sense_amp_latch + C_drain_sense_amp_mux);
!       dynRdEnergy += (C_bl + 2 * C_drain_bit_mux) * 2 * dp.V_b_sense * g_tp.sram_cell.Vdd *
!         subarray.num_cols * num_subarrays_per_mat;
        dynRdEnergy += (2 * C_drain_sense_amp_iso + C_sense_amp_latch +  C_drain_sense_amp_mux) * 
!         2 * dp.V_b_sense * g_tp.sram_cell.Vdd * (subarray.num_cols * num_subarrays_per_mat / deg_bl_muxing);
!       dynWriteEnergy += ((subarray.num_cols * num_subarrays_per_mat / deg_bl_muxing) / deg_senseamp_muxing) *
!           num_act_mats_hor_dir * (C_bl + 2*C_drain_bit_mux) * g_tp.sram_cell.Vdd * g_tp.sram_cell.Vdd;
      }
      else
      {
--- 1365,1376 ----
          R_bl * (C_bl/2 + 2*C_drain_bit_mux + 2*C_drain_sense_amp_iso + C_sense_amp_latch + C_drain_sense_amp_mux) +
          R_bit_mux * (C_drain_bit_mux + 2*C_drain_sense_amp_iso + C_sense_amp_latch + C_drain_sense_amp_mux) +
          R_sense_amp_iso * (C_drain_sense_amp_iso + C_sense_amp_latch + C_drain_sense_amp_mux);
!       dynRdEnergy += (C_bl + 2 * C_drain_bit_mux) * 2 * dp.V_b_sense * g_tp.sram_cell.Vdd /* *
!         subarray.num_cols * num_subarrays_per_mat*/; //changing acdng to mcpat 10-11-2021
        dynRdEnergy += (2 * C_drain_sense_amp_iso + C_sense_amp_latch +  C_drain_sense_amp_mux) * 
!         2 * dp.V_b_sense * g_tp.sram_cell.Vdd * (1.0 /*subarray.num_cols * num_subarrays_per_mat*/ / deg_bl_muxing); //changing acdng to mcpat 10-11-2021
!       dynWriteEnergy += ((1.0 /*subarray.num_cols * num_subarrays_per_mat*/ / deg_bl_muxing) / deg_senseamp_muxing) *
!           num_act_mats_hor_dir * (C_bl + 2*C_drain_bit_mux) * g_tp.sram_cell.Vdd * g_tp.sram_cell.Vdd; //*2 removing *2 as it is not included in advcacti //changing acdng to mcpat 10-11-2021
      }
      else
      {
***************
*** 727,743 ****
          (C_bl + C_drain_sense_amp_iso + C_sense_amp_latch + C_drain_sense_amp_mux) + R_bl * C_bl / 2 +
          R_sense_amp_iso * (C_drain_sense_amp_iso + C_sense_amp_latch + C_drain_sense_amp_mux);
        dynRdEnergy += (C_bl + 2 * C_drain_sense_amp_iso + C_sense_amp_latch + C_drain_sense_amp_mux) *
!         2 * dp.V_b_sense * g_tp.sram_cell.Vdd * subarray.num_cols * num_subarrays_per_mat;
!       dynWriteEnergy += (((subarray.num_cols * num_subarrays_per_mat / deg_bl_muxing) / deg_senseamp_muxing) *
!           num_act_mats_hor_dir * C_bl) * g_tp.sram_cell.Vdd * g_tp.sram_cell.Vdd;
! 
      }
      tstep = tau * log(V_b_pre / (V_b_pre - dp.V_b_sense));
      leak_power_sram_cell =
        leak_power_cc_inverters_sram_cell + 
        leak_power_acc_tr_RW_or_WR_port_sram_cell + 
        leak_power_acc_tr_RW_or_WR_port_sram_cell * (RWP + EWP - 1) +
        leak_power_RD_port_sram_cell * ERP;
      power_bitline.readOp.leakage = leak_power_sram_cell;
    }
  
--- 1378,1401 ----
          (C_bl + C_drain_sense_amp_iso + C_sense_amp_latch + C_drain_sense_amp_mux) + R_bl * C_bl / 2 +
          R_sense_amp_iso * (C_drain_sense_amp_iso + C_sense_amp_latch + C_drain_sense_amp_mux);
        dynRdEnergy += (C_bl + 2 * C_drain_sense_amp_iso + C_sense_amp_latch + C_drain_sense_amp_mux) *
!         2 * dp.V_b_sense * g_tp.sram_cell.Vdd /* * subarray.num_cols * num_subarrays_per_mat*/; //changing acdng to mcpat 10-11-2021
!       dynWriteEnergy += (((1.0 /*subarray.num_cols * num_subarrays_per_mat*/ / deg_bl_muxing) / deg_senseamp_muxing) *
!           num_act_mats_hor_dir * C_bl) * g_tp.sram_cell.Vdd * g_tp.sram_cell.Vdd; //*2 removing *2 as it is not included in advcacti; //changing acdng to mcpat 10-11-2021
      }
+ //    cout << "mat:: vbsense: " << dp.V_b_sense << ", vdd: " << g_tp.sram_cell.Vdd << endl;
+ //    cout << "mat:: tau: " << tau << ", dynRdEnergy: " << dynRdEnergy << ", dynWriteEnergy: " << dynWriteEnergy << endl;
+ 
+  /*   cout << "deg_bl_mux: " << deg_bl_muxing << ", C_bl: " << C_bl << ", C_drain_sense_amp_iso: "<< C_drain_sense_amp_iso
+     		<< ", C_sense_amp_latch: " << C_sense_amp_latch <<", C_drain_sense_amp_mux: " << C_drain_sense_amp_mux<<
+ 			", V_b_sense: " << dp.V_b_sense << ", vdd: " << g_tp.sram_cell.Vdd << endl;
+ */
      tstep = tau * log(V_b_pre / (V_b_pre - dp.V_b_sense));
      leak_power_sram_cell =
        leak_power_cc_inverters_sram_cell + 
        leak_power_acc_tr_RW_or_WR_port_sram_cell + 
        leak_power_acc_tr_RW_or_WR_port_sram_cell * (RWP + EWP - 1) +
        leak_power_RD_port_sram_cell * ERP;
+ //    cout << " cc_inv : " << leak_power_cc_inverters_sram_cell << ", acc : " << leak_power_acc_tr_RW_or_WR_port_sram_cell << ", rd : " << leak_power_RD_port_sram_cell << endl;
      power_bitline.readOp.leakage = leak_power_sram_cell;
    }
  
***************
*** 751,757 ****
    {
      delay_bitline = tstep + (V_wl - v_th_mem_cell) / (2 * m);
    }
! 
    bool is_fa = (g_ip->fully_assoc) ? true : false;
  
    if (dp.is_tag == false || is_fa == false)
--- 1409,1419 ----
    {
      delay_bitline = tstep + (V_wl - v_th_mem_cell) / (2 * m);
    }
! /*
!   cout << "V-wl: " <<V_wl <<", inrisetime: " << inrisetime << ", m: " << m
! 		  << ", (tstep <= (0.5 * (V_wl - v_th_mem_cell) / m)): " << (tstep <= (0.5 * (V_wl - v_th_mem_cell) / m))
! 		  <<", tstep: " << tstep << ", v_thmemcell: " << v_th_mem_cell << endl;
! */
    bool is_fa = (g_ip->fully_assoc) ? true : false;
  
    if (dp.is_tag == false || is_fa == false)
***************
*** 759,765 ****
      power_bitline.readOp.dynamic  = dynRdEnergy;
      power_bitline.writeOp.dynamic = dynWriteEnergy;
    }
! 
    double outrisetime = 0; 
    return outrisetime;
  }
--- 1421,1428 ----
      power_bitline.readOp.dynamic  = dynRdEnergy;
      power_bitline.writeOp.dynamic = dynWriteEnergy;
    }
! //  cout << "bitline delay: " << delay_bitline << ", dynamic: " << power_bitline.readOp.dynamic
! //		  << ", leakage: " << power_bitline.readOp.leakage << endl;
    double outrisetime = 0; 
    return outrisetime;
  }
***************
*** 781,802 ****
    double lkgReadPh  = Iiso + IsenseN + IsenseP;//+ IoBufN + IoBufP + 2*IsPch ;
    //double lkgRead = lkgReadPh * num_sa_subarray * 4 * num_act_mats_hor_dir + 
    //    lkgIdlePh * num_sa_subarray * 4 * (num_mats - num_act_mats_hor_dir);
!   double lkgIdle = lkgIdlePh * num_sa_subarray * num_subarrays_per_mat;
!   leak_power_sense_amps_closed_page_state = lkgIdlePh * g_tp.peri_global.Vdd * num_sa_subarray * num_subarrays_per_mat;
!   leak_power_sense_amps_open_page_state   = lkgReadPh * g_tp.peri_global.Vdd * num_sa_subarray * num_subarrays_per_mat;
  
    // sense amplifier has to drive logic in "data out driver" and sense precharge load.
    // load seen by sense amp. New delay model for sense amp that is sensitive to both the output time 
    //constant as well as the magnitude of input differential voltage.
    double C_ld = gate_C(g_tp.w_sense_p + g_tp.w_sense_n, 0, is_dram) +
!     drain_C_(g_tp.w_sense_n, NCH, 1, 0, cell.w * deg_bl_muxing / (RWP + ERP), is_dram) + 
!     drain_C_(g_tp.w_sense_p, PCH, 1, 0, cell.w * deg_bl_muxing / (RWP + ERP), is_dram) +
!     drain_C_(g_tp.w_iso,PCH,1, 0, cell.w * deg_bl_muxing / (RWP + ERP), is_dram) + 
!     drain_C_(g_tp.w_nmos_sa_mux, NCH, 1, 0, cell.w * deg_bl_muxing / (RWP + ERP), is_dram);
    double tau = C_ld / g_tp.gm_sense_amp_latch;
    delay_sa = tau * log(g_tp.peri_global.Vdd / dp.V_b_sense);
!   power_sa.readOp.dynamic = C_ld * g_tp.peri_global.Vdd * g_tp.peri_global.Vdd * num_sa_subarray *
!                             num_subarrays_per_mat;// * num_act_mats_hor_dir;
    power_sa.readOp.leakage = lkgIdle * g_tp.peri_global.Vdd;
  
    double outrisetime = 0;  
--- 1444,1465 ----
    double lkgReadPh  = Iiso + IsenseN + IsenseP;//+ IoBufN + IoBufP + 2*IsPch ;
    //double lkgRead = lkgReadPh * num_sa_subarray * 4 * num_act_mats_hor_dir + 
    //    lkgIdlePh * num_sa_subarray * 4 * (num_mats - num_act_mats_hor_dir);
!   double lkgIdle = lkgIdlePh /* * num_sa_subarray * num_subarrays_per_mat*/; //changing acdng to mcpat 10-11-2021
!   leak_power_sense_amps_closed_page_state = lkgIdlePh * g_tp.peri_global.Vdd /* num_sa_subarray * num_subarrays_per_mat*/; //changing acdng to mcpat 10-11-2021
!   leak_power_sense_amps_open_page_state   = lkgReadPh * g_tp.peri_global.Vdd /* num_sa_subarray * num_subarrays_per_mat*/; //changing acdng to mcpat 10-11-2021
  
    // sense amplifier has to drive logic in "data out driver" and sense precharge load.
    // load seen by sense amp. New delay model for sense amp that is sensitive to both the output time 
    //constant as well as the magnitude of input differential voltage.
    double C_ld = gate_C(g_tp.w_sense_p + g_tp.w_sense_n, 0, is_dram) +
!     drain_C_(g_tp.w_sense_n, NCH, 1, 0, camFlag? cam_cell.w:cell.w * deg_bl_muxing / (RWP + ERP + SCHP), is_dram) +
!     drain_C_(g_tp.w_sense_p, PCH, 1, 0, camFlag? cam_cell.w:cell.w * deg_bl_muxing / (RWP + ERP + SCHP), is_dram) +
!     drain_C_(g_tp.w_iso,PCH,1, 0, camFlag? cam_cell.w:cell.w * deg_bl_muxing / (RWP + ERP + SCHP), is_dram) +
!     drain_C_(g_tp.w_nmos_sa_mux, NCH, 1, 0, camFlag? cam_cell.w:cell.w * deg_bl_muxing / (RWP + ERP + SCHP), is_dram);
    double tau = C_ld / g_tp.gm_sense_amp_latch;
    delay_sa = tau * log(g_tp.peri_global.Vdd / dp.V_b_sense);
!   power_sa.readOp.dynamic = C_ld * g_tp.peri_global.Vdd * g_tp.peri_global.Vdd /* num_sa_subarray *
!                             num_subarrays_per_mat * num_act_mats_hor_dir*/;
    power_sa.readOp.leakage = lkgIdle * g_tp.peri_global.Vdd;
  
    double outrisetime = 0;  
***************
*** 812,818 ****
  
    // delay of signal through pass-transistor of first level of sense-amp mux to input of inverter-buffer.
    rd = tr_R_on(g_tp.w_nmos_sa_mux, NCH, 1, is_dram);
!   C_ld = dp.Ndsam_lev_1 * drain_C_(g_tp.w_nmos_sa_mux, NCH, 1, 0, cell.w * deg_bl_muxing / (RWP + ERP), is_dram) +
      gate_C(g_tp.min_w_nmos_ + p_to_n_sz_r * g_tp.min_w_nmos_, 0.0, is_dram);
    tf = rd * C_ld;
    this_delay = horowitz(inrisetime, tf, 0.5, 0.5, RISE);
--- 1473,1479 ----
  
    // delay of signal through pass-transistor of first level of sense-amp mux to input of inverter-buffer.
    rd = tr_R_on(g_tp.w_nmos_sa_mux, NCH, 1, is_dram);
!   C_ld = dp.Ndsam_lev_1 * drain_C_(g_tp.w_nmos_sa_mux, NCH, 1, 0, camFlag? cam_cell.w:cell.w * deg_bl_muxing / (RWP + ERP + SCHP), is_dram) +
      gate_C(g_tp.min_w_nmos_ + p_to_n_sz_r * g_tp.min_w_nmos_, 0.0, is_dram);
    tf = rd * C_ld;
    this_delay = horowitz(inrisetime, tf, 0.5, 0.5, RISE);
***************
*** 820,826 ****
    inrisetime = this_delay/(1.0 - 0.5);
    power_subarray_out_drv.readOp.dynamic += C_ld * 0.5 * g_tp.peri_global.Vdd * g_tp.peri_global.Vdd;
    power_subarray_out_drv.readOp.leakage += 0;  // for now, let leakage of the pass transistor be 0
! 
    // delay of signal through inverter-buffer to second level of sense-amp mux.
    // internal delay of buffer
    rd = tr_R_on(g_tp.min_w_nmos_, NCH, 1, is_dram);
--- 1481,1492 ----
    inrisetime = this_delay/(1.0 - 0.5);
    power_subarray_out_drv.readOp.dynamic += C_ld * 0.5 * g_tp.peri_global.Vdd * g_tp.peri_global.Vdd;
    power_subarray_out_drv.readOp.leakage += 0;  // for now, let leakage of the pass transistor be 0
! /*
!   cout << "1 rd: " << rd << ", C_ld: " << C_ld <<", tf: " << tf << ", delay: " << this_delay <<
! 		  ", inrisetime: " << inrisetime <<
! 		  ", delay_subarray_out_drv: " << delay_subarray_out_drv << ", dyn: " << power_subarray_out_drv.readOp.dynamic <<
! 		  ", leak: " << power_subarray_out_drv.readOp.leakage << endl;
! */
    // delay of signal through inverter-buffer to second level of sense-amp mux.
    // internal delay of buffer
    rd = tr_R_on(g_tp.min_w_nmos_, NCH, 1, is_dram);
***************
*** 832,864 ****
    delay_subarray_out_drv += this_delay;
    inrisetime = this_delay/(1.0 - 0.5);
    power_subarray_out_drv.readOp.dynamic += C_ld * 0.5 * g_tp.peri_global.Vdd * g_tp.peri_global.Vdd;
!   power_subarray_out_drv.readOp.leakage += cmos_Ileak(g_tp.min_w_nmos_, p_to_n_sz_r * g_tp.min_w_nmos_, is_dram) *
!     0.5 * g_tp.peri_global.Vdd;
! 
    // inverter driving drain of pass transistor of second level of sense-amp mux.
    rd = tr_R_on(g_tp.min_w_nmos_, NCH, 1, is_dram);
    C_ld = drain_C_(g_tp.min_w_nmos_, NCH, 1, 1, g_tp.cell_h_def, is_dram) +
      drain_C_(p_to_n_sz_r * g_tp.min_w_nmos_, PCH, 1, 1, g_tp.cell_h_def, is_dram) +
!     drain_C_(g_tp.w_nmos_sa_mux, NCH, 1, 0, cell.w * deg_bl_muxing * dp.Ndsam_lev_1 / (RWP + ERP), is_dram);
    tf = rd * C_ld;
    this_delay = horowitz(inrisetime, tf, 0.5, 0.5, RISE);
    delay_subarray_out_drv += this_delay;
    inrisetime = this_delay/(1.0 - 0.5);
    power_subarray_out_drv.readOp.dynamic += C_ld * 0.5 * g_tp.peri_global.Vdd * g_tp.peri_global.Vdd;
!   power_subarray_out_drv.readOp.leakage += cmos_Ileak(g_tp.min_w_nmos_, p_to_n_sz_r * g_tp.min_w_nmos_, is_dram) *
!     0.5 * g_tp.peri_global.Vdd;
! 
    // delay of signal through pass-transistor to input of subarray output driver.
    rd = tr_R_on(g_tp.w_nmos_sa_mux, NCH, 1, is_dram);
!   C_ld = dp.Ndsam_lev_2 * drain_C_(g_tp.w_nmos_sa_mux, NCH, 1, 0, cell.w * deg_bl_muxing * dp.Ndsam_lev_1 / (RWP + ERP), is_dram) +
!     gate_C(subarray_out_wire->repeater_size * g_tp.min_w_nmos_ * (1 + p_to_n_sz_r), 0.0, is_dram);
    tf = rd * C_ld;
    this_delay = horowitz(inrisetime, tf, 0.5, 0.5, RISE);
    delay_subarray_out_drv += this_delay;
    inrisetime = this_delay/(1.0 - 0.5);
    power_subarray_out_drv.readOp.dynamic += C_ld * 0.5 * g_tp.peri_global.Vdd * g_tp.peri_global.Vdd;
    power_subarray_out_drv.readOp.leakage += 0;  // for now, let leakage of the pass transistor be 0
! 
    return inrisetime;
  }
  
--- 1498,1545 ----
    delay_subarray_out_drv += this_delay;
    inrisetime = this_delay/(1.0 - 0.5);
    power_subarray_out_drv.readOp.dynamic += C_ld * 0.5 * g_tp.peri_global.Vdd * g_tp.peri_global.Vdd;
! //  power_subarray_out_drv.readOp.leakage += cmos_Ileak(g_tp.min_w_nmos_, p_to_n_sz_r * g_tp.min_w_nmos_, is_dram) *
! //    0.5 * g_tp.peri_global.Vdd;
!   power_subarray_out_drv.readOp.leakage      += cmos_Isub_leakage(g_tp.min_w_nmos_, p_to_n_sz_r * g_tp.min_w_nmos_, 1, inv, is_dram)* g_tp.peri_global.Vdd;
! /*  cout << "2 rd: " << rd << ", C_ld: " << C_ld <<", tf: " << tf << ", delay: " << this_delay <<
! 		  ", inrisetime: " << inrisetime <<
! 		  ", delay_subarray_out_drv: " << delay_subarray_out_drv << ", dyn: " << power_subarray_out_drv.readOp.dynamic <<
! 		  ", leak: " << power_subarray_out_drv.readOp.leakage << endl;
! */
    // inverter driving drain of pass transistor of second level of sense-amp mux.
    rd = tr_R_on(g_tp.min_w_nmos_, NCH, 1, is_dram);
    C_ld = drain_C_(g_tp.min_w_nmos_, NCH, 1, 1, g_tp.cell_h_def, is_dram) +
      drain_C_(p_to_n_sz_r * g_tp.min_w_nmos_, PCH, 1, 1, g_tp.cell_h_def, is_dram) +
!     drain_C_(g_tp.w_nmos_sa_mux, NCH, 1, 0, camFlag? cam_cell.w:cell.w * deg_bl_muxing * dp.Ndsam_lev_1 / (RWP + ERP + SCHP), is_dram);
    tf = rd * C_ld;
    this_delay = horowitz(inrisetime, tf, 0.5, 0.5, RISE);
    delay_subarray_out_drv += this_delay;
    inrisetime = this_delay/(1.0 - 0.5);
    power_subarray_out_drv.readOp.dynamic += C_ld * 0.5 * g_tp.peri_global.Vdd * g_tp.peri_global.Vdd;
! //  power_subarray_out_drv.readOp.leakage += cmos_Ileak(g_tp.min_w_nmos_, p_to_n_sz_r * g_tp.min_w_nmos_, is_dram) *
! //    0.5 * g_tp.peri_global.Vdd;
!   power_subarray_out_drv.readOp.leakage      += cmos_Isub_leakage(g_tp.min_w_nmos_, p_to_n_sz_r * g_tp.min_w_nmos_, 1, inv)* g_tp.peri_global.Vdd;
! /*  cout << "3 rd: " << rd << ", C_ld: " << C_ld <<", tf: " << tf << ", delay: " << this_delay <<
! 		  ", inrisetime: " << inrisetime <<
! 		  ", delay_subarray_out_drv: " << delay_subarray_out_drv << ", dyn: " << power_subarray_out_drv.readOp.dynamic <<
! 		  ", leak: " << power_subarray_out_drv.readOp.leakage << endl;
! */
    // delay of signal through pass-transistor to input of subarray output driver.
    rd = tr_R_on(g_tp.w_nmos_sa_mux, NCH, 1, is_dram);
!   C_ld = dp.Ndsam_lev_2 * drain_C_(g_tp.w_nmos_sa_mux, NCH, 1, 0, camFlag? cam_cell.w:cell.w * deg_bl_muxing * dp.Ndsam_lev_1 / (RWP + ERP + SCHP), is_dram) +
! //    gate_C(subarray_out_wire->repeater_size * g_tp.min_w_nmos_ * (1 + p_to_n_sz_r), 0.0, is_dram);	//removing as per mcpat 24-11-2021
! 	    gate_C(subarray_out_wire->repeater_size *(subarray_out_wire->wire_length/subarray_out_wire->repeater_spacing) * g_tp.min_w_nmos_ * (1 + p_to_n_sz_r), 0.0, is_dram);
    tf = rd * C_ld;
    this_delay = horowitz(inrisetime, tf, 0.5, 0.5, RISE);
    delay_subarray_out_drv += this_delay;
    inrisetime = this_delay/(1.0 - 0.5);
    power_subarray_out_drv.readOp.dynamic += C_ld * 0.5 * g_tp.peri_global.Vdd * g_tp.peri_global.Vdd;
    power_subarray_out_drv.readOp.leakage += 0;  // for now, let leakage of the pass transistor be 0
! /*  cout << "4 rd: " << rd << ", C_ld: " << C_ld <<", tf: " << tf << ", delay: " << this_delay <<
! 		  ", inrisetime: " << inrisetime <<
! 		  ", delay_subarray_out_drv: " << delay_subarray_out_drv << ", dyn: " << power_subarray_out_drv.readOp.dynamic <<
! 		  ", leak: " << power_subarray_out_drv.readOp.leakage << endl;
! */
    return inrisetime;
  }
  
***************
*** 883,889 ****
  
    //For each degree of associativity 
    //there are 4 such quarter comparators
!   double lkgCurrent = 0.5 * cmos_Ileak(g_tp.w_comp_inv_n1, g_tp.w_comp_inv_p1, is_dram) * 4 * A;
  
    /* Second Inverter */
    Ceq = gate_C(g_tp.w_comp_inv_n3+g_tp.w_comp_inv_p3, 0, is_dram) +
--- 1562,1569 ----
  
    //For each degree of associativity 
    //there are 4 such quarter comparators
! //  double lkgCurrent = 0.5 * cmos_Ileak(g_tp.w_comp_inv_n1, g_tp.w_comp_inv_p1, is_dram) * 4 * A;
!   double lkgCurrent   = cmos_Isub_leakage(g_tp.w_comp_inv_n1, g_tp.w_comp_inv_p1, 1, inv, is_dram)* 4 * A;
  
    /* Second Inverter */
    Ceq = gate_C(g_tp.w_comp_inv_n3+g_tp.w_comp_inv_p3, 0, is_dram) +
***************
*** 894,900 ****
    double st2del = horowitz(nextinputtime,tf,VTHCOMPINV,VTHCOMPINV,RISE);
    nextinputtime = st2del/(1.0-VTHCOMPINV);
    power_comparator.readOp.dynamic += 0.5 * Ceq * g_tp.peri_global.Vdd * g_tp.peri_global.Vdd * 4 * A;
!   lkgCurrent += 0.5 * cmos_Ileak(g_tp.w_comp_inv_n2, g_tp.w_comp_inv_p2, is_dram) * 4 * A;
  
    /* Third Inverter */
    Ceq = gate_C(g_tp.w_eval_inv_n+g_tp.w_eval_inv_p, 0, is_dram) +
--- 1574,1581 ----
    double st2del = horowitz(nextinputtime,tf,VTHCOMPINV,VTHCOMPINV,RISE);
    nextinputtime = st2del/(1.0-VTHCOMPINV);
    power_comparator.readOp.dynamic += 0.5 * Ceq * g_tp.peri_global.Vdd * g_tp.peri_global.Vdd * 4 * A;
! //  lkgCurrent += 0.5 * cmos_Ileak(g_tp.w_comp_inv_n2, g_tp.w_comp_inv_p2, is_dram) * 4 * A;
!   lkgCurrent += cmos_Isub_leakage(g_tp.w_comp_inv_n2, g_tp.w_comp_inv_p2, 1, inv, is_dram)* 4 * A;
  
    /* Third Inverter */
    Ceq = gate_C(g_tp.w_eval_inv_n+g_tp.w_eval_inv_p, 0, is_dram) +
***************
*** 905,911 ****
    double st3del = horowitz(nextinputtime,tf,VTHCOMPINV,VTHEVALINV,FALL);
    nextinputtime = st3del/(VTHEVALINV);
    power_comparator.readOp.dynamic += 0.5 * Ceq * g_tp.peri_global.Vdd * g_tp.peri_global.Vdd * 4 * A;
!   lkgCurrent += 0.5 * cmos_Ileak(g_tp.w_comp_inv_n3, g_tp.w_comp_inv_p3, is_dram) * 4 * A;
  
    /* Final Inverter (virtual ground driver) discharging compare part */
    double r1 = tr_R_on(g_tp.w_comp_n,NCH,2, is_dram);
--- 1586,1593 ----
    double st3del = horowitz(nextinputtime,tf,VTHCOMPINV,VTHEVALINV,FALL);
    nextinputtime = st3del/(VTHEVALINV);
    power_comparator.readOp.dynamic += 0.5 * Ceq * g_tp.peri_global.Vdd * g_tp.peri_global.Vdd * 4 * A;
! //  lkgCurrent += 0.5 * cmos_Ileak(g_tp.w_comp_inv_n3, g_tp.w_comp_inv_p3, is_dram) * 4 * A;
!   lkgCurrent += cmos_Isub_leakage(g_tp.w_comp_inv_n3, g_tp.w_comp_inv_p3, 1, inv, is_dram)* 4 * A;
  
    /* Final Inverter (virtual ground driver) discharging compare part */
    double r1 = tr_R_on(g_tp.w_comp_n,NCH,2, is_dram);
***************
*** 920,927 ****
      gate_C(WmuxdrvNANDn+WmuxdrvNANDp,0, is_dram);
    power_comparator.readOp.dynamic += 0.5 * c2 * g_tp.peri_global.Vdd * g_tp.peri_global.Vdd * 4 * A;
    power_comparator.readOp.dynamic += c1 * g_tp.peri_global.Vdd * g_tp.peri_global.Vdd *  (A - 1);
!   lkgCurrent += 0.5 * cmos_Ileak(g_tp.w_eval_inv_n,g_tp.w_eval_inv_p, is_dram) * 4 * A;
!   lkgCurrent += 0.2 * 0.5 * cmos_Ileak(g_tp.w_comp_n, g_tp.w_comp_p, is_dram)  * 4 * A;  // stack factor of 0.2
  
    /* time to go to threshold of mux driver */
    double tstep = (r2*c2+(r1+r2)*c1)*log(1.0/VTHMUXNAND);
--- 1602,1611 ----
      gate_C(WmuxdrvNANDn+WmuxdrvNANDp,0, is_dram);
    power_comparator.readOp.dynamic += 0.5 * c2 * g_tp.peri_global.Vdd * g_tp.peri_global.Vdd * 4 * A;
    power_comparator.readOp.dynamic += c1 * g_tp.peri_global.Vdd * g_tp.peri_global.Vdd *  (A - 1);
! //  lkgCurrent += 0.5 * cmos_Ileak(g_tp.w_eval_inv_n,g_tp.w_eval_inv_p, is_dram) * 4 * A;
! //  lkgCurrent += 0.2 * 0.5 * cmos_Ileak(g_tp.w_comp_n, g_tp.w_comp_p, is_dram)  * 4 * A;  // stack factor of 0.2
!   lkgCurrent += cmos_Isub_leakage(g_tp.w_eval_inv_n, g_tp.w_eval_inv_p, 1, inv, is_dram)* 4 * A;
!   lkgCurrent += cmos_Isub_leakage(g_tp.w_comp_n, g_tp.w_comp_n, 1, inv, is_dram)* 4 * A;  // stack factor of 0.2
  
    /* time to go to threshold of mux driver */
    double tstep = (r2*c2+(r1+r2)*c1)*log(1.0/VTHMUXNAND);
***************
*** 947,953 ****
  }
  
  
! 
  void Mat::compute_power_energy()
  {
    bool is_fa = (g_ip->fully_assoc) ? true : false;
--- 1631,1637 ----
  }
  
  
! /*
  void Mat::compute_power_energy()
  {
    bool is_fa = (g_ip->fully_assoc) ? true : false;
***************
*** 995,1004 ****
    // calculate leakage power
    if (is_fa == false || dp.is_tag == false)
    { // if fully associative cache and tag array, don't add the following components of leakage power
!     power_bitline.readOp.leakage            *= subarray.num_rows * subarray.num_cols * num_subarrays_per_mat;
      power_bl_precharge_eq_drv.readOp.leakage = bl_precharge_eq_drv->power.readOp.leakage * num_subarrays_per_mat;
      power_sa.readOp.leakage                 *= (RWP + ERP);
  
      int number_sa_subarray             = subarray.num_cols / deg_bl_muxing;
      int number_output_drivers_subarray = number_sa_subarray / (dp.Ndsam_lev_1 * dp.Ndsam_lev_2);
      power_subarray_out_drv.readOp.leakage = 
--- 1679,1693 ----
    // calculate leakage power
    if (is_fa == false || dp.is_tag == false)
    { // if fully associative cache and tag array, don't add the following components of leakage power
! 
! //	cout << "mat.cc sram cell leakage : " << power_bitline.readOp.leakage << endl;
! 
! 	power_bitline.readOp.leakage            *= subarray.num_rows * subarray.num_cols * num_subarrays_per_mat;
      power_bl_precharge_eq_drv.readOp.leakage = bl_precharge_eq_drv->power.readOp.leakage * num_subarrays_per_mat;
      power_sa.readOp.leakage                 *= (RWP + ERP);
  
+ //    cout << "mat.cc sram cell leakage*cells in mat : " << power_bitline.readOp.leakage << endl;
+ 
      int number_sa_subarray             = subarray.num_cols / deg_bl_muxing;
      int number_output_drivers_subarray = number_sa_subarray / (dp.Ndsam_lev_1 * dp.Ndsam_lev_2);
      power_subarray_out_drv.readOp.leakage = 
***************
*** 1009,1018 ****
--- 1698,1711 ----
                              power_bl_precharge_eq_drv.readOp.leakage +
                              power_sa.readOp.leakage +
                              power_subarray_out_drv.readOp.leakage;
+ 
+  //   cout << "mat.cc bitlines, precharge, sa, subarray : " << power.readOp.leakage << endl;
+ 
    }
  
    power_comparator.readOp.leakage *= num_do_b_mat * (RWP + ERP);
    power.readOp.leakage += power_comparator.readOp.leakage;
+ //  cout << "mat.cc with comparator : " << power.readOp.leakage << endl;
  
    // leakage power
    power_row_decoders.readOp.leakage = row_dec->power.readOp.leakage * subarray.num_rows * num_subarrays_per_mat;
***************
*** 1028,1032 ****
--- 1721,2033 ----
                            power_bit_mux_decoders.readOp.leakage +
                            power_sa_mux_lev_1_decoders.readOp.leakage +
                            power_sa_mux_lev_2_decoders.readOp.leakage;
+ 
+ //  cout << "mat.cc total : " << power.readOp.leakage << endl;
+ 
  }
+ */
+ 
+ //divya updated Mat:compute_power_energy() func acdng to mcpat-cacti
+ void Mat::compute_power_energy()
+ {
+ 	//for cam and FA, power.readOp is the plain read power, power.searchOp is the associative search related power
+     //when search all subarrays and all mats are fully active
+ 	//when plain read/write only one subarray in a single mat is active.
+ 
+     // add energy consumed in predecoder drivers. This unit is shared by all subarrays in a mat.
+   power.readOp.dynamic += r_predec->power.readOp.dynamic +
+                           b_mux_predec->power.readOp.dynamic +
+                           sa_mux_lev_1_predec->power.readOp.dynamic +
+                           sa_mux_lev_2_predec->power.readOp.dynamic;
+ 
+   // add energy consumed in decoders
+   power_row_decoders.readOp.dynamic        = row_dec->power.readOp.dynamic;
+   if (!(is_fa||pure_cam))
+     power_row_decoders.readOp.dynamic        *= num_subarrays_per_mat;
+ 
+   // add energy consumed in bitline prechagers, SAs, and bitlines
+   if (!(is_fa||pure_cam))
+   {
+ 	  // add energy consumed in bitline prechagers
+ 	  power_bl_precharge_eq_drv.readOp.dynamic = bl_precharge_eq_drv->power.readOp.dynamic;
+ 	  power_bl_precharge_eq_drv.readOp.dynamic *= num_subarrays_per_mat;
+ 
+ 	  //Add sense amps energy
+ 	  num_sa_subarray = subarray.num_cols / deg_bl_muxing;
+ 	  power_sa.readOp.dynamic *= num_sa_subarray*num_subarrays_per_mat ;
+ 
+ 	  // add energy consumed in bitlines
+ 	  //cout<<"bitline power"<<power_bitline.readOp.dynamic<<endl;
+ 	  power_bitline.readOp.dynamic *= num_subarrays_per_mat*subarray.num_cols;
+ 	  power_bitline.writeOp.dynamic *= num_subarrays_per_mat*subarray.num_cols;
+ //	  cout<<"mat:: bitline read power"<<power_bitline.readOp.dynamic<<"subarray"<<num_subarrays_per_mat<<"cols"<<subarray.num_cols<<endl;
+ //	  cout<<"mat:: bitline write power"<<power_bitline.writeOp.dynamic<<"subarray"<<num_subarrays_per_mat<<"cols"<<subarray.num_cols<<endl;
+ 	  //Add subarray output energy
+ 	  power_subarray_out_drv.readOp.dynamic =
+ 		  (power_subarray_out_drv.readOp.dynamic + subarray_out_wire->power.readOp.dynamic) * num_do_b_mat;
+ 
+ 	  power.readOp.dynamic += power_bl_precharge_eq_drv.readOp.dynamic +
+ 	                          power_sa.readOp.dynamic +
+ 	                          power_bitline.readOp.dynamic +
+ 	                          power_subarray_out_drv.readOp.dynamic;
+ 
+ 	  power.readOp.dynamic += power_row_decoders.readOp.dynamic +
+ 	                          bit_mux_dec->power.readOp.dynamic +
+ 	                          sa_mux_lev_1_dec->power.readOp.dynamic +
+ 	                          sa_mux_lev_2_dec->power.readOp.dynamic +
+ 	                          power_comparator.readOp.dynamic;
+   }
+ 
+   else if (is_fa)
+   {
+ 	  //for plain read/write only one subarray in a mat is active
+ 	  // add energy consumed in bitline prechagers
+ 	  power_bl_precharge_eq_drv.readOp.dynamic = bl_precharge_eq_drv->power.readOp.dynamic
+ 	           + cam_bl_precharge_eq_drv->power.readOp.dynamic;
+ 	  power_bl_precharge_eq_drv.searchOp.dynamic = bl_precharge_eq_drv->power.readOp.dynamic;
+ 
+ 	  //Add sense amps energy
+ 	  num_sa_subarray = (subarray.num_cols_fa_cam + subarray.num_cols_fa_ram)/ deg_bl_muxing;
+ 	  num_sa_subarray_search = subarray.num_cols_fa_ram/ deg_bl_muxing;
+ 	  power_sa.searchOp.dynamic = power_sa.readOp.dynamic*num_sa_subarray_search;
+ 	  power_sa.readOp.dynamic *= num_sa_subarray;
+ 
+ 
+ 	  // add energy consumed in bitlines
+ 	  power_bitline.searchOp.dynamic = power_bitline.readOp.dynamic;
+ 	  power_bitline.readOp.dynamic *= (subarray.num_cols_fa_cam+subarray.num_cols_fa_ram);
+ 	  power_bitline.writeOp.dynamic *= (subarray.num_cols_fa_cam+subarray.num_cols_fa_ram);
+ 	  power_bitline.searchOp.dynamic *= subarray.num_cols_fa_ram;
+ 
+ 	  //Add subarray output energy
+       power_subarray_out_drv.searchOp.dynamic =
+ 		  (power_subarray_out_drv.readOp.dynamic + subarray_out_wire->power.readOp.dynamic) * num_so_b_mat;
+ 	  power_subarray_out_drv.readOp.dynamic =
+ 		  (power_subarray_out_drv.readOp.dynamic + subarray_out_wire->power.readOp.dynamic) * num_do_b_mat;
+ 
+ 
+ 	  power.readOp.dynamic += power_bl_precharge_eq_drv.readOp.dynamic +
+ 	                          power_sa.readOp.dynamic +
+ 	                          power_bitline.readOp.dynamic +
+ 	                          power_subarray_out_drv.readOp.dynamic;
+ 
+ 	  power.readOp.dynamic += power_row_decoders.readOp.dynamic +
+ 	                          bit_mux_dec->power.readOp.dynamic +
+ 	                          sa_mux_lev_1_dec->power.readOp.dynamic +
+ 	                          sa_mux_lev_2_dec->power.readOp.dynamic +
+ 	                          power_comparator.readOp.dynamic;
+ 
+ 	  //add energy consumed inside cam
+ 	  power_matchline.searchOp.dynamic *= num_subarrays_per_mat;
+ 	  power_searchline_precharge = sl_precharge_eq_drv->power;
+       power_searchline_precharge.searchOp.dynamic = power_searchline_precharge.readOp.dynamic * num_subarrays_per_mat;
+       power_searchline = sl_data_drv->power;
+       power_searchline.searchOp.dynamic = power_searchline.readOp.dynamic*subarray.num_cols_fa_cam* num_subarrays_per_mat;;
+       power_matchline_precharge  = ml_precharge_drv->power;
+       power_matchline_precharge.searchOp.dynamic = power_matchline_precharge.readOp.dynamic* num_subarrays_per_mat;
+       power_ml_to_ram_wl_drv= ml_to_ram_wl_drv->power;
+       power_ml_to_ram_wl_drv.searchOp.dynamic= ml_to_ram_wl_drv->power.readOp.dynamic;
+ 
+ 	  power_cam_all_active.searchOp.dynamic = power_matchline.searchOp.dynamic;
+ 	  power_cam_all_active.searchOp.dynamic +=power_searchline_precharge.searchOp.dynamic;
+ 	  power_cam_all_active.searchOp.dynamic +=power_searchline.searchOp.dynamic;
+ 	  power_cam_all_active.searchOp.dynamic +=power_matchline_precharge.searchOp.dynamic;
+ 
+ 	  power.searchOp.dynamic += power_cam_all_active.searchOp.dynamic;
+ 	  //power.searchOp.dynamic += ml_to_ram_wl_drv->power.readOp.dynamic;
+ 
+   }
+   else
+   {
+ 	  // add energy consumed in bitline prechagers
+ 	  power_bl_precharge_eq_drv.readOp.dynamic = cam_bl_precharge_eq_drv->power.readOp.dynamic;
+ 	  //power_bl_precharge_eq_drv.readOp.dynamic *= num_subarrays_per_mat;
+ 	  //power_bl_precharge_eq_drv.searchOp.dynamic = cam_bl_precharge_eq_drv->power.readOp.dynamic;
+ 	  //power_bl_precharge_eq_drv.searchOp.dynamic *= num_subarrays_per_mat;
+ 
+ 	  //Add sense amps energy
+ 	  num_sa_subarray = subarray.num_cols_fa_cam/ deg_bl_muxing;
+ 	  power_sa.readOp.dynamic *= num_sa_subarray;//*num_subarrays_per_mat;
+ 	  power_sa.searchOp.dynamic = 0;
+ 
+ 	  power_bitline.readOp.dynamic *= subarray.num_cols_fa_cam;
+ 	  power_bitline.searchOp.dynamic = 0;
+ 	  power_bitline.writeOp.dynamic *= subarray.num_cols_fa_cam;
+ 
+ 	  power_subarray_out_drv.searchOp.dynamic =
+ 		  (power_subarray_out_drv.readOp.dynamic + subarray_out_wire->power.readOp.dynamic) * num_so_b_mat;
+ 	  power_subarray_out_drv.readOp.dynamic =
+ 	  		  (power_subarray_out_drv.readOp.dynamic + subarray_out_wire->power.readOp.dynamic) * num_do_b_mat;
+ 
+ 	  power.readOp.dynamic += power_bl_precharge_eq_drv.readOp.dynamic +
+ 	                          power_sa.readOp.dynamic +
+ 	                          power_bitline.readOp.dynamic +
+ 	                          power_subarray_out_drv.readOp.dynamic;
+ 
+ 	  power.readOp.dynamic += power_row_decoders.readOp.dynamic +
+ 	                          bit_mux_dec->power.readOp.dynamic +
+ 	                          sa_mux_lev_1_dec->power.readOp.dynamic +
+ 	                          sa_mux_lev_2_dec->power.readOp.dynamic +
+ 	                          power_comparator.readOp.dynamic;
+ 
+ 
+ 	  ////add energy consumed inside cam
+ 	  power_matchline.searchOp.dynamic *= num_subarrays_per_mat;
+ 	  power_searchline_precharge = sl_precharge_eq_drv->power;
+       power_searchline_precharge.searchOp.dynamic = power_searchline_precharge.readOp.dynamic * num_subarrays_per_mat;
+       power_searchline = sl_data_drv->power;
+       power_searchline.searchOp.dynamic = power_searchline.readOp.dynamic*subarray.num_cols_fa_cam* num_subarrays_per_mat;;
+       power_matchline_precharge  = ml_precharge_drv->power;
+       power_matchline_precharge.searchOp.dynamic = power_matchline_precharge.readOp.dynamic* num_subarrays_per_mat;
+       power_ml_to_ram_wl_drv= ml_to_ram_wl_drv->power;
+       power_ml_to_ram_wl_drv.searchOp.dynamic= ml_to_ram_wl_drv->power.readOp.dynamic;
+ 
+ 	  power_cam_all_active.searchOp.dynamic = power_matchline.searchOp.dynamic;
+ 	  power_cam_all_active.searchOp.dynamic +=power_searchline_precharge.searchOp.dynamic;
+ 	  power_cam_all_active.searchOp.dynamic +=power_searchline.searchOp.dynamic;
+ 	  power_cam_all_active.searchOp.dynamic +=power_matchline_precharge.searchOp.dynamic;
+ 
+ 	  power.searchOp.dynamic += power_cam_all_active.searchOp.dynamic;
+ 	  //power.searchOp.dynamic += ml_to_ram_wl_drv->power.readOp.dynamic;
+ 
+   }
+ 
+ 
+   int number_output_drivers_subarray;
+ //  // calculate leakage power
+   if (!(is_fa || pure_cam))
+   {
+ 	number_output_drivers_subarray = num_sa_subarray / (dp.Ndsam_lev_1 * dp.Ndsam_lev_2);
+ 
+ 	power_bitline.readOp.leakage            *= subarray.num_rows * subarray.num_cols * num_subarrays_per_mat;
+     power_bl_precharge_eq_drv.readOp.leakage = bl_precharge_eq_drv->power.readOp.leakage * num_subarrays_per_mat;
+     power_sa.readOp.leakage                 *= num_sa_subarray*num_subarrays_per_mat*(RWP + ERP);
+ 
+     //num_sa_subarray             = subarray.num_cols / deg_bl_muxing;
+     power_subarray_out_drv.readOp.leakage =
+       (power_subarray_out_drv.readOp.leakage + subarray_out_wire->power.readOp.leakage) *
+       number_output_drivers_subarray * num_subarrays_per_mat * (RWP + ERP);
+ 
+     power.readOp.leakage += power_bitline.readOp.leakage +
+                             power_bl_precharge_eq_drv.readOp.leakage +
+                             power_sa.readOp.leakage +
+                             power_subarray_out_drv.readOp.leakage;
+ 
+     power_comparator.readOp.leakage *= num_do_b_mat * (RWP + ERP);
+     power.readOp.leakage += power_comparator.readOp.leakage;
+ 
+     array_leakage = power_bitline.readOp.leakage;
+ 
+     cl_leakage =
+ 		power_bl_precharge_eq_drv.readOp.leakage +
+ 		power_sa.readOp.leakage +
+ 		power_subarray_out_drv.readOp.leakage +
+ 		power_comparator.readOp.leakage;
+ 
+ 
+ 
+     //Decoder blocks
+     power_row_decoders.readOp.leakage = row_dec->power.readOp.leakage * subarray.num_rows * num_subarrays_per_mat;
+     power_bit_mux_decoders.readOp.leakage      = bit_mux_dec->power.readOp.leakage * deg_bl_muxing;
+     power_sa_mux_lev_1_decoders.readOp.leakage = sa_mux_lev_1_dec->power.readOp.leakage * dp.Ndsam_lev_1;
+     power_sa_mux_lev_2_decoders.readOp.leakage = sa_mux_lev_2_dec->power.readOp.leakage * dp.Ndsam_lev_2;
+ 
+     	power.readOp.leakage += r_predec->power.readOp.leakage +
+     	b_mux_predec->power.readOp.leakage +
+     	sa_mux_lev_1_predec->power.readOp.leakage +
+     	sa_mux_lev_2_predec->power.readOp.leakage +
+     	power_row_decoders.readOp.leakage +
+     	power_bit_mux_decoders.readOp.leakage +
+     	power_sa_mux_lev_1_decoders.readOp.leakage +
+     	power_sa_mux_lev_2_decoders.readOp.leakage;
+ 
+     wl_leakage = r_predec->power.readOp.leakage +
+ 		b_mux_predec->power.readOp.leakage +
+ 		sa_mux_lev_1_predec->power.readOp.leakage +
+ 		sa_mux_lev_2_predec->power.readOp.leakage +
+ 		power_row_decoders.readOp.leakage +
+ 		power_bit_mux_decoders.readOp.leakage +
+ 		power_sa_mux_lev_1_decoders.readOp.leakage +
+ 		power_sa_mux_lev_2_decoders.readOp.leakage;
+   }
+   else if (is_fa) //fully assoc
+   {
+ 	  int number_output_drivers_subarray = num_sa_subarray;// / (dp.Ndsam_lev_1 * dp.Ndsam_lev_2);
+ 
+ 	  power_bitline.readOp.leakage            *= subarray.num_rows * subarray.num_cols * num_subarrays_per_mat;
+ 	  power_bl_precharge_eq_drv.readOp.leakage = bl_precharge_eq_drv->power.readOp.leakage * num_subarrays_per_mat;
+ 	  power_bl_precharge_eq_drv.searchOp.leakage = cam_bl_precharge_eq_drv->power.readOp.leakage * num_subarrays_per_mat;
+ 	  power_sa.readOp.leakage                 *= num_sa_subarray*num_subarrays_per_mat*(RWP + ERP + SCHP);
+ 
+ 	  //cout<<"leakage3"<<power.readOp.leakage<<endl;
+ 
+ 
+ 	  power_subarray_out_drv.readOp.leakage =
+ 		  (power_subarray_out_drv.readOp.leakage + subarray_out_wire->power.readOp.leakage) *
+ 		  number_output_drivers_subarray * num_subarrays_per_mat * (RWP + ERP + SCHP);
+ 
+ 	  power.readOp.leakage += power_bitline.readOp.leakage +
+ 	                          power_bl_precharge_eq_drv.readOp.leakage +
+ 	                          power_bl_precharge_eq_drv.searchOp.leakage +
+ 	                          power_sa.readOp.leakage +
+ 	                          power_subarray_out_drv.readOp.leakage;
+ 
+ 	  //cout<<"leakage4"<<power.readOp.leakage<<endl;
+ 
+ 	  // leakage power
+ 	  power_row_decoders.readOp.leakage = row_dec->power.readOp.leakage * subarray.num_rows * num_subarrays_per_mat;
+ 	  power.readOp.leakage += r_predec->power.readOp.leakage +
+ 	                          power_row_decoders.readOp.leakage;
+ 
+ 	  //cout<<"leakage5"<<power.readOp.leakage<<endl;
+ 
+ 	  //inside cam
+ 	  power_cam_all_active.searchOp.leakage = power_matchline.searchOp.leakage;
+ 	  power_cam_all_active.searchOp.leakage +=sl_precharge_eq_drv->power.readOp.leakage;
+ 	  power_cam_all_active.searchOp.leakage +=sl_data_drv->power.readOp.leakage*subarray.num_cols_fa_cam;
+ 	  power_cam_all_active.searchOp.leakage +=ml_precharge_drv->power.readOp.dynamic;
+ 	  power_cam_all_active.searchOp.leakage *= num_subarrays_per_mat;
+ 
+ 	  power.readOp.leakage += power_cam_all_active.searchOp.leakage;
+ 
+ //	  cout<<"leakage6"<<power.readOp.leakage<<endl;
+ 
+   }
+   else //pure CAM
+   {
+ 	  int number_output_drivers_subarray = num_sa_subarray;// / (dp.Ndsam_lev_1 * dp.Ndsam_lev_2);
+ 
+ 	  //power_bitline.readOp.leakage            *= subarray.num_rows * subarray.num_cols * num_subarrays_per_mat;
+ 	  //power_bl_precharge_eq_drv.readOp.leakage = bl_precharge_eq_drv->power.readOp.leakage * num_subarrays_per_mat;
+ 	  power_bl_precharge_eq_drv.searchOp.leakage = cam_bl_precharge_eq_drv->power.readOp.leakage * num_subarrays_per_mat;
+ 	  power_sa.readOp.leakage                 *= num_sa_subarray*num_subarrays_per_mat*(RWP + ERP + SCHP);
+ 
+ 
+ 	  power_subarray_out_drv.readOp.leakage =
+ 		  (power_subarray_out_drv.readOp.leakage + subarray_out_wire->power.readOp.leakage) *
+ 		  number_output_drivers_subarray * num_subarrays_per_mat * (RWP + ERP + SCHP);
+ 
+ 	  power.readOp.leakage += //power_bitline.readOp.leakage +
+ 	                          //power_bl_precharge_eq_drv.readOp.leakage +
+ 	                          power_bl_precharge_eq_drv.searchOp.leakage +
+ 	                          power_sa.readOp.leakage +
+ 	                          power_subarray_out_drv.readOp.leakage;
+ 
+ 	  // leakage power
+ 	  power_row_decoders.readOp.leakage = row_dec->power.readOp.leakage * subarray.num_rows * num_subarrays_per_mat*(RWP + ERP + EWP);
+ 	  power.readOp.leakage += r_predec->power.readOp.leakage +
+ 	                          power_row_decoders.readOp.leakage;
+ 
+ 	  //inside cam
+ 	  power_cam_all_active.searchOp.leakage = power_matchline.searchOp.leakage;
+ 	  power_cam_all_active.searchOp.leakage +=sl_precharge_eq_drv->power.readOp.leakage;
+ 	  power_cam_all_active.searchOp.leakage +=sl_data_drv->power.readOp.leakage*subarray.num_cols_fa_cam;
+ 	  power_cam_all_active.searchOp.leakage +=ml_precharge_drv->power.readOp.dynamic;
+ 	  power_cam_all_active.searchOp.leakage *= num_subarrays_per_mat;
+ 
+ 	  power.readOp.leakage += power_cam_all_active.searchOp.leakage;
+ 
+   }
+ }
+ 
  
diff -crB pcacti_xml/mat.h FN-CACTI/mat.h
*** pcacti_xml/mat.h	2014-07-03 09:48:56.000000000 +0200
--- FN-CACTI/mat.h	2023-04-05 13:29:26.351994000 +0200
***************
*** 74,102 ****
  
      Wire   * subarray_out_wire;
      Driver * bl_precharge_eq_drv;
  
      powerDef power_row_decoders;
      powerDef power_bit_mux_decoders;
      powerDef power_sa_mux_lev_1_decoders;
      powerDef power_sa_mux_lev_2_decoders;
      powerDef power_fa_decoder;  // TODO: leakage power is not computed yet
      powerDef power_bl_precharge_eq_drv;
      powerDef power_subarray_out_drv;
  
      double   delay_fa_decoder;
      double   delay_before_decoder;
      double   delay_bitline;
      double   delay_wl_reset;
      double   delay_bl_restore;
  
      Subarray subarray;
!     powerDef power_bitline;
      double   per_bitline_read_energy;
      int      deg_bl_muxing;
      int      num_act_mats_hor_dir;
      double   delay_writeback;
!     Area     cell;
!     bool     is_dram;
      int      num_mats;
      powerDef power_sa;
      double   delay_sa;
--- 74,122 ----
  
      Wire   * subarray_out_wire;
      Driver * bl_precharge_eq_drv;
+     Driver * cam_bl_precharge_eq_drv;//bitline pre-charge circuit is separated for CAM and RAM arrays.
+     Driver * ml_precharge_drv;//matchline prechange driver
+     Driver * sl_precharge_eq_drv;//searchline prechage driver
+     Driver * sl_data_drv;//search line data driver
+     Driver * ml_to_ram_wl_drv;//search line data driver
  
      powerDef power_row_decoders;
      powerDef power_bit_mux_decoders;
      powerDef power_sa_mux_lev_1_decoders;
      powerDef power_sa_mux_lev_2_decoders;
      powerDef power_fa_decoder;  // TODO: leakage power is not computed yet
+     powerDef power_fa_cam;  // TODO: leakage power is not computed yet
      powerDef power_bl_precharge_eq_drv;
      powerDef power_subarray_out_drv;
+     powerDef power_cam_all_active;
+     powerDef power_searchline_precharge;
+     powerDef power_matchline_precharge;
+     powerDef power_ml_to_ram_wl_drv;
  
+     double   delay_fa_tag, delay_cam;
      double   delay_fa_decoder;
      double   delay_before_decoder;
      double   delay_bitline;
      double   delay_wl_reset;
      double   delay_bl_restore;
  
+     double   delay_searchline;
+     double   delay_matchchline;
+     double   delay_cam_sl_restore;
+     double   delay_cam_ml_reset;
+     double   delay_fa_ram_wl;
+ 
+     double   delay_hit_miss_reset;
+     double   delay_hit_miss;
+ 
      Subarray subarray;
!     powerDef power_bitline, power_searchline, power_matchline, power_bitline_gated;
      double   per_bitline_read_energy;
      int      deg_bl_muxing;
      int      num_act_mats_hor_dir;
      double   delay_writeback;
!     Area     cell,cam_cell;
!     bool     is_dram, is_fa, pure_cam, camFlag;
      int      num_mats;
      powerDef power_sa;
      double   delay_sa;
***************
*** 107,124 ****
      double   delay_comparator;
      powerDef power_comparator;
      int      num_do_b_mat;
      double   C_bl;
  	 double   leak_power_sram_cell; // Alireza
  
      uint32_t num_subarrays_per_mat;  // the number of subarrays in a mat
      uint32_t num_subarrays_per_row;  // the number of subarrays in a row of a mat
  
  
    private:
      double compute_bit_mux_sa_precharge_sa_mux_wr_drv_wr_mux_h();
      double width_write_driver_or_write_mux();
      double compute_comparators_height(int tagbits, int number_ways_in_mat, double subarray_mem_cell_area_w);
!     void   delay_fa_tag(int tagbits, int Ntbl, bool is_dram);
      double compute_bitline_delay(double inrisetime);
      double compute_sa_delay(double inrisetime);
      double compute_subarray_out_drv(double inrisetime);
--- 127,151 ----
      double   delay_comparator;
      powerDef power_comparator;
      int      num_do_b_mat;
+     int      num_so_b_mat;
+     int      num_sa_subarray;
+     int      num_sa_subarray_search;
      double   C_bl;
  	 double   leak_power_sram_cell; // Alireza
  
      uint32_t num_subarrays_per_mat;  // the number of subarrays in a mat
      uint32_t num_subarrays_per_row;  // the number of subarrays in a row of a mat
  
+     double  array_leakage;
+     double  wl_leakage;
+     double  cl_leakage;
  
    private:
      double compute_bit_mux_sa_precharge_sa_mux_wr_drv_wr_mux_h();
      double width_write_driver_or_write_mux();
      double compute_comparators_height(int tagbits, int number_ways_in_mat, double subarray_mem_cell_area_w);
!     double compute_cam_delay(double inrisetime);
!     void   delay_fa_tag1(int tagbits, int Ntbl, bool is_dram);
      double compute_bitline_delay(double inrisetime);
      double compute_sa_delay(double inrisetime);
      double compute_subarray_out_drv(double inrisetime);
***************
*** 127,132 ****
--- 154,160 ----
      int RWP;
      int ERP;
      int EWP;
+     int SCHP;
  };
  
  
diff -crB pcacti_xml/nuca.cc FN-CACTI/nuca.cc
*** pcacti_xml/nuca.cc	2014-07-03 09:48:42.000000000 +0200
--- FN-CACTI/nuca.cc	2023-04-05 13:37:52.532242000 +0200
***************
*** 244,251 ****
    }
    cout << "Simulating various NUCA configurations\n";
    for (it=bank_start; it<iterations; it++) { /* different bank count values */
!     ures.tag_array2 = &tag;
!     ures.data_array2 = &data;
      /* 
       * find the optimal bank organization 
       */
--- 244,251 ----
    }
    cout << "Simulating various NUCA configurations\n";
    for (it=bank_start; it<iterations; it++) { /* different bank count values */
!     ures.tag_array2 = tag;
!     ures.data_array2 = data;
      /* 
       * find the optimal bank organization 
       */
diff -crB pcacti_xml/parameter.cc FN-CACTI/parameter.cc
*** pcacti_xml/parameter.cc	2014-07-03 09:48:52.000000000 +0200
--- FN-CACTI/parameter.cc	2023-04-05 13:30:22.871129000 +0200
***************
*** 58,66 ****
  {
    string indent_str(indent, ' ');
  
!   cout << indent_str << "C_g_ideal = " << setw(12) << C_g_ideal << " F/um" << endl;
!   cout << indent_str << "C_fringe  = " << setw(12) << C_fringe  << " F/um" << endl;
!   cout << indent_str << "C_overlap = " << setw(12) << C_overlap << " F/um" << endl;
    cout << indent_str << "C_junc    = " << setw(12) << C_junc    << " F/um^2" << endl;
    cout << indent_str << "l_phy     = " << setw(12) << l_phy     << " um" << endl;
    cout << indent_str << "l_elec    = " << setw(12) << l_elec    << " um" << endl;
--- 58,66 ----
  {
    string indent_str(indent, ' ');
  
!   cout << indent_str << "C_g_ideal = " << setw(12) << C_g_ideal << " F" << endl;
!   cout << indent_str << "C_fringe  = " << setw(12) << C_fringe  << " F" << endl;
!   cout << indent_str << "C_overlap = " << setw(12) << C_overlap << " F" << endl;
    cout << indent_str << "C_junc    = " << setw(12) << C_junc    << " F/um^2" << endl;
    cout << indent_str << "l_phy     = " << setw(12) << l_phy     << " um" << endl;
    cout << indent_str << "l_elec    = " << setw(12) << l_elec    << " um" << endl;
***************
*** 68,78 ****
    cout << indent_str << "R_pch_on  = " << setw(12) << R_pch_on  << " ohm-um" << endl;
    cout << indent_str << "Vdd       = " << setw(12) << Vdd       << " V" << endl;
    cout << indent_str << "Vth       = " << setw(12) << Vth       << " V" << endl;
!   cout << indent_str << "I_on_n    = " << setw(12) << I_on_n    << " A/um" << endl;
!   cout << indent_str << "I_on_p    = " << setw(12) << I_on_p    << " A/um" << endl;
!   cout << indent_str << "I_off_n   = " << setw(12) << I_off_n   << " A/um" << endl;
!   cout << indent_str << "I_off_p   = " << setw(12) << I_off_p   << " A/um" << endl;
!   cout << indent_str << "C_ox      = " << setw(12) << C_ox      << " F/um^2" << endl;
    cout << indent_str << "t_ox      = " << setw(12) << t_ox      << " um" << endl;
    cout << indent_str << "n_to_p_eff_curr_drv_ratio = " << n_to_p_eff_curr_drv_ratio << endl;
  }
--- 68,78 ----
    cout << indent_str << "R_pch_on  = " << setw(12) << R_pch_on  << " ohm-um" << endl;
    cout << indent_str << "Vdd       = " << setw(12) << Vdd       << " V" << endl;
    cout << indent_str << "Vth       = " << setw(12) << Vth       << " V" << endl;
!   cout << indent_str << "I_on_n    = " << setw(12) << I_on_n    << " A" << endl;
!   cout << indent_str << "I_on_p    = " << setw(12) << I_on_p    << " A" << endl;
!   cout << indent_str << "I_off_n   = " << setw(12) << I_off_n   << " A" << endl;
!   cout << indent_str << "I_off_p   = " << setw(12) << I_off_p   << " A" << endl;
!   cout << indent_str << "C_ox      = " << setw(12) << C_ox      << " F/um" << endl;
    cout << indent_str << "t_ox      = " << setw(12) << t_ox      << " um" << endl;
    cout << indent_str << "n_to_p_eff_curr_drv_ratio = " << n_to_p_eff_curr_drv_ratio << endl;
  }
***************
*** 192,209 ****
  }
  
  
- 
  DynamicParameter::DynamicParameter(
      bool is_tag_,
      int pure_ram_,
      double Nspd_,
      unsigned int Ndwl_, 
      unsigned int Ndbl_,
!     unsigned int Ndcm,
      unsigned int Ndsam_lev_1_,
      unsigned int Ndsam_lev_2_,
      bool is_main_mem_):
!   is_tag(is_tag_), pure_ram(pure_ram_), tagbits(0), Nspd(Nspd_), Ndwl(Ndwl_), Ndbl(Ndbl_),
    Ndsam_lev_1(Ndsam_lev_1_), Ndsam_lev_2(Ndsam_lev_2_),
    number_way_select_signals_mat(0), V_b_sense(0), use_inp_params(0),
    is_main_mem(is_main_mem_), cell(), is_valid(false)
--- 192,209 ----
  }
  
  
  DynamicParameter::DynamicParameter(
      bool is_tag_,
      int pure_ram_,
+     int pure_cam_,
      double Nspd_,
      unsigned int Ndwl_, 
      unsigned int Ndbl_,
!     unsigned int Ndcm_,
      unsigned int Ndsam_lev_1_,
      unsigned int Ndsam_lev_2_,
      bool is_main_mem_):
!   is_tag(is_tag_), pure_ram(pure_ram_), pure_cam(pure_cam_), tagbits(0), Nspd(Nspd_), Ndwl(Ndwl_), Ndbl(Ndbl_),Ndcm(Ndcm_),
    Ndsam_lev_1(Ndsam_lev_1_), Ndsam_lev_2(Ndsam_lev_2_),
    number_way_select_signals_mat(0), V_b_sense(0), use_inp_params(0),
    is_main_mem(is_main_mem_), cell(), is_valid(false)
***************
*** 213,221 ****
  
    unsigned int capacity_per_die = g_ip->cache_sz / NUMBER_STACKED_DIE_LAYERS;  // capacity per stacked die layer
    const TechnologyParameter::InterconnectType & wire_local = g_tp.wire_local;
!   bool fully_assoc = (g_ip->fully_assoc) ? true : false;
  
!   if (fully_assoc)
    { // fully-assocative cache -- ref: CACTi 2.0 report
      if (Ndwl != 1 ||            //Ndwl is fixed to 1 for FA 
          Ndcm != 1 ||            //Ndcm is fixed to 1 for FA
--- 213,223 ----
  
    unsigned int capacity_per_die = g_ip->cache_sz / NUMBER_STACKED_DIE_LAYERS;  // capacity per stacked die layer
    const TechnologyParameter::InterconnectType & wire_local = g_tp.wire_local;
!   fully_assoc = (g_ip->fully_assoc) ? true : false;
! 
!   //cout << "dp : fa : " << fully_assoc << "ip.fa : " << g_ip->fully_assoc << endl;
  
!   if (fully_assoc || pure_cam)
    { // fully-assocative cache -- ref: CACTi 2.0 report
      if (Ndwl != 1 ||            //Ndwl is fixed to 1 for FA 
          Ndcm != 1 ||            //Ndcm is fixed to 1 for FA
***************
*** 238,383 ****
    // is formed out of two horizontal subarrays and two vertical subarrays
    if (fully_assoc == false && (Ndwl < 1 || Ndbl < 1))
    {
      return;
    }
  
!   // if data array, let tagbits = 0
!   if (is_tag)
    {
!     if (g_ip->specific_tag)
!     {
!       tagbits = g_ip->tag_w;
!     }
!     else
!     {
!       if (fully_assoc)
!       {
!         tagbits = ADDRESS_BITS + EXTRA_TAG_BITS - _log2(g_ip->block_sz);
!       }
!       else
!       {
!         tagbits = ADDRESS_BITS + EXTRA_TAG_BITS - _log2(capacity_per_die) + 
!           _log2(g_ip->tag_assoc*2 - 1) - _log2(g_ip->nbanks);
!       }
!     }
!     tagbits = (((tagbits + 3) >> 2) << 2);
! 
!     if (fully_assoc)
!     {
!       num_r_subarray = (int)(capacity_per_die / (g_ip->block_sz * Ndbl));
!       num_c_subarray = (int)((tagbits * Nspd / Ndwl) + EPSILON);
!     }
!     else
!     {
!       num_r_subarray = (int)(capacity_per_die / (g_ip->nbanks *
!             g_ip->block_sz * g_ip->tag_assoc * Ndbl * Nspd) + EPSILON);
!       num_c_subarray = (int)((tagbits * g_ip->tag_assoc * Nspd / Ndwl) + EPSILON);
!     }
!     //burst_length = 1;
    }
    else
!   {
!     if (fully_assoc)
!     {
!       num_r_subarray = (int) (capacity_per_die) / (g_ip->block_sz * Ndbl);
!       num_c_subarray = 8 * g_ip->block_sz;
!     }
!     else
!     {
!       num_r_subarray = (int)(capacity_per_die / (g_ip->nbanks * 
!             g_ip->block_sz * g_ip->data_assoc * Ndbl * Nspd) + EPSILON);
!       num_c_subarray = (int)((8 * g_ip->block_sz * g_ip->data_assoc * Nspd / Ndwl) + EPSILON);
!     }
!     // burst_length = g_ip->block_sz * 8 / g_ip->out_w;
!   }    
! 
!   if ((!fully_assoc)&&(num_r_subarray < MINSUBARRAYROWS)) return;
!   if (num_r_subarray == 0) return;
!   if (num_r_subarray > MAXSUBARRAYROWS) return;
!   if (num_c_subarray < MINSUBARRAYCOLS) return;
!   if (num_c_subarray > MAXSUBARRAYCOLS) return;
  
    num_subarrays = Ndwl * Ndbl;  
  
    // calculate wire parameters
!   if(is_tag)
    {
!     cell.h = g_tp.sram.b_h + 2 * wire_local.pitch * (g_ip->num_rw_ports - 1 + g_ip->num_rd_ports);
!     cell.w = g_tp.sram.b_w + 2 * wire_local.pitch * (g_ip->num_rw_ports - 1 + 
!         (g_ip->num_rd_ports - g_ip->num_se_rd_ports)) + 
!       wire_local.pitch * g_ip->num_se_rd_ports;
    }
    else
    {
!     if (is_dram)
!     {
!       cell.h = g_tp.dram.b_h;
!       cell.w = g_tp.dram.b_w;
!     }
!     else
!     {
!       cell.h = g_tp.sram.b_h + 2 * wire_local.pitch * (g_ip->num_wr_ports + 
!           g_ip->num_rw_ports - 1 + g_ip->num_rd_ports);
!       cell.w = g_tp.sram.b_w + 2 * wire_local.pitch * (g_ip->num_rw_ports - 1 + 
!           (g_ip->num_rd_ports - g_ip->num_se_rd_ports) + 
!           g_ip->num_wr_ports) + g_tp.wire_local.pitch * g_ip->num_se_rd_ports;
!     }
    }
  
    double c_b_metal = cell.h * wire_local.C_per_um;
    double C_bl;
  
!   if (is_dram)
    {
!     deg_bl_muxing = 1;
!     if (ram_cell_tech_type == comm_dram)
!     {
!       C_bl  = num_r_subarray * c_b_metal;
!       V_b_sense = (g_tp.dram_cell_Vdd/2) * g_tp.dram_cell_C / (g_tp.dram_cell_C + C_bl);
!       if (V_b_sense < g_tp.Vbit_sense_min)
!       {
!         return;
!       }
!       V_b_sense = g_tp.Vbit_sense_min;  // in any case, we fix sense amp input signal to a constant value
!       dram_refresh_period = 64e-3;
!     }
!     else
!     {
!       double Cbitrow_drain_cap = drain_C_(g_tp.dram.cell_a_w, NCH, 1, 0, cell.w, true, true) / 2.0;
!       C_bl  = num_r_subarray * (Cbitrow_drain_cap + c_b_metal);
!       V_b_sense = (g_tp.dram_cell_Vdd/2) * g_tp.dram_cell_C /(g_tp.dram_cell_C + C_bl);
! 
!       if (V_b_sense < g_tp.Vbit_sense_min)
!       {
!         return; //Sense amp input signal is smaller that minimum allowable sense amp input signal
!       }
!       V_b_sense = g_tp.Vbit_sense_min; // in any case, we fix sense amp input signal to a constant value
!       //v_storage_worst = g_tp.dram_cell_Vdd / 2 - g_tp.Vbit_sense_min * (g_tp.dram_cell_C + C_bl) / g_tp.dram_cell_C;
!       //dram_refresh_period = 1.1 * g_tp.dram_cell_C * v_storage_worst / g_tp.dram_cell_I_off_worst_case_len_temp;
!       dram_refresh_period = 0.9 * g_tp.dram_cell_C * VDD_STORAGE_LOSS_FRACTION_WORST * g_tp.dram_cell_Vdd / g_tp.dram_cell_I_off_worst_case_len_temp;
!     }
    }
    else
!   { //SRAM
!     if ( g_ip->is_finfet ) {
! 	  V_b_sense = g_tp.Vbit_sense_min;
! 	} else {
!       V_b_sense = (0.05 * g_tp.sram_cell.Vdd > g_tp.Vbit_sense_min) ? 0.05 * g_tp.sram_cell.Vdd : g_tp.Vbit_sense_min;
! 	}
!     deg_bl_muxing = Ndcm;
!     // "/ 2.0" below is due to the fact that two adjacent access transistors share drain
!     // contacts in a physical layout
!     double Cbitrow_drain_cap = drain_C_(g_tp.sram.cell_a_w, NCH, 1, 0, cell.w, false, true) / 2.0;
!     C_bl = num_r_subarray * (Cbitrow_drain_cap + c_b_metal);
!     dram_refresh_period = 0;
!   }
! 
!   if (fully_assoc)
!   {
!     num_mats_h_dir = 1;
!     num_mats_v_dir = Ndbl / 2;
!     num_do_b_mat   = 8 * g_ip->block_sz;
!     num_mats = num_mats_h_dir * num_mats_v_dir;
    }
    else
    {
--- 240,487 ----
    // is formed out of two horizontal subarrays and two vertical subarrays
    if (fully_assoc == false && (Ndwl < 1 || Ndbl < 1))
    {
+ 	if(is_tag)
+ 		cout << "Ndwl : " << Ndwl << ", Ndbl : " << Ndbl << endl;
+ 
      return;
    }
  
!   //***********compute row, col of an subarray
!   if (!(fully_assoc || pure_cam))//Not fully_asso nor cam
    {
! 	  // if data array, let tagbits = 0
! 	  if (is_tag)
! 	  {
! 		if (g_ip->specific_tag)
! 		{
! 		  tagbits = g_ip->tag_w;
! 		}
! 		else
! 		{
! 			tagbits = ADDRESS_BITS + EXTRA_TAG_BITS - _log2(capacity_per_die) +
! 			  _log2(g_ip->tag_assoc*2 - 1) - _log2(g_ip->nbanks);
! 		}
! 		tagbits = (((tagbits + 3) >> 2) << 2);
! 
! 		  num_r_subarray = (int)(capacity_per_die / (g_ip->nbanks *
! 				g_ip->block_sz * g_ip->tag_assoc * Ndbl * Nspd));// + EPSILON);
! 		  num_c_subarray = (int)((tagbits * g_ip->tag_assoc * Nspd / Ndwl));// + EPSILON);
! 
! 	//    cout << "1 dynp : Ndwl : " << Ndwl << ", Ndbl : " << Ndbl << ", Nspd : " << Nspd << ", Ndcm : " << Ndcm << ", Ndsam_lev_1 : " << Ndsam_lev_1
! 	//    			  << ", Ndsam_lev_2 : " << Ndsam_lev_2 << endl;
! 	//    cout << "2 dynp : tagbits : " << tagbits << ", num_r_subarray : "  << num_r_subarray << ", num_c_subarray : " << num_c_subarray << endl;
! 	  } else {
! 		  num_r_subarray = (int)ceil(capacity_per_die / (g_ip->nbanks *
! 				  g_ip->block_sz * g_ip->data_assoc * Ndbl * Nspd));// + EPSILON);
! 		  num_c_subarray = (int)ceil((8 * g_ip->block_sz * g_ip->data_assoc * Nspd / Ndwl));// + EPSILON); + EPSILON);
! 		  // burst_length = g_ip->block_sz * 8 / g_ip->out_w;
! 		  }
! 
! 	  //cout << "num_r_subarray : " << num_r_subarray << ", num_c_subarray : " << num_c_subarray << endl;
! 	  if (num_r_subarray < MINSUBARRAYROWS) return;
! 	  if (num_r_subarray == 0) return;
! 	  if (num_r_subarray > MAXSUBARRAYROWS) return;
! 	  if (num_c_subarray < MINSUBARRAYCOLS) return;
! 	  if (num_c_subarray > MAXSUBARRAYCOLS) return;
    }
    else
!   { //either fully-assoc or cam
! 	  if (pure_cam)
! 	  {
! 		  if (g_ip->specific_tag)
! 		  {
! 			  tagbits = int(ceil(g_ip->tag_w/8.0)*8);
! 		  }
! 		  else
! 		  {
! 			  tagbits = int(ceil((ADDRESS_BITS + EXTRA_TAG_BITS)/8.0)*8);
! //			  cout<<"Pure CAM needs tag width to be specified"<<endl;
! //			  exit(0);
! 		  }
! 		  //tagbits = (((tagbits + 3) >> 2) << 2);
! 
! 		  tag_num_r_subarray = (int)ceil(capacity_per_die / (g_ip->nbanks*tagbits/8.0 * Ndbl));//TODO: error check input of tagbits and blocksize //TODO: for pure CAM, g_ip->block should be number of entries.
! 		  //tag_num_c_subarray = (int)(tagbits  + EPSILON);
! 		  tag_num_c_subarray = tagbits;
! 		  if (tag_num_r_subarray == 0) return;
! 		  if (tag_num_r_subarray > MAXSUBARRAYROWS) return;
! 		  if (tag_num_c_subarray < MINSUBARRAYCOLS) return;
! 		  if (tag_num_c_subarray > MAXSUBARRAYCOLS) return;
! 		  num_r_subarray = tag_num_r_subarray;
! 	  }
! 	 else //if (fully_assoc)
!     {
! 		  if (g_ip->specific_tag)
! 		  {
! 			  tagbits = g_ip->tag_w;
! 		  }
! 		  else
! 		  {
! 			  tagbits = ADDRESS_BITS + EXTRA_TAG_BITS - _log2(g_ip->block_sz);//TODO: should be the page_offset=log2(page size), but this info is not avail with CACTI, for McPAT this is no problem.
! 		  }
! 		  tagbits = (((tagbits + 3) >> 2) << 2);
! 
! 		  tag_num_r_subarray = (int)(capacity_per_die / (g_ip->nbanks*g_ip->block_sz * Ndbl));
! 		  tag_num_c_subarray = (int)ceil((tagbits * Nspd / Ndwl));// + EPSILON);
! 		  if (tag_num_r_subarray == 0) return;
! 		  if (tag_num_r_subarray > MAXSUBARRAYROWS) return;
! 		  if (tag_num_c_subarray < MINSUBARRAYCOLS) return;
! 		  if (tag_num_c_subarray > MAXSUBARRAYCOLS) return;
! 
! 		  data_num_r_subarray = tag_num_r_subarray;
! 		  data_num_c_subarray = 8 * g_ip->block_sz;
! 		  if (data_num_r_subarray == 0) return;
! 		  if (data_num_r_subarray > MAXSUBARRAYROWS) return;
! 		  if (data_num_c_subarray < MINSUBARRAYCOLS) return;
! 		  if (data_num_c_subarray > MAXSUBARRAYCOLS) return;
! 		  num_r_subarray = tag_num_r_subarray;
! 	  }
!    }
  
    num_subarrays = Ndwl * Ndbl;  
  
    // calculate wire parameters
!   if (fully_assoc || pure_cam)
    {
! 	  cam_cell.h = g_tp.cam.b_h + 2 * wire_local.pitch * (g_ip->num_rw_ports-1 + g_ip->num_rd_ports + g_ip->num_wr_ports)
! 	  + 2 * wire_local.pitch*(g_ip->num_search_ports-1) + wire_local.pitch * g_ip->num_se_rd_ports;
! 	  cam_cell.w = g_tp.cam.b_w + 2 * wire_local.pitch * (g_ip->num_rw_ports-1 + g_ip->num_rd_ports + g_ip->num_wr_ports)
! 	  + 2 * wire_local.pitch*(g_ip->num_search_ports-1) + wire_local.pitch * g_ip->num_se_rd_ports;
! 
! 	  cell.h = g_tp.sram.b_h + 2 * wire_local.pitch * (g_ip->num_wr_ports +g_ip->num_rw_ports-1 + g_ip->num_rd_ports)
! 	  + 2 * wire_local.pitch*(g_ip->num_search_ports-1);
! 	  cell.w = g_tp.sram.b_w + 2 * wire_local.pitch * (g_ip->num_rw_ports -1 + (g_ip->num_rd_ports - g_ip->num_se_rd_ports)
! 			  + g_ip->num_wr_ports) + g_tp.wire_local.pitch * g_ip->num_se_rd_ports + 2 * wire_local.pitch*(g_ip->num_search_ports-1);
    }
    else
    {
! 	  if(is_tag)
! 	  {
! 		  cell.h = g_tp.sram.b_h + 2 * wire_local.pitch * (g_ip->num_rw_ports - 1 + g_ip->num_rd_ports +
! 				  g_ip->num_wr_ports);
! 		  cell.w = g_tp.sram.b_w + 2 * wire_local.pitch * (g_ip->num_rw_ports - 1 + g_ip->num_wr_ports +
! 				  (g_ip->num_rd_ports - g_ip->num_se_rd_ports)) +
! 				  wire_local.pitch * g_ip->num_se_rd_ports;
! 	  }
! 	  else
! 	  {
! 		  if (is_dram)
! 		  {
! 			  cell.h = g_tp.dram.b_h;
! 			  cell.w = g_tp.dram.b_w;
! 		  }
! 		  else
! 		  {
! 			  cell.h = g_tp.sram.b_h + 2 * wire_local.pitch * (g_ip->num_wr_ports +
! 					  g_ip->num_rw_ports - 1 + g_ip->num_rd_ports);
! 			  cell.w = g_tp.sram.b_w + 2 * wire_local.pitch * (g_ip->num_rw_ports - 1 +
! 					  (g_ip->num_rd_ports - g_ip->num_se_rd_ports) +
! 					  g_ip->num_wr_ports) + g_tp.wire_local.pitch * g_ip->num_se_rd_ports;
! 		  }
! 	  }
    }
  
    double c_b_metal = cell.h * wire_local.C_per_um;
    double C_bl;
  
!   if (!(fully_assoc || pure_cam))
    {
! 	  if (is_dram)
! 	  {
! 		deg_bl_muxing = 1;
! 		if (ram_cell_tech_type == comm_dram)
! 		{
! 		  C_bl  = num_r_subarray * c_b_metal;
! 		  V_b_sense = (g_tp.dram_cell_Vdd/2) * g_tp.dram_cell_C / (g_tp.dram_cell_C + C_bl);
! 		  if (V_b_sense < g_tp.Vbit_sense_min)
! 		  {
! 			return;
! 		  }
! 		  V_b_sense = g_tp.Vbit_sense_min;  // in any case, we fix sense amp input signal to a constant value
! 		  dram_refresh_period = 64e-3;
! 		}
! 		else
! 		{
! 		  double Cbitrow_drain_cap = drain_C_(g_tp.dram.cell_a_w, NCH, 1, 0, cell.w, true, true) / 2.0;
! 
! 		  C_bl  = num_r_subarray * (Cbitrow_drain_cap + c_b_metal);
! 		  V_b_sense = (g_tp.dram_cell_Vdd/2) * g_tp.dram_cell_C /(g_tp.dram_cell_C + C_bl);
! 
! 		  if (V_b_sense < g_tp.Vbit_sense_min)
! 		  {
! 			return; //Sense amp input signal is smaller that minimum allowable sense amp input signal
! 		  }
! 		  V_b_sense = g_tp.Vbit_sense_min; // in any case, we fix sense amp input signal to a constant value
! 		  //v_storage_worst = g_tp.dram_cell_Vdd / 2 - g_tp.Vbit_sense_min * (g_tp.dram_cell_C + C_bl) / g_tp.dram_cell_C;
! 		  //dram_refresh_period = 1.1 * g_tp.dram_cell_C * v_storage_worst / g_tp.dram_cell_I_off_worst_case_len_temp;
! 		  dram_refresh_period = 0.9 * g_tp.dram_cell_C * VDD_STORAGE_LOSS_FRACTION_WORST * g_tp.dram_cell_Vdd / g_tp.dram_cell_I_off_worst_case_len_temp;
! 		}
! 	  }
! 	  else
! 	  { //SRAM
! 		if ( g_ip->is_finfet ) {
! 		  V_b_sense = g_tp.Vbit_sense_min;
! 		} else {
! 		  V_b_sense = (0.05 * g_tp.sram_cell.Vdd > g_tp.Vbit_sense_min) ? 0.05 * g_tp.sram_cell.Vdd : g_tp.Vbit_sense_min;
! 		}
! 		deg_bl_muxing = Ndcm;
! 		// "/ 2.0" below is due to the fact that two adjacent access transistors share drain
! 		// contacts in a physical layout
! 
! 		double Cbitrow_drain_cap = drain_C_(g_tp.sram.cell_a_w, NCH, 1, 0, cell.w, false, true) / 2.0;
! 
! 		C_bl = num_r_subarray * (Cbitrow_drain_cap + c_b_metal);
! 		dram_refresh_period = 0;
! 	  }
    }
    else
!   {
! 	  c_b_metal = cam_cell.h * wire_local.C_per_um;//IBM and SUN design, SRAM array uses dummy cells to fill the blank space due to mismatch on CAM-RAM
! 	  if ( g_ip->is_finfet )
! 	  	  V_b_sense = g_tp.Vbit_sense_min;
! 	  else
! 		  V_b_sense = (0.05 * g_tp.sram_cell.Vdd > g_tp.Vbit_sense_min) ? 0.05 * g_tp.sram_cell.Vdd : g_tp.Vbit_sense_min;
! 	  deg_bl_muxing = 1;//FA fix as 1
! 	  // "/ 2.0" below is due to the fact that two adjacent access transistors share drain
! 	  // contacts in a physical layout
! 	  double Cbitrow_drain_cap = drain_C_(g_tp.cam.cell_a_w, NCH, 1, 0, cam_cell.w, false, true) / 2.0;//TODO: comment out these two lines
! 	  C_bl = num_r_subarray * (Cbitrow_drain_cap + c_b_metal);
! 	  dram_refresh_period = 0;
!   }
! 
!  // cout << "5 5 \n";
! 
!   if (fully_assoc || pure_cam)
!   {
! 	    switch (Ndbl) {
! 	      case (0):
! 	        cout <<  "   Invalid Ndbl \n"<<endl;
! 	        exit(0);
! 	        break;
! 	      case (1):
! 	    	  num_mats_h_dir = 1;//one subarray per mat
! 	    	  num_mats_v_dir = 1;
! 	        break;
! 	      case (2):
! 	    	  num_mats_h_dir = 1;//two subarrays per mat
! 	    	  num_mats_v_dir = 1;
! 	    	  break;
! 	      default:
! 	    	  num_mats_h_dir = int(floor(sqrt(Ndbl/4.0)));//4 subbarrys per mat
! 	    	  num_mats_v_dir = int(Ndbl/4.0 / num_mats_h_dir);
! 	    }
! 	    num_mats = num_mats_h_dir * num_mats_v_dir;
! 
! 	    if (fully_assoc)
! 	    {
! 	    	num_so_b_mat   = data_num_c_subarray;
! 	    	num_do_b_mat   = data_num_c_subarray + tagbits;
! 	    }
! 	    else
! 	    {
! 	    	num_so_b_mat = int(ceil(log2(num_r_subarray)) + ceil(log2(num_subarrays)));//the address contains the matched data
! 	    	num_do_b_mat = tagbits;
! 	    }
    }
    else
    {
***************
*** 386,468 ****
      num_mats       = num_mats_h_dir * num_mats_v_dir;
      num_do_b_mat   = MAX((num_subarrays/num_mats) * num_c_subarray / (deg_bl_muxing * Ndsam_lev_1 * Ndsam_lev_2), 1);
    }
  
!   if (!(fully_assoc&&is_tag) && (num_do_b_mat < (num_subarrays/num_mats)))
    {
      return;
    }
  
  
    int deg_sa_mux_l1_non_assoc;
  
!   if (!is_tag)
    {
!     if (is_main_mem == true)
!     {
!       num_do_b_subbank = g_ip->int_prefetch_w * g_ip->out_w;
!       deg_sa_mux_l1_non_assoc = Ndsam_lev_1;
!     }
!     else
!     {
!       if (g_ip->fast_access == true)
!       {
!         num_do_b_subbank = g_ip->out_w * g_ip->data_assoc;
!         deg_sa_mux_l1_non_assoc = Ndsam_lev_1;
!       }
!       else
!       {
!         if (!fully_assoc)
!         {
!           num_do_b_subbank = g_ip->out_w;
!           deg_sa_mux_l1_non_assoc = Ndsam_lev_1 / g_ip->data_assoc;
!           if (deg_sa_mux_l1_non_assoc < 1)
!           {
!             return;
!           }
!         }
!         else
!         {
!           num_do_b_subbank = 8 * g_ip->block_sz;
!           deg_sa_mux_l1_non_assoc = 1;
!         }
!       }
!     }
!   }
    else
    {
!     num_do_b_subbank = tagbits * g_ip->tag_assoc;
!     if (fully_assoc == false && (num_do_b_mat < tagbits))
!     {
!       return;
!     }
!     deg_sa_mux_l1_non_assoc = Ndsam_lev_1;
!     //num_do_b_mat = g_ip->tag_assoc / num_mats_h_dir;
    }
  
    deg_senseamp_muxing_non_associativity = deg_sa_mux_l1_non_assoc;
  
!   if (fully_assoc)
    {
      num_act_mats_hor_dir = 1;
    }
    else
    {
      num_act_mats_hor_dir = num_do_b_subbank / num_do_b_mat;
      if (num_act_mats_hor_dir == 0)
      {
        return;
      }
    }
  
  
    if (is_tag)
    {
!     if (fully_assoc)
!     {
!       num_do_b_mat     = 0;
!       num_do_b_subbank = 0;
!     }
!     else
      {
        num_do_b_mat     = g_ip->tag_assoc / num_act_mats_hor_dir;
        num_do_b_subbank = num_act_mats_hor_dir * num_do_b_mat;
--- 490,584 ----
      num_mats       = num_mats_h_dir * num_mats_v_dir;
      num_do_b_mat   = MAX((num_subarrays/num_mats) * num_c_subarray / (deg_bl_muxing * Ndsam_lev_1 * Ndsam_lev_2), 1);
    }
+ //  cout << "4 dynp : num_do_b_mat : "<< num_do_b_mat << ", num_subarrays : " << num_subarrays << ", num_mats : " << num_mats << endl;
  
!   if (!(fully_assoc || pure_cam) && (num_do_b_mat < (num_subarrays/num_mats)))
    {
+ 	  //cout << "4 dynp : num_do_b_mat : "<< num_do_b_mat << ", num_subarrays : " << num_subarrays << ", num_mats : " << num_mats << endl;
      return;
    }
  
  
    int deg_sa_mux_l1_non_assoc;
  
!   if (!(fully_assoc || pure_cam))
    {
! 	  if (!is_tag)
! 	  {
! 		if (is_main_mem == true)
! 		{
! 		  num_do_b_subbank = g_ip->int_prefetch_w * g_ip->out_w;
! 		  deg_sa_mux_l1_non_assoc = Ndsam_lev_1;
! 		}
! 		else
! 		{
! 		  if (g_ip->fast_access == true)
! 		  {
! 			num_do_b_subbank = g_ip->out_w * g_ip->data_assoc;
! 			deg_sa_mux_l1_non_assoc = Ndsam_lev_1;
! 		  }
! 		  else
! 		  {
! 			  num_do_b_subbank = g_ip->out_w;
! 			  deg_sa_mux_l1_non_assoc = Ndsam_lev_1 / g_ip->data_assoc;
! 			  if (deg_sa_mux_l1_non_assoc < 1)
! 			  {
! 				  //cout << " 5 dynp deg_sa_mux_l1_non_assoc : " << deg_sa_mux_l1_non_assoc << endl;
! 				return;
! 			  }
! 		   }
! 		}
! 	  }
! 	  else
! 	  {
! 		  num_do_b_subbank = tagbits * g_ip->tag_assoc;
! 		  if (num_do_b_mat < tagbits)
! 		  {
! 			  return;
! 		  }
! 		  deg_sa_mux_l1_non_assoc = Ndsam_lev_1;
! 		  //num_do_b_mat = g_ip->tag_assoc / num_mats_h_dir;
! 	  }
!    }
    else
    {
! 	  if (fully_assoc)
! 	  {
! 		  num_so_b_subbank = 8 * g_ip->block_sz;//TODO:internal perfetch should be considered also for fa
! 		  num_do_b_subbank = num_so_b_subbank + tag_num_c_subarray;
! 	  }
! 	  else
! 	  {
! 		  num_so_b_subbank = int(ceil(log2(num_r_subarray)) + ceil(log2(num_subarrays)));//the address contains the matched data
! 		  num_do_b_subbank = tag_num_c_subarray;
! 	  }
! 
! 	deg_sa_mux_l1_non_assoc = 1;
    }
  
    deg_senseamp_muxing_non_associativity = deg_sa_mux_l1_non_assoc;
  
!   if (fully_assoc || pure_cam)
    {
      num_act_mats_hor_dir = 1;
+ 	  num_act_mats_hor_dir_sl = num_mats_h_dir;//TODO: this is unnecessary, since search op, num_mats is used
    }
    else
    {
      num_act_mats_hor_dir = num_do_b_subbank / num_do_b_mat;
+     //cout << "num_do_b_subbank : " << num_do_b_subbank << ", num_do_b_mat :" << num_do_b_mat << " out_w : " << g_ip->out_w << endl;
      if (num_act_mats_hor_dir == 0)
      {
+     	//cout << "5 dynp : num_act_mats_hor_dir : " << num_act_mats_hor_dir << endl;
        return;
      }
    }
  
+ 	//cout << "52 dynp : num_do_b_subbank : " << num_do_b_subbank << ", num_do_b_mat ; " << num_do_b_mat << ", num_act_mats_hor_dir : " << num_act_mats_hor_dir << endl;
  
    if (is_tag)
    {
!     if (!(fully_assoc || pure_cam))
      {
        num_do_b_mat     = g_ip->tag_assoc / num_act_mats_hor_dir;
        num_do_b_subbank = num_act_mats_hor_dir * num_do_b_mat;
***************
*** 482,518 ****
    {
      return;
    }
  
!   if (num_act_mats_hor_dir > num_mats_h_dir) 
    {
      return;
    }
! 
!   if(!is_tag)
!   {
!     if(g_ip->fast_access == true)
!     {
!       num_di_b_mat = num_do_b_mat / g_ip->data_assoc;
!     }
!     else
!     {
!       num_di_b_mat = num_do_b_mat;
!     }
    }
    else
    {
!     num_di_b_mat = tagbits;
    }
  
    int num_di_b_subbank       = num_di_b_mat * num_act_mats_hor_dir;
!   int num_addr_b_row_dec     = (fully_assoc == true) ? 0 : _log2(num_r_subarray);
    int number_subbanks        = num_mats / num_act_mats_hor_dir;
!   number_subbanks_decode = _log2(number_subbanks);
  
    num_rw_ports = g_ip->num_rw_ports;
    num_rd_ports = g_ip->num_rd_ports;
    num_wr_ports = g_ip->num_wr_ports;
    num_se_rd_ports = g_ip->num_se_rd_ports;
  
    if (is_dram && is_main_mem)
    {
--- 598,665 ----
    {
      return;
    }
+  	//cout << "55 dynp : num_do_b_subbank : " << num_do_b_subbank << ", num_do_b_mat ; " << num_do_b_mat << endl;
  
!   if (num_act_mats_hor_dir > num_mats_h_dir) //Original
    {
+ 	  //cout << "6 dynp num_act_mats_hor_dir : " << num_act_mats_hor_dir << ", num_mats_h_dir : " << num_mats_h_dir << endl;
      return;
    }
! //cout << "7 dynp here \n";
!   //compute di for mat subbank and bank
!   if (!(fully_assoc ||pure_cam))
!   {
! 	  if(!is_tag)
! 	  {
! 		  if(g_ip->fast_access == true)
! 		  {
! 			  num_di_b_mat = num_do_b_mat / g_ip->data_assoc;
! 		  }
! 		  else
! 		  {
! 			  num_di_b_mat = num_do_b_mat;
! 		  }
! 	  }
! 	  else
! 	  {
! 		  num_di_b_mat = tagbits;
! 	  }
    }
    else
    {
! 	  if (fully_assoc)
! 	  {
! 		  num_di_b_mat = num_do_b_mat;
! 		  //*num_subarrays/num_mats; bits per mat of CAM/FA is as same as cache,
! 		  //but inside the mat wire tracks need to be reserved for search data bus
! 		  num_si_b_mat = tagbits;
! 	  }
! 	  else
! 	  {
! 		  num_di_b_mat = tagbits;
! 		  num_si_b_mat = tagbits;//*num_subarrays/num_mats;
! 	  }
! 
    }
+   //cout << "8 dynp here,  num_r_subarray : " << num_r_subarray << endl;
  
    int num_di_b_subbank       = num_di_b_mat * num_act_mats_hor_dir;
!   num_si_b_subbank       = num_si_b_mat; //* num_act_mats_hor_dir_sl; inside the data is broadcast
! 
!   int num_addr_b_row_dec     = _log2(num_r_subarray);
!   if  ((fully_assoc ||pure_cam))
! 	  num_addr_b_row_dec     +=_log2(num_subarrays/num_mats);
    int number_subbanks        = num_mats / num_act_mats_hor_dir;
!   number_subbanks_decode = _log2(number_subbanks);//TODO: add log2(num_subarray_per_bank) to FA/CAM
! 
!   //cout << " 9 dynp deg_bl_muxing : " << deg_bl_muxing << ", deg_sa_mux_l1_non_assoc : " << deg_sa_mux_l1_non_assoc << ", Ndsam_lev_2 : " << Ndsam_lev_2
! //		  << ", number_subbanks : " << number_subbanks << endl;
  
    num_rw_ports = g_ip->num_rw_ports;
    num_rd_ports = g_ip->num_rd_ports;
    num_wr_ports = g_ip->num_wr_ports;
    num_se_rd_ports = g_ip->num_se_rd_ports;
+   num_search_ports = g_ip->num_search_ports;
  
    if (is_dram && is_main_mem)
    {
***************
*** 524,541 ****
      number_addr_bits_mat = num_addr_b_row_dec + _log2(deg_bl_muxing) +
        _log2(deg_sa_mux_l1_non_assoc) + _log2(Ndsam_lev_2);
    }
! 
!   if (is_tag)
    {
!     num_di_b_bank_per_port = tagbits;
!     num_do_b_bank_per_port = g_ip->data_assoc;
    }
    else
    {
!     num_di_b_bank_per_port = g_ip->out_w + g_ip->data_assoc;
!     num_do_b_bank_per_port = g_ip->out_w;
    }
! 
    if ((!is_tag) && (g_ip->data_assoc > 1) && (!g_ip->fast_access))
    {
      number_way_select_signals_mat = g_ip->data_assoc;
--- 671,708 ----
      number_addr_bits_mat = num_addr_b_row_dec + _log2(deg_bl_muxing) +
        _log2(deg_sa_mux_l1_non_assoc) + _log2(Ndsam_lev_2);
    }
!   //cout << "9-0 dynp here \n";
!   if (!(fully_assoc ||pure_cam))
    {
! 	  if (is_tag)
! 	  {
! 		  num_di_b_bank_per_port = tagbits;
! 		  num_do_b_bank_per_port = g_ip->data_assoc;
! 	  }
! 	  else
! 	  {
! 		  num_di_b_bank_per_port = g_ip->out_w + g_ip->data_assoc;
! 		  num_do_b_bank_per_port = g_ip->out_w;
! 	  }
    }
    else
    {
! 	  if (fully_assoc)
! 	  {
! 		  num_di_b_bank_per_port = g_ip->out_w + tagbits;//TODO: out_w or block_sz?
! 		  num_si_b_bank_per_port = tagbits;
! 		  num_do_b_bank_per_port = g_ip->out_w + tagbits;
! 		  num_so_b_bank_per_port = g_ip->out_w;
! 	  }
! 	  else
! 	  {
! 		  num_di_b_bank_per_port = tagbits;
! 		  num_si_b_bank_per_port = tagbits;
! 		  num_do_b_bank_per_port = tagbits;
! 		  num_so_b_bank_per_port = int(ceil(log2(num_r_subarray)) + ceil(log2(num_subarrays)));
! 	  }
    }
!   //cout << "9 dynp here \n";
    if ((!is_tag) && (g_ip->data_assoc > 1) && (!g_ip->fast_access))
    {
      number_way_select_signals_mat = g_ip->data_assoc;
***************
*** 549,556 ****
      num_di_b_mat += (int) (ceil(num_di_b_mat / num_bits_per_ecc_b_));
      num_di_b_subbank += (int) (ceil(num_di_b_subbank / num_bits_per_ecc_b_));
      num_do_b_subbank += (int) (ceil(num_do_b_subbank / num_bits_per_ecc_b_));
!   }
  
    is_valid = true;
  }
  
--- 715,731 ----
      num_di_b_mat += (int) (ceil(num_di_b_mat / num_bits_per_ecc_b_));
      num_di_b_subbank += (int) (ceil(num_di_b_subbank / num_bits_per_ecc_b_));
      num_do_b_subbank += (int) (ceil(num_do_b_subbank / num_bits_per_ecc_b_));
! 	  num_di_b_bank_per_port += (int) (ceil(num_di_b_bank_per_port / num_bits_per_ecc_b_));
! 	  num_do_b_bank_per_port += (int) (ceil(num_do_b_bank_per_port / num_bits_per_ecc_b_));
  
+ 	  num_so_b_mat += (int) (ceil(num_so_b_mat / num_bits_per_ecc_b_));
+ 	  num_si_b_mat += (int) (ceil(num_si_b_mat / num_bits_per_ecc_b_));
+ 	  num_si_b_subbank += (int) (ceil(num_si_b_subbank / num_bits_per_ecc_b_));
+ 	  num_so_b_subbank += (int) (ceil(num_so_b_subbank / num_bits_per_ecc_b_));
+ 	  num_si_b_bank_per_port += (int) (ceil(num_si_b_bank_per_port / num_bits_per_ecc_b_));
+ 	  num_so_b_bank_per_port += (int) (ceil(num_so_b_bank_per_port / num_bits_per_ecc_b_));
+   }
+ //cout << "7 dynp valid true \n";
    is_valid = true;
  }
  
diff -crB pcacti_xml/parameter.h FN-CACTI/parameter.h
*** pcacti_xml/parameter.h	2014-07-03 09:48:42.000000000 +0200
--- FN-CACTI/parameter.h	2023-04-05 13:30:24.827099000 +0200
***************
*** 58,64 ****
--- 58,66 ----
      double P_fin; // in um, for FinFET devices. -Alireza
      double H_fin; // in um, for FinFET devices. -Alireza
      double T_si;  // in um, for FinFET devices. -Alireza
+     double W_fin;	//Divya added
      double C_g_ideal;
+ 
      double C_fringe;
      double C_overlap;
      double C_junc;  // C_junc_area
***************
*** 76,92 ****
      double C_ox;
      double t_ox;
      double n_to_p_eff_curr_drv_ratio;
  
!     DeviceType(): P_fin(0), H_fin(0), T_si(0), C_g_ideal(0),
                    C_fringe(0), C_overlap(0), C_junc(0), C_junc_sidewall(0),
                    l_phy(0), l_elec(0), R_nch_on(0), R_pch_on(0), Vdd(0), Vth(0),
                    I_on_n(0), I_on_p(0), I_off_n(0), I_off_p(0),
!                   C_ox(0), t_ox(0), n_to_p_eff_curr_drv_ratio(0) { };
      void reset()
      {
        P_fin     = 0;
        H_fin     = 0;
        T_si      = 0;
        C_g_ideal = 0;
        C_fringe  = 0;
        C_overlap = 0;
--- 79,99 ----
      double C_ox;
      double t_ox;
      double n_to_p_eff_curr_drv_ratio;
+     double long_channel_leakage_reduction; //divya: dummy value, set to 0
+     double Vcc_min;//divya: dummy value: allowed min vcc; for memory cell it is the lowest vcc for data retention. for logic it is the vcc to balance the leakage reduction and wakeup latency
  
!     DeviceType(): P_fin(0), H_fin(0), T_si(0), W_fin(0), C_g_ideal(0),
                    C_fringe(0), C_overlap(0), C_junc(0), C_junc_sidewall(0),
                    l_phy(0), l_elec(0), R_nch_on(0), R_pch_on(0), Vdd(0), Vth(0),
                    I_on_n(0), I_on_p(0), I_off_n(0), I_off_p(0),
!                   C_ox(0), t_ox(0), n_to_p_eff_curr_drv_ratio(0),
! 				  long_channel_leakage_reduction(0), Vcc_min(0) { };
      void reset()
      {
        P_fin     = 0;
        H_fin     = 0;
        T_si      = 0;
+       W_fin 	= 0;	//Divya added
        C_g_ideal = 0;
        C_fringe  = 0;
        C_overlap = 0;
***************
*** 104,110 ****
        C_ox      = 0;
        t_ox      = 0;
        n_to_p_eff_curr_drv_ratio = 0;
!     }
  
      void display(uint32_t indent = 0);
    };
--- 111,119 ----
        C_ox      = 0;
        t_ox      = 0;
        n_to_p_eff_curr_drv_ratio = 0;
!       long_channel_leakage_reduction = 0;
!       Vcc_min   = 0;
!      }
  
      void display(uint32_t indent = 0);
    };
***************
*** 114,119 ****
--- 123,133 ----
      double pitch;
      double R_per_um;
      double C_per_um;
+     double horiz_dielectric_constant;
+     double vert_dielectric_constant;
+     double aspect_ratio;
+     double miller_value;
+     double ild_thickness;
  
      InterconnectType(): pitch(0), R_per_um(0), C_per_um(0) { };
  
***************
*** 122,127 ****
--- 136,146 ----
        pitch = 0;
        R_per_um = 0;
        C_per_um = 0;
+       horiz_dielectric_constant = 0;
+       vert_dielectric_constant = 0;
+       aspect_ratio = 0;
+       miller_value = 0;
+       ild_thickness = 0;
      }
  
      void display(uint32_t indent = 0);
***************
*** 153,158 ****
--- 172,198 ----
      void display(uint32_t indent = 0);
    };
  
+   //Divya 17-11-2021 for mcpat
+   class ScalingFactor
+   {
+    public:
+     double logic_scaling_co_eff;
+     double core_tx_density;
+     double long_channel_leakage_reduction;
+ 
+     ScalingFactor(): logic_scaling_co_eff(0), core_tx_density(0),
+     long_channel_leakage_reduction(0) { };
+ 
+     void reset()
+     {
+       logic_scaling_co_eff= 0;
+       core_tx_density = 0;
+       long_channel_leakage_reduction= 0;
+     }
+ 
+     void display(uint32_t indent = 0);
+   };
+ 
    double ram_wl_stitching_overhead_;
    double min_w_nmos_;
    double max_w_nmos_;
***************
*** 198,209 ****
--- 238,257 ----
    double HPOWERRAIL;
    double cell_h_def;
  
+   //divya 17-11-2021 begin
+   double chip_layout_overhead;
+   double macro_layout_overhead;
+   double sckt_co_eff;
+   //divya end
+   double fringe_cap;
+ 
    uint64_t h_dec;
  
    DeviceType sram_cell;   // SRAM cell transistor
    DeviceType dram_acc;    // DRAM access transistor
    DeviceType dram_wl;     // DRAM wordline transistor
    DeviceType peri_global; // peripheral global
+   DeviceType cam_cell;   // SRAM cell transistor
  
    InterconnectType wire_local;
    InterconnectType wire_inside_mat;
***************
*** 214,221 ****
--- 262,272 ----
    double aspect_ratio;
    double miller_value;
   
+   ScalingFactor scaling_factor;
+ 
    MemoryType sram;
    MemoryType dram;
+   MemoryType cam;
  
    void display(uint32_t indent = 0);
  
***************
*** 227,245 ****
--- 278,307 ----
      vpp            = 0;
      Vbit_sense_min = 0; // Alireza2
  
+     sense_delay               = 0;
+     sense_dy_power            = 0;
+     fringe_cap                = 0;
+ 
      dram_cell_I_off_worst_case_len_temp = 0;
  
      sram_cell.reset();
      dram_acc.reset();
      dram_wl.reset();
      peri_global.reset();
+     cam_cell.reset();
  
      wire_local.reset();
      wire_inside_mat.reset();
      wire_outside_mat.reset();
+     scaling_factor.reset();
  
      sram.reset();
      dram.reset();
+     cam.reset();
+ 
+     chip_layout_overhead  = 0;
+     macro_layout_overhead = 0;
+     sckt_co_eff           = 0;
    }
  };
  
***************
*** 250,261 ****
--- 312,326 ----
    public:
      bool is_tag;
      bool pure_ram;
+     bool pure_cam;
+ 	bool fully_assoc;
      int tagbits;
      int num_subarrays;  // only for leakage computation  -- the number of subarrays per bank
      int num_mats;       // only for leakage computation  -- the number of mats per bank
      double Nspd;
      int Ndwl;
      int Ndbl;
+     int Ndcm;
      int deg_bl_muxing; 
      int deg_senseamp_muxing_non_associativity; 
      int Ndsam_lev_1;
***************
*** 266,278 ****
      int num_do_b_bank_per_port;
      int num_di_b_mat;
      int num_do_b_mat;
      int num_do_b_subbank;
!     int number_way_select_signals_mat;
      int num_act_mats_hor_dir;
      bool is_dram;
      double V_b_sense;
      int num_r_subarray;
      int num_c_subarray;
      int num_mats_h_dir;
      int num_mats_v_dir;
      uint32_t ram_cell_tech_type;
--- 331,358 ----
      int num_do_b_bank_per_port;
      int num_di_b_mat;
      int num_do_b_mat;
+     int num_di_b_subbank;
      int num_do_b_subbank;
! 
!     int num_si_b_mat;
!     int num_so_b_mat;
!     int num_si_b_subbank;
!     int num_so_b_subbank;
! 	int num_si_b_bank_per_port;
! 	int num_so_b_bank_per_port;
! 
! 	int number_way_select_signals_mat;
      int num_act_mats_hor_dir;
+ 
+     int num_act_mats_hor_dir_sl;
      bool is_dram;
      double V_b_sense;
      int num_r_subarray;
      int num_c_subarray;
+     int tag_num_r_subarray;//sheng: fully associative cache tag and data must be computed together, data and tag must be separate
+     int tag_num_c_subarray;
+     int data_num_r_subarray;
+     int data_num_c_subarray;
      int num_mats_h_dir;
      int num_mats_v_dir;
      uint32_t ram_cell_tech_type;
***************
*** 282,287 ****
--- 362,368 ----
      DynamicParameter(
          bool         is_tag,
          int          pure_ram,
+         int          pure_cam_,
          double       Nspd,
          unsigned int Ndwl,
          unsigned int Ndbl,
***************
*** 295,303 ****
      unsigned int num_rd_ports;
      unsigned int num_wr_ports;
      unsigned int num_se_rd_ports;  // number of single ended read ports
      unsigned int out_w;// == nr_bits_out
      bool   is_main_mem;
!     Area   cell;
      bool   is_valid;
  };
  
--- 376,385 ----
      unsigned int num_rd_ports;
      unsigned int num_wr_ports;
      unsigned int num_se_rd_ports;  // number of single ended read ports
+     unsigned int num_search_ports;
      unsigned int out_w;// == nr_bits_out
      bool   is_main_mem;
!     Area   cell, cam_cell;
      bool   is_valid;
  };
  
Only in FN-CACTI: pcacti_report.txt
Only in FN-CACTI: .project
diff -crB pcacti_xml/router.cc FN-CACTI/router.cc
*** pcacti_xml/router.cc	2014-07-03 09:49:52.000000000 +0200
--- FN-CACTI/router.cc	2023-04-05 13:29:33.367887000 +0200
***************
*** 45,52 ****
      double flit_size_,
      double vc_buf, /* vc size = vc_buffer_size * flit_size */
      double vc_c,
!     TechnologyParameter::DeviceType *dt
!     ):flit_size(flit_size_), deviceType(dt)
  {
    vc_buffer_size = vc_buf;
    vc_count = vc_c;
--- 45,59 ----
      double flit_size_,
      double vc_buf, /* vc size = vc_buffer_size * flit_size */
      double vc_c,
!     TechnologyParameter::DeviceType *dt,
!     double I_,
!     double O_,
!     double M_
! 
!     ):flit_size(flit_size_), deviceType(dt),
!     I(I_),
!     O(O_),
!     M(M_)
  {
    vc_buffer_size = vc_buf;
    vc_count = vc_c;
***************
*** 143,148 ****
--- 150,160 ----
  {
    DynamicParameter dyn_p;
    dyn_p.is_tag = false;
+   dyn_p.pure_cam    = false;
+   dyn_p.fully_assoc = false;
+   dyn_p.pure_ram    = true;
+   dyn_p.is_dram     = false;
+   dyn_p.is_main_mem = false;
    dyn_p.num_subarrays = 1;
    dyn_p.num_mats = 1;
    dyn_p.Ndbl = 1;
***************
*** 152,177 ****
    dyn_p.deg_senseamp_muxing_non_associativity = 1;
    dyn_p.Ndsam_lev_1 = 1;
    dyn_p.Ndsam_lev_2 = 1;
    dyn_p.number_addr_bits_mat = 8;
    dyn_p.number_way_select_signals_mat = 1;
    dyn_p.num_act_mats_hor_dir = 1;
!   dyn_p.is_dram = false;
    dyn_p.V_b_sense = Vdd; // FIXME check power calc.
!   dyn_p.ram_cell_tech_type = 
      dyn_p.num_r_subarray = (int) vc_buffer_size;
    dyn_p.num_c_subarray = (int) flit_size * (int) vc_count;
    dyn_p.num_mats_h_dir = 1;
    dyn_p.num_mats_v_dir = 1;
    dyn_p.num_do_b_subbank = (int)flit_size;
    dyn_p.num_do_b_mat = (int) flit_size;
  
    dyn_p.use_inp_params = 1;
    dyn_p.num_wr_ports = (unsigned int) vc_count;
!   dyn_p.num_rd_ports = (unsigned int) vc_count;
    dyn_p.num_rw_ports = 0;
    dyn_p.num_se_rd_ports =0;
!   dyn_p.out_w = (int) flit_size;
! 
  
    dyn_p.cell.h = g_tp.sram.b_h + 2 * g_tp.wire_outside_mat.pitch * (dyn_p.num_wr_ports + 
        dyn_p.num_rw_ports - 1 + dyn_p.num_rd_ports);
--- 164,197 ----
    dyn_p.deg_senseamp_muxing_non_associativity = 1;
    dyn_p.Ndsam_lev_1 = 1;
    dyn_p.Ndsam_lev_2 = 1;
+   dyn_p.Ndcm = 1;
    dyn_p.number_addr_bits_mat = 8;
    dyn_p.number_way_select_signals_mat = 1;
+   dyn_p.number_subbanks_decode = 0;
    dyn_p.num_act_mats_hor_dir = 1;
! 
    dyn_p.V_b_sense = Vdd; // FIXME check power calc.
!   dyn_p.ram_cell_tech_type = 0;
      dyn_p.num_r_subarray = (int) vc_buffer_size;
    dyn_p.num_c_subarray = (int) flit_size * (int) vc_count;
    dyn_p.num_mats_h_dir = 1;
    dyn_p.num_mats_v_dir = 1;
    dyn_p.num_do_b_subbank = (int)flit_size;
+   dyn_p.num_di_b_subbank = (int)flit_size;
+   dyn_p.num_do_b_mat = (int) flit_size;
+   dyn_p.num_di_b_mat = (int) flit_size;
    dyn_p.num_do_b_mat = (int) flit_size;
+   dyn_p.num_di_b_mat = (int) flit_size;
+   dyn_p.num_do_b_bank_per_port = (int) flit_size;
+   dyn_p.num_di_b_bank_per_port = (int) flit_size;
+   dyn_p.out_w = (int) flit_size;
  
    dyn_p.use_inp_params = 1;
    dyn_p.num_wr_ports = (unsigned int) vc_count;
!   dyn_p.num_rd_ports = 1; //(unsigned int) vc_count;//based on Bill Dally's book
    dyn_p.num_rw_ports = 0;
    dyn_p.num_se_rd_ports =0;
!   dyn_p.num_search_ports =0;
  
    dyn_p.cell.h = g_tp.sram.b_h + 2 * g_tp.wire_outside_mat.pitch * (dyn_p.num_wr_ports + 
        dyn_p.num_rw_ports - 1 + dyn_p.num_rd_ports);
***************
*** 202,209 ****
    }
    else {
      crossbar.power.readOp.dynamic = tr_crossbar_power();
!     crossbar.power.readOp.leakage = flit_size * I * O * cmos_Ileak(NTtr*g_tp.min_w_nmos_, 
!         PTtr*min_w_pmos);
    }
  }
  
--- 222,231 ----
    }
    else {
      crossbar.power.readOp.dynamic = tr_crossbar_power();
! //    crossbar.power.readOp.leakage = flit_size * I * O * cmos_Ileak(NTtr*g_tp.min_w_nmos_,
! //        PTtr*min_w_pmos);
!     crossbar.power.readOp.leakage = flit_size * I * O *
!         cmos_Isub_leakage(NTtr*g_tp.min_w_nmos_, PTtr*min_w_pmos, 1, tg);
    }
  }
  
diff -crB pcacti_xml/router.h FN-CACTI/router.h
*** pcacti_xml/router.h	2014-07-03 09:49:46.000000000 +0200
--- FN-CACTI/router.h	2023-04-05 13:30:16.719223000 +0200
***************
*** 62,68 ****
          double flit_size_,
          double vc_buf, /* vc size = vc_buffer_size * flit_size */
          double vc_count,
!         TechnologyParameter::DeviceType *dt = &(g_tp.peri_global));
      ~Router();
  
  
--- 62,72 ----
          double flit_size_,
          double vc_buf, /* vc size = vc_buffer_size * flit_size */
          double vc_count,
!         TechnologyParameter::DeviceType *dt = &(g_tp.peri_global),
!         double I_ = 5,
!         double O_ = 5,
!         double M_ = 0.6);
! 
      ~Router();
  
  
***************
*** 75,80 ****
--- 79,85 ----
      double vc_buffer_size; /* vc size = vc_buffer_size * flit_size */
  
    private:
+ 	TechnologyParameter::DeviceType *deviceType;
      double FREQUENCY; // move this to config file --TODO
      double Cw3(double len);
      double gate_cap(double w);
***************
*** 83,88 ****
--- 88,94 ----
      enum Wire_placement wire_placement;
      //corssbar
      double NTtr, PTtr, wt, ht, I, O, NTi, PTi, NTid, PTid, NTod, PTod, TriS1, TriS2;
+     double M; //network load
      double transmission_buf_inpcap();
      double transmission_buf_outcap();
      double transmission_buf_ctrcap();
***************
*** 110,116 ****
      void get_router_delay();
  
      double min_w_pmos;
-     TechnologyParameter::DeviceType *deviceType;
  
  };
  
--- 116,121 ----
Only in FN-CACTI: .settings
diff -crB pcacti_xml/subarray.cc FN-CACTI/subarray.cc
*** pcacti_xml/subarray.cc	2014-07-03 09:48:34.000000000 +0200
--- FN-CACTI/subarray.cc	2023-04-05 13:30:18.479196000 +0200
***************
*** 42,68 ****
  
  #include <iostream>
  #include <math.h>
  
  #include "subarray.h"
  
  
  Subarray::Subarray(const DynamicParameter & dp_, bool is_fa_):
!   dp(dp_), num_rows(dp.num_r_subarray), num_cols(dp.num_c_subarray), cell(dp.cell), is_fa(is_fa_)
  {
!   if (is_fa == false)
!   {
!     uint32_t ram_num_cells_wl_stitching = 
!       (dp.ram_cell_tech_type == lp_dram)   ? dram_num_cells_wl_stitching_ :
!       (dp.ram_cell_tech_type == comm_dram) ? comm_dram_num_cells_wl_stitching_ : sram_num_cells_wl_stitching_;
! 
!     area.h = cell.h * num_rows;
!     area.w = cell.w * num_cols +
!       ceil(num_cols / ram_num_cells_wl_stitching) * g_tp.ram_wl_stitching_overhead_ +  // stitching overhead
!       (g_ip->add_ecc_b_ ? cell.w * ceil(num_cols / num_bits_per_ecc_b_) : 0);         // ECC overhead
!   }
!   else  // fully associative cache
    {
!     // it is assumed that the transistor size of a CAM cell is linearly scaled from 0.8um process
      double CAM2x2_h_1p = 61 * g_ip->F_sz_um;  // 48.8um in 0.8um process
      double CAM2x2_w_1p = 56 * g_ip->F_sz_um;  // 44.8um in 0.8um process
      double fa_h_incr_per_first_rw_or_wr_port_ = 20 * g_ip->F_sz_um;
--- 42,75 ----
  
  #include <iostream>
  #include <math.h>
+ #include <assert.h>
  
  #include "subarray.h"
  
  
  Subarray::Subarray(const DynamicParameter & dp_, bool is_fa_):
!   dp(dp_), num_rows(dp.num_r_subarray), num_cols(dp.num_c_subarray),
!   num_cols_fa_cam(dp.tag_num_c_subarray), num_cols_fa_ram(dp.data_num_c_subarray),
!   cell(dp.cell), cam_cell(dp.cam_cell), is_fa(is_fa_)
  {
!     if(cell.h < 0) //divya
!   	       cout << "subarray.cc subarray() cell.h : " << cell.h << ", cell.w : " << cell.w << "is_fa : " << is_fa << endl;
! 
!     if (!(is_fa || dp.pure_cam))
!     {
!   	  num_cols +=(g_ip->add_ecc_b_ ? (int)ceil(num_cols / num_bits_per_ecc_b_) : 0);   // ECC overhead
!   	  uint32_t ram_num_cells_wl_stitching =
!   		  (dp.ram_cell_tech_type == lp_dram)   ? dram_num_cells_wl_stitching_ :
!   	  (dp.ram_cell_tech_type == comm_dram) ? comm_dram_num_cells_wl_stitching_ : sram_num_cells_wl_stitching_;
! 
!   	  area.h = cell.h * num_rows;
! 
!   	  area.w = cell.w * num_cols +
!   	  ceil(num_cols / ram_num_cells_wl_stitching) * g_tp.ram_wl_stitching_overhead_;  // stitching overhead
!     }
!   else  // cam fa
    {
! /*    // it is assumed that the transistor size of a CAM cell is linearly scaled from 0.8um process
      double CAM2x2_h_1p = 61 * g_ip->F_sz_um;  // 48.8um in 0.8um process
      double CAM2x2_w_1p = 56 * g_ip->F_sz_um;  // 44.8um in 0.8um process
      double fa_h_incr_per_first_rw_or_wr_port_ = 20 * g_ip->F_sz_um;
***************
*** 147,154 ****
--- 154,183 ----
  
      cell.h = (CAM2x2_h_1p + 2*overhead_h) / 2.0;
      cell.w = (CAM2x2_w_1p + 2*overhead_w - w_contact_) / 2.0;
+ */
+ 	  //should not add dummy row here since the dummy row do not need decoder
+ 	  if (is_fa)// fully associative cache
+ 	  {
+ 		  num_cols_fa_cam  += g_ip->add_ecc_b_ ? (int)ceil(num_cols_fa_cam / num_bits_per_ecc_b_) : 0;
+ 		  num_cols_fa_ram  += (g_ip->add_ecc_b_ ? (int)ceil(num_cols_fa_ram / num_bits_per_ecc_b_) : 0);
+ 		  num_cols = num_cols_fa_cam + num_cols_fa_ram;
+ 	  }
+ 	  else
+ 	  {
+ 		  num_cols_fa_cam  += g_ip->add_ecc_b_ ? (int)ceil(num_cols_fa_cam / num_bits_per_ecc_b_) : 0;
+ 		  num_cols_fa_ram  = 0;
+ 		  num_cols = num_cols_fa_cam;
+ 	  }
+ 
+ 	  area.h = cam_cell.h * (num_rows + 1);//height of subarray is decided by CAM array. blank space in sram array are filled with dummy cells
+ 	  area.w = cam_cell.w * num_cols_fa_cam + cell.w * num_cols_fa_ram
+ 	  + ceil((num_cols_fa_cam + num_cols_fa_ram) / sram_num_cells_wl_stitching_)*g_tp.ram_wl_stitching_overhead_
+ 	  + 16*g_tp.wire_local.pitch //the overhead for the NAND gate to connect the two halves
+ 	  + 128*g_tp.wire_local.pitch;//the overhead for the drivers from matchline to wordline of RAM
    }
  
+     assert(area.h>0);
+     assert(area.w>0);
    compute_C();
  }
  
***************
*** 162,168 ****
  
  double Subarray::get_total_cell_area()
  {
!   return cell.get_area() * num_rows * num_cols;
  }
  
  
--- 191,209 ----
  
  double Subarray::get_total_cell_area()
  {
! //	cout << dp.is_tag << ", cell.h :" << cell.h << ", cell.w : " << cell.w << ", cell_area : " << cell.get_area() << endl;
! //  return cell.get_area() * num_rows * num_cols;
!     if (!(is_fa || dp.pure_cam))
! 	  return (cell.get_area() * num_rows * num_cols);
!     else if (is_fa)
!     { //for FA, this area includes the dummy cells in SRAM arrays.
!       //return (cam_cell.get_area()*(num_rows+1)*(num_cols_fa_cam + num_cols_fa_ram));
!       //cout<<"diff" <<cam_cell.get_area()*(num_rows+1)*(num_cols_fa_cam + num_cols_fa_ram)- cam_cell.h*(num_rows+1)*(cam_cell.w*num_cols_fa_cam + cell.w*num_cols_fa_ram)<<endl;
!       return (cam_cell.h*(num_rows+1)*(cam_cell.w*num_cols_fa_cam + cell.w*num_cols_fa_ram));
!     }
!     else
!       return (cam_cell.get_area()*(num_rows+1)*num_cols_fa_cam );
! 
  }
  
  
***************
*** 170,176 ****
  void Subarray::compute_C()
  {
    double c_w_metal = cell.w * g_tp.wire_local.C_per_um;
! //  double r_w_metal = cell.w * g_tp.wire_local.R_per_um;
    double C_b_metal = cell.h * g_tp.wire_local.C_per_um;
    double C_b_row_drain_C;
    C_rwl = 0; // Alireza
--- 211,217 ----
  void Subarray::compute_C()
  {
    double c_w_metal = cell.w * g_tp.wire_local.C_per_um;
!   double r_w_metal = cell.w * g_tp.wire_local.R_per_um;
    double C_b_metal = cell.h * g_tp.wire_local.C_per_um;
    double C_b_row_drain_C;
    C_rwl = 0; // Alireza
***************
*** 191,200 ****
    }
    else
    {
!     C_rwl = (gate_C_pass(g_tp.sram.cell_rd_a_w, 0, false, true) + c_w_metal) * num_cols; // Alireza
!     C_wl = (gate_C_pass(g_tp.sram.cell_a_w, (g_tp.sram.b_w-2*g_tp.sram.cell_a_w)/2.0, false, true)*2 + c_w_metal) * num_cols;
!     C_b_row_drain_C = drain_C_(g_tp.sram.cell_a_w, NCH, 1, 0, cell.w, false, true) / 2.0;  // due to shared contact
!     C_bl = num_rows * (C_b_row_drain_C + C_b_metal);
    }
  }
  
--- 232,297 ----
    }
    else
    {
! 	  if (!(is_fa ||dp.pure_cam))
! 	 {
! 			C_rwl = (gate_C_pass(g_tp.sram.cell_rd_a_w, 0, false, true) + c_w_metal) * num_cols; // Alireza
! 			C_wl = (gate_C_pass(g_tp.sram.cell_a_w, (g_tp.sram.b_w-2*g_tp.sram.cell_a_w)/2.0, false, true)*2 + c_w_metal) * num_cols;
! 			C_b_row_drain_C = drain_C_(g_tp.sram.cell_a_w, NCH, 1, 0, cell.w, false, true) / 2.0;  // due to shared contact
! 
! 			if(ceil(g_tp.sram.cell_rd_a_w/g_tp.min_w_nmos_) > 1)
! 				cout << "Subarray::compute_C():: gate_C_pass : g_tp.sram.cell_rd_a_w : "<< g_tp.sram.cell_rd_a_w << ", g_tp.min_w_nmos_ : "  << g_tp.min_w_nmos_ << endl;
! 
! 			if(ceil(g_tp.sram.cell_a_w/g_tp.min_w_nmos_) > 1)
! 					cout << "Subarray::compute_C():: gate_C_pass : g_tp.sram.cell_a_w : "<< g_tp.sram.cell_a_w << ", g_tp.min_w_nmos_ : "  << g_tp.min_w_nmos_ << endl;
! 
! 			if(ceil(g_tp.sram.cell_a_w/g_tp.min_w_nmos_) > 1)
! 					cout << "Subarray::compute_C():: drain_C_ : g_tp.sram.cell_a_w : "<< g_tp.sram.cell_a_w << ", g_tp.min_w_nmos_ : "  << g_tp.min_w_nmos_ << endl;
! 
! 
! 			C_bl = num_rows * (C_b_row_drain_C + C_b_metal);
! 	 }
! 	  else
! 	  {
! 			 //Following is wordline not matchline
! 			 //CAM portion
! 			 c_w_metal = cam_cell.w * g_tp.wire_local.C_per_um;
! 			 r_w_metal = cam_cell.w * g_tp.wire_local.R_per_um;
! 	         C_wl_cam = (gate_C_pass(g_tp.cam.cell_a_w, (g_tp.cam.b_w-2*g_tp.cam.cell_a_w)/2.0, false, true)*2 +
! 					  c_w_metal) * num_cols_fa_cam;
! 	         R_wl_cam = (r_w_metal) * num_cols_fa_cam;
! 
! 	         if (!dp.pure_cam)
! 	         {
! 	        	 //RAM portion
! 	        	 c_w_metal = cell.w * g_tp.wire_local.C_per_um;
! 	        	 r_w_metal = cell.w * g_tp.wire_local.R_per_um;
! 	        	 C_wl_ram = (gate_C_pass(g_tp.sram.cell_a_w, (g_tp.sram.b_w-2*g_tp.sram.cell_a_w)/2.0, false, true)*2 +
! 	        			 c_w_metal) * num_cols_fa_ram;
! 	        	 R_wl_ram = (r_w_metal) * num_cols_fa_ram;
! 	         }
! 	         else
! 	         {
! 	        	 C_wl_ram = R_wl_ram =0;
! 	         }
! 	         C_wl = C_wl_cam + C_wl_ram;
! 	         C_wl += (16+128)*g_tp.wire_local.pitch*g_tp.wire_local.C_per_um;
! 
! 	         R_wl = R_wl_cam + R_wl_ram;
! 	         R_wl += (16+128)*g_tp.wire_local.pitch*g_tp.wire_local.R_per_um;
! 
! 	         //there are two ways to write to a FA,
! 	         //1) Write to CAM array then force a match on match line to active the corresponding wordline in RAM;
! 	         //2) using separate wordline for read/write and search in RAM.
! 	         //We are using the second approach.
! 
! 	         //Bitline CAM portion This is bitline not searchline. We assume no sharing between bitline and searchline according to SUN's implementations.
! 	         C_b_metal = cam_cell.h * g_tp.wire_local.C_per_um;
! 	         C_b_row_drain_C = drain_C_(g_tp.cam.cell_a_w, NCH, 1, 0, cam_cell.w, false, true) / 2.0;  // due to shared contact
! 	         C_bl_cam = (num_rows+1) * (C_b_row_drain_C + C_b_metal);
! 	         //height of subarray is decided by CAM array. blank space in sram array are filled with dummy cells
! 	         C_b_row_drain_C = drain_C_(g_tp.sram.cell_a_w, NCH, 1, 0, cell.w, false, true) / 2.0;  // due to shared contact
! 	         C_bl = (num_rows +1) * (C_b_row_drain_C + C_b_metal);
! 	  }
    }
  }
  
diff -crB pcacti_xml/subarray.h FN-CACTI/subarray.h
*** pcacti_xml/subarray.h	2014-07-03 09:46:40.000000000 +0200
--- FN-CACTI/subarray.h	2023-04-05 13:30:10.515318000 +0200
***************
*** 59,70 ****
      double  get_total_cell_area();
      int32_t num_rows;
      int32_t num_cols;
!     Area    cell;
  
      bool    is_fa;
      double  C_wl;  // Alireza: this will serve as the capacitance of write word line (WWL) for 8T SRAM cell
      double  C_rwl; // Alireza: capacitance of read word line (RWL) for 8T SRAM cell
      double  C_bl;
    private:
  
      void compute_C();  // compute bitline and wordline capacitance
--- 59,75 ----
      double  get_total_cell_area();
      int32_t num_rows;
      int32_t num_cols;
!     int32_t num_cols_fa_cam;
!     int32_t num_cols_fa_ram;
!     Area    cell, cam_cell;
  
      bool    is_fa;
      double  C_wl;  // Alireza: this will serve as the capacitance of write word line (WWL) for 8T SRAM cell
      double  C_rwl; // Alireza: capacitance of read word line (RWL) for 8T SRAM cell
      double  C_bl;
+     double  C_wl_cam, C_wl_ram;
+     double  R_wl, R_wl_cam, R_wl_ram;
+     double  C_bl_cam;
    private:
  
      void compute_C();  // compute bitline and wordline capacitance
diff -crB pcacti_xml/technology.cc FN-CACTI/technology.cc
*** pcacti_xml/technology.cc	2014-07-03 09:49:14.000000000 +0200
--- FN-CACTI/technology.cc	2023-04-05 13:29:39.767789000 +0200
***************
*** 42,48 ****
  #include <iostream> // Alireza
  #include "basic_circuit.h"
  #include "parameter.h"
! #include "xmlParser.h"	// Majid
  using namespace std; // Alireza
  
  
--- 42,48 ----
  #include <iostream> // Alireza
  #include "basic_circuit.h"
  #include "parameter.h"
! //#include "xmlParser.h"	// Majid
  using namespace std; // Alireza
  
  
***************
*** 67,79 ****
  }
  
  
! void init_tech_params(double technology, bool is_tag)
  {
  	int    iter, tech, tech_lo, tech_hi;
  	double curr_alpha, curr_vpp;
! 	double aspect_ratio, wire_width, wire_thickness, wire_spacing, barrier_thickness, dishing_thickness,
  			 alpha_scatter, ild_thickness, miller_value = 1.5, horiz_dielectric_constant, vert_dielectric_constant,
  			 fringe_cap, pmos_to_nmos_sizing_r;
  	double curr_vdd_dram_cell, curr_v_th_dram_access_transistor, curr_I_on_dram_cell, curr_c_dram_cell;
  
  	// TO DO: remove 'ram_cell_tech_type'.
--- 67,84 ----
  }
  
  
! void init_tech_params(double technology, double wire_technology, bool is_tag) //Divya added wire_technology
  {
  	int    iter, tech, tech_lo, tech_hi;
  	double curr_alpha, curr_vpp;
! /*	double aspect_ratio, wire_width, wire_thickness, wire_spacing, barrier_thickness, dishing_thickness,
  			 alpha_scatter, ild_thickness, miller_value = 1.5, horiz_dielectric_constant, vert_dielectric_constant,
  			 fringe_cap, pmos_to_nmos_sizing_r;
+ */
+ 	  double wire_width, wire_thickness, wire_spacing,
+ 	         fringe_cap, pmos_to_nmos_sizing_r;
+ 	  double barrier_thickness, dishing_thickness, alpha_scatter;
+ 
  	double curr_vdd_dram_cell, curr_v_th_dram_access_transistor, curr_I_on_dram_cell, curr_c_dram_cell;
  
  	// TO DO: remove 'ram_cell_tech_type'.
***************
*** 81,86 ****
--- 86,92 ----
  	//uint32_t peri_global_tech_type = (is_tag) ? g_ip->tag_arr_peri_global_tech_type : g_ip->data_arr_peri_global_tech_type;
  
  	technology  = technology * 1000.0;  // in the unit of nm
+ 	wire_technology = wire_technology * 1000.0;	//in the unit of nm //Divya added
  
  	// initialize parameters
  	g_tp.reset();
***************
*** 91,107 ****
--- 97,118 ----
  			 curr_Wmemcellpmos_sram, curr_Wmemcellnmos_sram, curr_Wmemcellrda_sram = 0,
  			 curr_Wmemcellrdiso_sram = 0, curr_area_cell_sram, curr_asp_ratio_cell_sram,
  			 curr_I_off_dram_cell_worst_case_length_temp;
+    double curr_Wmemcella_cam, curr_Wmemcellpmos_cam, curr_Wmemcellnmos_cam, curr_area_cell_cam,//Sheng: CAM data
+ 	         curr_asp_ratio_cell_cam;
  	double SENSE_AMP_D, SENSE_AMP_P; // s, J
  	double area_cell_dram = 0;
  	double asp_ratio_cell_dram = 0;
  	double area_cell_sram = 0;
  	double asp_ratio_cell_sram = 0;
+ 	  double area_cell_cam = 0;
+ 	  double asp_ratio_cell_cam = 0;
  	double mobility_eff_periph_global = 0;
  	double Vdsat_periph_global = 0;
  	double width_dram_access_transistor;
  
  	/***** Alireza2 - BEGIN *****/
  	// Alireza: 5, 7, 14, 16, and 22 are added
+ //	cout << "tech: " << technology << endl;
  	if ( technology == 90 ) {        // 90nm CMOS
  		tech_lo = 90; tech_hi = 90;
  	} else if ( technology == 65 ) { // 65nm CMOS
***************
*** 136,163 ****
  		cout << "ERROR: Invalid technology node!" << endl;
  		exit(0);
  	}
- 	/****** Alireza2 - END ******/
- 
  
! 	//---------- Majid - BEGIN ----------
! 	double Lphy_dram;
  	double vdd_dram;
  	double c_ox_dram, c_fringe_dram, c_junc_dram;
  	double I_on_n_dram, I_on_p_dram, I_off_n_dram, I_off_p_dram;
  	
  	double vdd_cell, vdd_peri;
  	double Lphy, Xj, delta_L, Lelec, t_ox;
  	double p_fin, h_fin, t_si;
  	double v_th, Vdsat;
  	double c_junc, c_junc_sidewall, c_junc_sidewall_gate;
! 	double c_ox, c_g_ideal, c_fringe;
  	double I_on_n, I_on_p, I_off_n, I_off_p;
  	double Rnchannelon, Rpchannelon;
- 	double n_to_p_eff_curr_drv_ratio;
  	double vbit_sense_min;
  	double mobility_eff, gmp_to_gmn_multiplier;
! 	//---------- Majid - END ------------
!   
    
  	for (iter = 0; iter <= 1; ++iter) {
  		// linear interpolation
--- 147,183 ----
  		cout << "ERROR: Invalid technology node!" << endl;
  		exit(0);
  	}
  
! 	double Lphy_dram, Lelec_dram;
  	double vdd_dram;
  	double c_ox_dram, c_fringe_dram, c_junc_dram;
  	double I_on_n_dram, I_on_p_dram, I_off_n_dram, I_off_p_dram;
  	
+ 	double t_ox_dram, v_th_dram, mobility_eff_dram, Vdsat_dram, c_g_ideal_dram;
+ 	double nmos_effective_resistance_multiplier, n_to_p_eff_curr_drv_ratio, gmp_to_gmn_multiplier_dram;
+ //    double Rnchannelon_dram, Rpchannelon_dram;
+ 
  	double vdd_cell, vdd_peri;
  	double Lphy, Xj, delta_L, Lelec, t_ox;
  	double p_fin, h_fin, t_si;
+ 	double w_fin;	//newly added by Divya.
  	double v_th, Vdsat;
  	double c_junc, c_junc_sidewall, c_junc_sidewall_gate;
! 	double c_ox, c_g_ideal, c_fringe, c_gate; //c_gate added newly by Divya
  	double I_on_n, I_on_p, I_off_n, I_off_p;
  	double Rnchannelon, Rpchannelon;
  	double vbit_sense_min;
  	double mobility_eff, gmp_to_gmn_multiplier;
! 	double I_on_n_to_I_on_p_ratio; //newly added by Divya
! 	double Ioffs[5];
! 
! 	double vdd, vdd_real, alpha_power_law;	//divya adding for 45-nm
! 	double curr_logic_scaling_co_eff = 0;//This is based on the reported numbers of Intel Merom 65nm, Penryn45nm and IBM cell 90/65/45 date
! 	double curr_core_tx_density = 0;//this is density per um^2; 90, ...22nm based on Intel Penryn
! 	double curr_chip_layout_overhead = 0;
! 	double curr_macro_layout_overhead = 0;
! 	double curr_sckt_co_eff = 0;
! 
    
  	for (iter = 0; iter <= 1; ++iter) {
  		// linear interpolation
***************
*** 178,553 ****
  		}
  		
  		double lambda_um = (double)tech / 2.0 / 1000.0; // Alireza: lambda in um
! 		
! 		
!     /***** Alireza - BEGIN *****/
!     // Standard 14nm (gate length) Planar CMOS based on TCAD.
!     // Source: Shuang Chen, USC.
!     if (tech == 14 && !g_ip->is_finfet) {
!       Lphy_dram = 0.014;
!       curr_vdd_dram_cell = ((g_ip->is_near_threshold) ? 0.55 : 0.8);
!       c_ox_dram = 3.52e-14;
!       c_fringe_dram = 0.8e-16;
!       c_junc_dram = 0.5e-15;
!       I_on_n_dram = ((g_ip->is_near_threshold) ? 1.155e-04 : 8.367e-04);
!       I_on_p_dram = ((g_ip->is_near_threshold) ? 8.618e-05 : 5.012e-04);
!       I_off_n_dram = ((g_ip->is_near_threshold) ? 3.282e-08 : 9.662e-08);
!       I_off_p_dram = ((g_ip->is_near_threshold) ? 3.460e-08 : 1.095e-07);
!     }
!     
!     // Standard 7nm (gate length) FinFET based on TCAD.
!     // Source: Shuang Chen, USC.
!     if (tech == 7 && g_ip->is_finfet) {
!       Lphy_dram = 0.007;
!       curr_vdd_dram_cell = ((g_ip->is_near_threshold) ? 0.3 : 0.45);
!       c_ox_dram = 4.73e-14;
!       c_fringe_dram = 0.8e-16;
!       c_junc_dram = 0.5e-15;
! 		I_on_n_dram = ((g_ip->is_near_threshold) ? 2.845e-04 : 1.716e-03);
!       I_on_p_dram = ((g_ip->is_near_threshold) ? 2.610e-04 : 1.075e-03);
!       I_off_n_dram = ((g_ip->is_near_threshold) ? 6.355e-08 : 6.890e-08);
!       I_off_p_dram = ((g_ip->is_near_threshold) ? 1.027e-07 : 1.040e-07);
!     }
!     /****** Alireza - END ******/
! 	 
! 	 
! 		//-------------------- cell parameters begin --------------------------
! 		//---------- Majid - BEGIN ----------
! 		char temp_var[1000];
! 		XMLNode root_node, geometry_node, voltages_node, cap_node, senseAmp_node;
! 		XMLNode NMOS_ONcurrents_node, PMOS_ONcurrents_node, NMOS_OFFcurrents_node, PMOS_OFFcurrents_node;
! 		
! 		if ( is_tag ) {
! 			root_node = XMLNode::openFileHelper(g_ip->tag_array_cell_tech_file,"device_definition");
! 		} else {
! 			root_node = XMLNode::openFileHelper(g_ip->data_array_cell_tech_file,"device_definition");
! 		}
! 		
! 		geometry_node = root_node.getChildNode("geometries");
! 		strcpy(temp_var,geometry_node.getChildNode("Lphy").getText(0));
! 		sscanf(temp_var, "%lf", &(Lphy));
! 		strcpy(temp_var,geometry_node.getChildNode("Xj").getText(0));
! 		sscanf(temp_var, "%lf", &(Xj));
! 		strcpy(temp_var,geometry_node.getChildNode("t_ox").getText(0));
! 		sscanf(temp_var, "%lf", &(t_ox));
! 		if ( g_ip->is_finfet ) {
! 			strcpy(temp_var,geometry_node.getChildNode("FinFET").getChildNode("t_si").getText(0));
! 			sscanf(temp_var, "%lf", &(t_si));
! 			strcpy(temp_var,geometry_node.getChildNode("FinFET").getChildNode("h_fin").getText(0));
! 			sscanf(temp_var, "%lf", &(h_fin));
! 			if ( !geometry_node.getChildNode("FinFET").getChildNode("p_fin").isEmpty() ) {
! 				strcpy(temp_var,geometry_node.getChildNode("FinFET").getChildNode("p_fin").getText(0));
! 				sscanf(temp_var, "%lf", &(p_fin));
! 			} else {
! 				p_fin = (2 * lambda_um) + t_si;
  			}
- 		}
- 		
- 		voltages_node = root_node.getChildNode("voltages");
- 		strcpy(temp_var,voltages_node.getChildNode("v_th").getText(0));
- 		sscanf(temp_var, "%lf", &(v_th));
- 		if ( g_ip->is_near_threshold ) {
- 			strcpy(temp_var,voltages_node.getChildNode("vdd").getChildNode("near_threshold").getText(0));
- 			sscanf(temp_var, "%lf", &(vdd_cell));
- 		} else {
- 			strcpy(temp_var,voltages_node.getChildNode("vdd").getChildNode("super_threshold").getText(0));
- 			sscanf(temp_var, "%lf", &(vdd_cell));
- 		}
- 		
- 		cap_node = root_node.getChildNode("capacitances");
- 		strcpy(temp_var,cap_node.getChildNode("c_ox").getText(0));
- 		sscanf(temp_var, "%lf", &(c_ox));
- 		strcpy(temp_var,cap_node.getChildNode("c_junc_sidewall").getText(0));
- 		sscanf(temp_var, "%lf", &(c_junc_sidewall));
- 		strcpy(temp_var,cap_node.getChildNode("c_junc_sidewall_gate").getText(0));
- 		sscanf(temp_var, "%lf", &(c_junc_sidewall_gate));
- 		strcpy(temp_var,cap_node.getChildNode("c_junc").getText(0));
- 		sscanf(temp_var, "%lf", &(c_junc));
- 		strcpy(temp_var,cap_node.getChildNode("c_fringe").getText(0));
- 		sscanf(temp_var, "%lf", &(c_fringe));
- 		
- 		senseAmp_node = root_node.getChildNode("sense_amplifier");
- 		if ( g_ip->is_near_threshold ) {
- 			strcpy(temp_var,senseAmp_node.getChildNode("delay").getChildNode("near_threshold").getText(0));
- 			sscanf(temp_var, "%lf", &(SENSE_AMP_D));
- 			strcpy(temp_var,senseAmp_node.getChildNode("energy").getChildNode("near_threshold").getText(0));
- 			sscanf(temp_var, "%lf", &(SENSE_AMP_P));
- 		} else {
- 			strcpy(temp_var,senseAmp_node.getChildNode("delay").getChildNode("super_threshold").getText(0));
- 			sscanf(temp_var, "%lf", &(SENSE_AMP_D));
- 			strcpy(temp_var,senseAmp_node.getChildNode("energy").getChildNode("super_threshold").getText(0));
- 			sscanf(temp_var, "%lf", &(SENSE_AMP_P));
- 		}
  
! 		char temperature[10];
! 		sprintf(temperature,"%d",g_ip->temp);
! 		NMOS_ONcurrents_node = root_node.getChildNode("currents").getChildNode("ON_current").getChildNode("NMOS");
! 		if ( g_ip->is_near_threshold ) {
! 			strcpy(temp_var,NMOS_ONcurrents_node.getChildNode("near_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 			sscanf(temp_var, "%lf", &(I_on_n));
! 		} else {
! 			strcpy(temp_var,NMOS_ONcurrents_node.getChildNode("super_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 			sscanf(temp_var, "%lf", &(I_on_n));
! 		}
  
! 		PMOS_ONcurrents_node = root_node.getChildNode("currents").getChildNode("ON_current").getChildNode("PMOS");
! 		if ( g_ip->is_near_threshold ) {
! 			strcpy(temp_var,PMOS_ONcurrents_node.getChildNode("near_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 			sscanf(temp_var, "%lf", &(I_on_p));
! 		} else {
! 			strcpy(temp_var,PMOS_ONcurrents_node.getChildNode("super_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 			sscanf(temp_var, "%lf", &(I_on_p));
! 		}
  
! 		NMOS_OFFcurrents_node = root_node.getChildNode("currents").getChildNode("OFF_current").getChildNode("NMOS");
! 		if ( g_ip->is_near_threshold ) {
! 			strcpy(temp_var,NMOS_OFFcurrents_node.getChildNode("near_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 			sscanf(temp_var, "%lf", &(I_off_n));
! 		} else {
! 			strcpy(temp_var,NMOS_OFFcurrents_node.getChildNode("super_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 			sscanf(temp_var, "%lf", &(I_off_n));
! 		}
  
! 		PMOS_OFFcurrents_node = root_node.getChildNode("currents").getChildNode("OFF_current").getChildNode("PMOS");
! 		if ( g_ip->is_near_threshold ) {
! 			strcpy(temp_var,PMOS_OFFcurrents_node.getChildNode("near_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 			sscanf(temp_var, "%lf", &(I_off_p));
! 		} else {
! 			strcpy(temp_var,PMOS_OFFcurrents_node.getChildNode("super_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 			sscanf(temp_var, "%lf", &(I_off_p));
! 		}
! 		//---------- Majid - END ------------
  
! 		/***** Alireza - BEGIN *****/
! 		if (g_ip->is_finfet) {
! 			vbit_sense_min = 0.04;
! 			g_tp.sram_cell.P_fin   += curr_alpha * p_fin;
! 			g_tp.sram_cell.H_fin   += curr_alpha * h_fin;
! 			g_tp.sram_cell.T_si    += curr_alpha * t_si;
! 			// FinFET-based SRAM cell properties:
! 			double sram_cell_height, sram_cell_width;
! 			sram_cell_height = g_ip->sram_cell_design.calc_height(lambda_um);
! 			sram_cell_width = g_ip->sram_cell_design.calc_width(lambda_um, p_fin, t_si);
! 			int n[5];
! 			g_ip->sram_cell_design.getNfins(n);
! 			curr_Wmemcella_sram      = n[0] * 2 * h_fin;
! 			curr_Wmemcellpmos_sram   = n[1] * 2 * h_fin;
! 			curr_Wmemcellnmos_sram   = n[2] * 2 * h_fin;
! 			curr_Wmemcellrdiso_sram  = n[3] * 2 * h_fin;
! 			curr_Wmemcellrda_sram    = n[4] * 2 * h_fin;
! 			curr_area_cell_sram      = sram_cell_height * sram_cell_width;
! 			curr_asp_ratio_cell_sram = sram_cell_height / sram_cell_width;
! 		} else {
! 			vbit_sense_min = 0.08;
! 			// CMOS-based SRAM cell properties:
! 			if ( g_ip->sram_cell_design.getType() == std_6T ) {
! 				curr_Wmemcella_sram      = 1.31 * g_ip->F_sz_um;
! 				curr_Wmemcellpmos_sram   = 1.23 * g_ip->F_sz_um;
! 				curr_Wmemcellnmos_sram   = 2.08 * g_ip->F_sz_um;
! 				curr_area_cell_sram      = 146 * g_ip->F_sz_um * g_ip->F_sz_um;
! 				curr_asp_ratio_cell_sram = 1.46;
! 			} else if ( g_ip->sram_cell_design.getType() == std_8T ) {
! 				// Source: Chang et al., "Stable SRAM cell design for the 32 nm node and beyond," VLSI Symposia 2005.
! 				curr_Wmemcella_sram      = 1.0 * g_ip->F_sz_um;
! 				curr_Wmemcellpmos_sram   = 1.0 * g_ip->F_sz_um;
! 				curr_Wmemcellnmos_sram   = 1.0 * g_ip->F_sz_um;
! 				curr_Wmemcellrda_sram    = 1.0 * g_ip->F_sz_um;
! 				curr_Wmemcellrdiso_sram  = 3.5 * g_ip->F_sz_um;
! 				curr_area_cell_sram      = 195 * g_ip->F_sz_um * g_ip->F_sz_um;
! 				curr_asp_ratio_cell_sram = 0.36;
! 			} else {
! 				cout << "ERROR: Invalid SRAM cell type in technology.cc!\n";
! 				exit(0);
  			}
- 		}
  
! 		g_tp.Vbit_sense_min = vbit_sense_min;
  
! 		delta_L = (g_ip->is_finfet) ? (2*0.8*Xj) : (0.8*Xj);
! 		c_g_ideal = Lphy * c_ox;
! 		Lelec = Lphy - delta_L;
! 		if ( Lelec <=0 ) {
! 			cout << "ERROR: Lelec (ram_cell) is not a positive value! Please check the Lphy or the Xj value.\n";
! 			exit(0);
! 		}
! 		n_to_p_eff_curr_drv_ratio = I_on_n / I_on_p;
! 		Rnchannelon = vdd_cell / I_on_n;
! 		Rpchannelon = vdd_cell / I_on_p;
! 		g_tp.sram_cell.Vdd       += curr_alpha * vdd_cell;
! 		g_tp.sram_cell.l_phy     += curr_alpha * Lphy;
! 		g_tp.sram_cell.l_elec    += curr_alpha * Lelec;
! 		g_tp.sram_cell.t_ox      += curr_alpha * t_ox;
! 		g_tp.sram_cell.Vth       += curr_alpha * v_th;
! 		g_tp.sram_cell.C_g_ideal += curr_alpha * c_g_ideal;
! 		g_tp.sram_cell.C_fringe  += curr_alpha * c_fringe;
! 		g_tp.sram_cell.C_junc    += curr_alpha * c_junc;
! 		g_tp.sram_cell.C_junc_sidewall = c_junc_sidewall;
! 		g_tp.sram_cell.I_on_n    += curr_alpha * I_on_n;
! 		g_tp.sram_cell.I_off_n   += curr_alpha * I_off_n;
! 		g_tp.sram_cell.I_off_p   += curr_alpha * I_off_p;
! 		g_tp.sram_cell.R_nch_on  += curr_alpha * Rnchannelon;
! 		g_tp.sram_cell.R_pch_on  += curr_alpha * Rpchannelon;
! 		g_tp.sram_cell.n_to_p_eff_curr_drv_ratio += curr_alpha * n_to_p_eff_curr_drv_ratio;
! 		/****** Alireza - END ******/
! 		//-------------------- cell parameters end ----------------------------
! 
! 
! 		//-------------------- peripheral parameters begin --------------------
! 		//---------- Majid - BEGIN ----------
! 		if ( is_tag ) {
! 			root_node = XMLNode::openFileHelper(g_ip->tag_array_peri_tech_file,"device_definition");
! 		} else {
! 			root_node = XMLNode::openFileHelper(g_ip->data_array_peri_tech_file,"device_definition");
! 		}
  
! 		geometry_node = root_node.getChildNode("geometries");
! 		strcpy(temp_var,geometry_node.getChildNode("Lphy").getText(0));
! 		sscanf(temp_var, "%lf", &(Lphy));
! 		strcpy(temp_var,geometry_node.getChildNode("Xj").getText(0));
! 		sscanf(temp_var, "%lf", &(Xj));
! 		strcpy(temp_var,geometry_node.getChildNode("t_ox").getText(0));
! 		sscanf(temp_var, "%lf", &(t_ox));
! 		if ( g_ip->is_finfet ) {
! 			strcpy(temp_var,geometry_node.getChildNode("FinFET").getChildNode("t_si").getText(0));
! 			sscanf(temp_var, "%lf", &(t_si));
! 			strcpy(temp_var,geometry_node.getChildNode("FinFET").getChildNode("h_fin").getText(0));
! 			sscanf(temp_var, "%lf", &(h_fin));
! 			if ( !geometry_node.getChildNode("FinFET").getChildNode("p_fin").isEmpty() ) {
! 				strcpy(temp_var,geometry_node.getChildNode("FinFET").getChildNode("p_fin").getText(0));
! 				sscanf(temp_var, "%lf", &(p_fin));
! 			} else {
! 				p_fin = (2 * lambda_um) + t_si;
  			}
! 		}
  
! 		voltages_node = root_node.getChildNode("voltages");
! 		strcpy(temp_var,voltages_node.getChildNode("v_th").getText(0));
! 		sscanf(temp_var, "%lf", &(v_th));
! 		if ( g_ip->is_near_threshold ) {
! 			strcpy(temp_var,voltages_node.getChildNode("vdd").getChildNode("near_threshold").getText(0));
! 			sscanf(temp_var, "%lf", &(vdd_peri));
! 			strcpy(temp_var,voltages_node.getChildNode("Vdsat").getChildNode("near_threshold").getText(0));
! 			sscanf(temp_var, "%lf", &(Vdsat));
! 		} else {
! 			strcpy(temp_var,voltages_node.getChildNode("vdd").getChildNode("super_threshold").getText(0));
! 			sscanf(temp_var, "%lf", &(vdd_peri));
! 			strcpy(temp_var,voltages_node.getChildNode("Vdsat").getChildNode("super_threshold").getText(0));
! 			sscanf(temp_var, "%lf", &(Vdsat));
! 		}
  
! 		cap_node = root_node.getChildNode("capacitances");
! 		strcpy(temp_var,cap_node.getChildNode("c_ox").getText(0));
! 		sscanf(temp_var, "%lf", &(c_ox));
! 		strcpy(temp_var,cap_node.getChildNode("c_junc_sidewall").getText(0));
! 		sscanf(temp_var, "%lf", &(c_junc_sidewall));
! 		strcpy(temp_var,cap_node.getChildNode("c_junc_sidewall_gate").getText(0));
! 		sscanf(temp_var, "%lf", &(c_junc_sidewall_gate));
! 		strcpy(temp_var,cap_node.getChildNode("c_junc").getText(0));
! 		sscanf(temp_var, "%lf", &(c_junc));
! 		strcpy(temp_var,cap_node.getChildNode("c_fringe").getText(0));
! 		sscanf(temp_var, "%lf", &(c_fringe));
! 
! 		strcpy(temp_var,root_node.getChildNode("mobility_eff").getText(0));
! 		sscanf(temp_var, "%lf", &(mobility_eff));
! 
! 		strcpy(temp_var,root_node.getChildNode("gmp_to_gmn_multiplier").getText(0));
! 		sscanf(temp_var, "%lf", &(gmp_to_gmn_multiplier));
! 
! 		NMOS_ONcurrents_node = root_node.getChildNode("currents").getChildNode("ON_current").getChildNode("NMOS");
! 		if ( g_ip->is_near_threshold ) {
! 			strcpy(temp_var,NMOS_ONcurrents_node.getChildNode("near_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 			sscanf(temp_var, "%lf", &(I_on_n));
! 		} else {
! 			strcpy(temp_var,NMOS_ONcurrents_node.getChildNode("super_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 			sscanf(temp_var, "%lf", &(I_on_n));
! 		}
  
! 		PMOS_ONcurrents_node = root_node.getChildNode("currents").getChildNode("ON_current").getChildNode("PMOS");
! 		if ( g_ip->is_near_threshold ) {
! 			strcpy(temp_var,PMOS_ONcurrents_node.getChildNode("near_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 			sscanf(temp_var, "%lf", &(I_on_p));
! 		} else {
! 			strcpy(temp_var,PMOS_ONcurrents_node.getChildNode("super_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 			sscanf(temp_var, "%lf", &(I_on_p));
! 		}
  
! 		NMOS_OFFcurrents_node = root_node.getChildNode("currents").getChildNode("OFF_current").getChildNode("NMOS");
! 		if ( g_ip->is_near_threshold ) {
! 			strcpy(temp_var,NMOS_OFFcurrents_node.getChildNode("near_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 			sscanf(temp_var, "%lf", &(I_off_n));
! 		} else {
! 			strcpy(temp_var,NMOS_OFFcurrents_node.getChildNode("super_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 			sscanf(temp_var, "%lf", &(I_off_n));
! 		}
  
! 		PMOS_OFFcurrents_node = root_node.getChildNode("currents").getChildNode("OFF_current").getChildNode("PMOS");
! 		if ( g_ip->is_near_threshold ) {
! 			strcpy(temp_var,PMOS_OFFcurrents_node.getChildNode("near_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 			sscanf(temp_var, "%lf", &(I_off_p));
! 		} else {
! 			strcpy(temp_var,PMOS_OFFcurrents_node.getChildNode("super_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 			sscanf(temp_var, "%lf", &(I_off_p));
! 		}
! 		//---------- Majid - END ------------
  
! 		/***** Alireza - BEGIN *****/
! 		if (g_ip->is_finfet) {
! 			g_tp.peri_global.P_fin += curr_alpha * p_fin;
! 			g_tp.peri_global.H_fin += curr_alpha * h_fin;
! 			g_tp.peri_global.T_si  += curr_alpha * t_si;
! 		}
  
! 		delta_L = (g_ip->is_finfet) ? (2*0.8*Xj) : (0.8*Xj);
! 		c_g_ideal = Lphy * c_ox;
! 		Lelec = Lphy - delta_L;
! 		if ( Lelec <= 0 ) {
! 			cout << "ERROR: Lelec (peri_global) is not a positive value! Please check the Lphy or the Xj value.\n";
! 			exit(0);
! 		}
! 		n_to_p_eff_curr_drv_ratio = I_on_n / I_on_p;
! 		Rnchannelon = vdd_peri / I_on_n;
! 		Rpchannelon = vdd_peri / I_on_p;
! 		g_tp.peri_global.Vdd       += curr_alpha * vdd_peri;
! 		g_tp.peri_global.t_ox      += curr_alpha * t_ox;
! 		g_tp.peri_global.Vth       += curr_alpha * v_th;
! 		g_tp.peri_global.C_ox      += curr_alpha * c_ox;
! 		g_tp.peri_global.C_g_ideal += curr_alpha * c_g_ideal;
! 		g_tp.peri_global.C_fringe  += curr_alpha * c_fringe;
! 		g_tp.peri_global.C_junc    += curr_alpha * c_junc;
! 		g_tp.peri_global.C_junc_sidewall = c_junc_sidewall;
! 		g_tp.peri_global.l_phy     += curr_alpha * Lphy;
! 		g_tp.peri_global.l_elec    += curr_alpha * Lelec;
! 		g_tp.peri_global.I_on_n    += curr_alpha * I_on_n;
! 		g_tp.peri_global.I_off_n   += curr_alpha * I_off_n;
! 		g_tp.peri_global.I_off_p   += curr_alpha * I_off_p;
! 		g_tp.peri_global.R_nch_on  += curr_alpha * Rnchannelon;
! 		g_tp.peri_global.R_pch_on  += curr_alpha * Rpchannelon;
! 		g_tp.peri_global.n_to_p_eff_curr_drv_ratio += curr_alpha * n_to_p_eff_curr_drv_ratio;
! 		gmp_to_gmn_multiplier_periph_global += curr_alpha * gmp_to_gmn_multiplier;
! 		/****** Alireza - END ******/
! 		//-------------------- peripheral parameters end ----------------------
  
  
  
  		// TO DO: Update This!
  		//-------------------- dram parameters begin --------------------------
  		c_g_ideal = Lphy_dram * c_ox_dram;
  		Lelec = Lphy_dram - delta_L;
! 		if ( Lelec <= 0 ) { // Alireza2
! 			///cout << "ERROR: Lelec is not a positive value! Please check the Lphy or the Xj value.\n"; // Alireza2
! 			///exit(0); // Alireza2
! 		} // Alireza2
  		n_to_p_eff_curr_drv_ratio = I_on_n_dram / I_on_p_dram;
! 		Rnchannelon = curr_vdd_dram_cell / I_on_n_dram;
! 		Rpchannelon = curr_vdd_dram_cell / I_on_p_dram;
! 		g_tp.dram_cell_Vdd      += curr_alpha * curr_vdd_dram_cell;
! 		g_tp.dram_acc.Vth       += curr_alpha * curr_v_th_dram_access_transistor;
! 		g_tp.dram_acc.l_phy     += curr_alpha * Lphy_dram;
  		g_tp.dram_acc.l_elec    += curr_alpha * Lelec;
! 		g_tp.dram_acc.C_g_ideal += curr_alpha * c_g_ideal;
  		g_tp.dram_acc.C_fringe  += curr_alpha * c_fringe_dram;
  		g_tp.dram_acc.C_junc    += curr_alpha * c_junc_dram;
! 		g_tp.dram_acc.C_junc_sidewall = c_junc_sidewall;
  		g_tp.dram_cell_I_on     += curr_alpha * curr_I_on_dram_cell;
  		g_tp.dram_cell_I_off_worst_case_len_temp += curr_alpha * curr_I_off_dram_cell_worst_case_length_temp;
  		g_tp.dram_acc.I_on_n    += curr_alpha * I_on_n_dram;
--- 198,1083 ----
  		}
  		
  		double lambda_um = (double)tech / 2.0 / 1000.0; // Alireza: lambda in um
! /*
! 		//Divya adding 45-nm technology 23-11-2021
! 	    if (tech == 45)
! 	    { //45nm technology-node. Corresponds to year 2010 in ITRS
! 	      //ITRS HP device type
! 	    	cout << "45-nm \n";
! 	      SENSE_AMP_D = .04e-9; // s
! 	      SENSE_AMP_P = 2.7e-15; // J
! 	      vdd = 1.0;
! 	      vdd_real = g_ip->vdd;	//g_ip->specific_hp_vdd ? g_ip->hp_Vdd : vdd;//TODO
! 	      vdd_cell = vdd_real;
! 	      alpha_power_law=1.21;
! 	      Lphy = 0.018;
! 	      Lelec = 0.01345;
! 	      t_ox = 0.65e-3;
! 	      v_th = .18035;
! 	      c_ox = 3.77e-14;
! 	      mobility_eff = 266.68 * (1e-2 * 1e6 * 1e-2 * 1e6);
! 	      Vdsat = 9.38E-2;
! 	      c_g_ideal = 6.78e-16;
! 	      c_fringe = 0.05e-15;
! 	      c_junc = 1e-15;
! 	      I_on_n = 2046.6e-6*pow((vdd_real-v_th)/(vdd-v_th),alpha_power_law);
! 	      //There are certain problems with the ITRS PMOS numbers in MASTAR for 45nm. So we are using 65nm values of
! 	      //n_to_p_eff_curr_drv_ratio and gmp_to_gmn_multiplier for 45nm
! 	      I_on_p = I_on_n / 2;//This value is fixed arbitrarily but I_on_p is not being used in CACTI
! 	      nmos_effective_resistance_multiplier = 1.51;
! 	      n_to_p_eff_curr_drv_ratio = 2.41;
! 	      gmp_to_gmn_multiplier = 1.38;
! 	      Rnchannelon = nmos_effective_resistance_multiplier * vdd_real / I_on_n;
! 	      Rpchannelon = n_to_p_eff_curr_drv_ratio * Rnchannelon;
! //	      long_channel_leakage_reduction = 1/3.546;//Using MASTAR, @380K, increase Lgate until Ion reduces to 90%, Ioff(Lgate normal)/Ioff(Lgate long)= 3.74
! 
! 	      I_off_n = 2.8e-7*pow(vdd_real/(vdd),4); //at 300K
! //	      I_g_on_n  = 3.59e-8;//A/micron	//divya removing I_g_on as this is insignificant in FinFETs/NCFETs
! 		  vbit_sense_min = 0.08;
! 
! 	      if (ram_cell_tech_type == lp_dram)
! 	      {
! 	        //LP-DRAM cell access transistor technology parameters
! 	        curr_vdd_dram_cell = 1.1;
! 	        Lphy_dram = 0.078;
! 	        Lelec = 0.0504;// Assume Lelec is 30% lesser than Lphy for DRAM access and wordline transistors.
! 	        curr_v_th_dram_access_transistor = 0.44559;
! 	        width_dram_access_transistor = 0.079;
! 	        curr_I_on_dram_cell = 36e-6;//A
! 	        curr_I_off_dram_cell_worst_case_length_temp = 19.5e-12;
! 	        curr_Wmemcella_dram = width_dram_access_transistor;
! 	        curr_Wmemcellpmos_dram = 0;
! 	        curr_Wmemcellnmos_dram  = 0;
! 	        curr_area_cell_dram = width_dram_access_transistor * Lphy_dram * 10.0;
! 	        curr_asp_ratio_cell_dram = 1.46;
! 	        curr_c_dram_cell = 20e-15;
! 
! 	        //LP-DRAM wordline transistor parameters
! 	        curr_vpp = 1.5;
! 	        t_ox_dram = 2.1e-3;
! 	        v_th_dram = 0.44559;
! 	        c_ox_dram = 1.41e-14;
! 	        mobility_eff_dram =   426.30 * (1e-2 * 1e6 * 1e-2 * 1e6);
! 	        Vdsat_dram = 0.181;
! 	        c_g_ideal_dram = 1.10e-15;
! 	        c_fringe_dram = 0.08e-15;
! 	        c_junc_dram = 1e-15;
! 	        I_on_n_dram = 456e-6;
! 	        I_on_p_dram = I_on_n_dram / 2;
! 	        nmos_effective_resistance_multiplier = 1.65;
! 	        n_to_p_eff_curr_drv_ratio = 2.05;
! 	        gmp_to_gmn_multiplier_dram = 0.90;
! 	        Rnchannelon = nmos_effective_resistance_multiplier * curr_vpp / I_on_n_dram;
! 	        Rpchannelon = n_to_p_eff_curr_drv_ratio * Rnchannelon;
! //	        long_channel_leakage_reduction[3] = 1;
! 	        I_off_n_dram = 2.54e-11;
! 	      }
! 	      else if (ram_cell_tech_type == comm_dram)
! 	      {
! 	        //COMM-DRAM cell access transistor technology parameters
! 	        curr_vdd_dram_cell = 1.1;
! 	        Lphy_dram = 0.045;
! 	        Lelec_dram = 0.0298;
! 	        curr_v_th_dram_access_transistor = 1;
! 	        width_dram_access_transistor = 0.045;
! 	        curr_I_on_dram_cell = 20e-6;//A
! 	        curr_I_off_dram_cell_worst_case_length_temp = 1e-15;
! 	        curr_Wmemcella_dram = width_dram_access_transistor;
! 	        curr_Wmemcellpmos_dram = 0;
! 	        curr_Wmemcellnmos_dram  = 0;
! 	        curr_area_cell_dram = 6*0.045*0.045;
! 	        curr_asp_ratio_cell_dram = 1.5;
! 	        curr_c_dram_cell = 30e-15;
! 
! 	        //COMM-DRAM wordline transistor parameters
! 	        curr_vpp = 2.7;
! 	        t_ox_dram = 4e-3;
! 	        v_th_dram = 1.0;
! 	        c_ox_dram = 7.98e-15;
! 	        mobility_eff_dram = 368.58 * (1e-2 * 1e6 * 1e-2 * 1e6);
! 	        Vdsat_dram = 0.147;
! 	        c_g_ideal_dram = 3.59e-16;
! 	        c_fringe_dram = 0.08e-15;
! 	        c_junc_dram = 1e-15;
! 	        I_on_n_dram = 999.4e-6;
! 	        I_on_p_dram = I_on_n_dram / 2;
! 	        nmos_effective_resistance_multiplier = 1.69;
! 	        n_to_p_eff_curr_drv_ratio = 1.95;
! 	        gmp_to_gmn_multiplier_dram = 0.90;
! 	        Rnchannelon = nmos_effective_resistance_multiplier * curr_vpp / I_on_n_dram;
! 	        Rpchannelon = n_to_p_eff_curr_drv_ratio * Rnchannelon;
! //	        long_channel_leakage_reduction[3] = 1;
! 	        I_off_n_dram = 1.31e-14;
! 	      }
! 
! 	      //SRAM cell properties
! 	      curr_Wmemcella_sram = 1.31 * g_ip->F_sz_um;
! 	      curr_Wmemcellpmos_sram = 1.23 * g_ip->F_sz_um;
! 	      curr_Wmemcellnmos_sram = 2.08 * g_ip->F_sz_um;
! 	      curr_area_cell_sram = 146 * g_ip->F_sz_um * g_ip->F_sz_um;
! 	      curr_asp_ratio_cell_sram = 1.46;
! 	      //CAM cell properties //TODO: data need to be revisited
! 	      curr_Wmemcella_cam = 1.31 * g_ip->F_sz_um;
! 	      curr_Wmemcellpmos_cam = 1.23 * g_ip->F_sz_um;
! 	      curr_Wmemcellnmos_cam = 2.08 * g_ip->F_sz_um;
! 	      curr_area_cell_cam = 292 * g_ip->F_sz_um * g_ip->F_sz_um;
! 	      curr_asp_ratio_cell_cam = 2.92;
! 	      //Empirical undifferentiated core/FU coefficient
! 	      curr_logic_scaling_co_eff = 0.7*0.7;
! 	      curr_core_tx_density      = 1.25;
! 	      curr_sckt_co_eff           = 1.1387;
! 	      curr_chip_layout_overhead  = 1.2;//die measurement results based on Niagara 1 and 2
! 	      curr_macro_layout_overhead = 1.1;//EDA placement and routing tool rule of thumb
! 
! 	      g_tp.Vbit_sense_min = vbit_sense_min;
! 
! 	      g_tp.peri_global.Vdd       += curr_alpha * vdd_real;//real vdd, user defined or itrs
! 	      g_tp.peri_global.Vth       += curr_alpha * v_th;
! 	      g_tp.peri_global.t_ox      += curr_alpha * t_ox;
! 	      g_tp.peri_global.C_ox      += curr_alpha * c_ox;
! 	      g_tp.peri_global.C_g_ideal += curr_alpha * c_g_ideal;
! 	      g_tp.peri_global.C_fringe  += curr_alpha * c_fringe;
! 	      g_tp.peri_global.C_junc    += curr_alpha * c_junc;
! 	      g_tp.peri_global.C_junc_sidewall = 0.25e-15;  // F/micron
! 	      g_tp.peri_global.l_phy     += curr_alpha * Lphy;
! 	      g_tp.peri_global.l_elec    += curr_alpha * Lelec;
! 	      g_tp.peri_global.I_on_n    += curr_alpha * I_on_n;
! 	      g_tp.peri_global.R_nch_on  += curr_alpha * Rnchannelon;
! 	      g_tp.peri_global.R_pch_on  += curr_alpha * Rpchannelon;
! 	      g_tp.peri_global.n_to_p_eff_curr_drv_ratio
! 	        += curr_alpha * n_to_p_eff_curr_drv_ratio;
! 	      g_tp.peri_global.long_channel_leakage_reduction
! 	        += curr_alpha * 0;//long_channel_leakage_reduction;
! 	      g_tp.peri_global.I_off_n   += curr_alpha * I_off_n; //*pow(g_tp.peri_global.Vdd/g_tp.peri_global.Vdd_default,3);//Consider the voltage change may affect the current density as well. TODO: polynomial curve-fitting based on MASTAR may not be accurate enough
! 	      g_tp.peri_global.I_off_p   += curr_alpha * I_off_n; //*pow(g_tp.peri_global.Vdd/g_tp.peri_global.Vdd_default,3);//To mimic the Vdd effect on Ioff (for the same device, dvs should not change default Ioff---only changes if device is different?? but MASTAR shows different results)
! //	      g_tp.peri_global.I_g_on_n   += curr_alpha * I_g_on_n[g_ip->temp - 300];
! //	      g_tp.peri_global.I_g_on_p   += curr_alpha * I_g_on_n[g_ip->temp - 300];
! 	      gmp_to_gmn_multiplier_periph_global += curr_alpha * gmp_to_gmn_multiplier;
! 
! 	      g_tp.sram_cell.Vdd       += curr_alpha * vdd_real;
! 	      g_tp.sram_cell.Vth       += curr_alpha * v_th;
! 	      g_tp.sram_cell.l_phy     += curr_alpha * Lphy;
! 	      g_tp.sram_cell.l_elec    += curr_alpha * Lelec;
! 	      g_tp.sram_cell.t_ox      += curr_alpha * t_ox;
! 	      g_tp.sram_cell.C_g_ideal += curr_alpha * c_g_ideal;
! 	      g_tp.sram_cell.C_fringe  += curr_alpha * c_fringe;
! 	      g_tp.sram_cell.C_junc    += curr_alpha * c_junc;
! 	      g_tp.sram_cell.C_junc_sidewall = 0.25e-15;  // F/micron
! 	      g_tp.sram_cell.I_on_n    += curr_alpha * I_on_n;
! 	      g_tp.sram_cell.R_nch_on  += curr_alpha * Rnchannelon;
! 	      g_tp.sram_cell.R_pch_on  += curr_alpha * Rpchannelon;
! 	      g_tp.sram_cell.n_to_p_eff_curr_drv_ratio += curr_alpha * n_to_p_eff_curr_drv_ratio;
! 	      g_tp.sram_cell.long_channel_leakage_reduction += curr_alpha * 0;	//long_channel_leakage_reduction;
! 	      g_tp.sram_cell.I_off_n   += curr_alpha * I_off_n;//**pow(g_tp.sram_cell.Vdd/g_tp.sram_cell.Vdd_default,4);
! 	      g_tp.sram_cell.I_off_p   += curr_alpha * I_off_n;//**pow(g_tp.sram_cell.Vdd/g_tp.sram_cell.Vdd_default,4);
! //	      g_tp.sram_cell.I_g_on_n   += curr_alpha * I_g_on_n[g_ip->temp - 300];
! //	      g_tp.sram_cell.I_g_on_p   += curr_alpha * I_g_on_n[g_ip->temp - 300];
! 
! 	      g_tp.cam_cell.Vdd       += curr_alpha * vdd_real;
! 	      g_tp.cam_cell.l_phy     += curr_alpha * Lphy;
! 	      g_tp.cam_cell.l_elec    += curr_alpha * Lelec;
! 	      g_tp.cam_cell.t_ox      += curr_alpha * t_ox;
! 	      g_tp.cam_cell.Vth       += curr_alpha * v_th;
! 	      g_tp.cam_cell.C_g_ideal += curr_alpha * c_g_ideal;
! 	      g_tp.cam_cell.C_fringe  += curr_alpha * c_fringe;
! 	      g_tp.cam_cell.C_junc    += curr_alpha * c_junc;
! 	      g_tp.cam_cell.C_junc_sidewall = 0.25e-15;  // F/micron
! 	      g_tp.cam_cell.I_on_n    += curr_alpha * I_on_n;
! 	      g_tp.cam_cell.R_nch_on  += curr_alpha * Rnchannelon;
! 	      g_tp.cam_cell.R_pch_on  += curr_alpha * Rpchannelon;
! 	      g_tp.cam_cell.n_to_p_eff_curr_drv_ratio += curr_alpha * n_to_p_eff_curr_drv_ratio;
! 	      g_tp.cam_cell.long_channel_leakage_reduction += curr_alpha * 0;	//long_channel_leakage_reduction;
! 	      g_tp.cam_cell.I_off_n   += curr_alpha * I_off_n;//*pow(g_tp.cam_cell.Vdd/g_tp.cam_cell.Vdd_default,4);
! 	      g_tp.cam_cell.I_off_p   += curr_alpha * I_off_n;//**pow(g_tp.cam_cell.Vdd/g_tp.cam_cell.Vdd_default,4);
! //	      g_tp.cam_cell.I_g_on_n   += curr_alpha * I_g_on_n[g_ip->temp - 300];
! //	      g_tp.cam_cell.I_g_on_p   += curr_alpha * I_g_on_n[g_ip->temp - 300];
! 
! 	    }	//end of 45-nm data
! */
! 	    if(tech == 14)//14-nm
! 		{
! 	    	//we dont have data for 14-nm DRAM for finfet. It is fine as we don't need it also
! 	    	if (tech == 14 && !g_ip->is_finfet) {
! //	    		cout << "technology.cc:: 14nm & cmos \n";
! 			   Lphy_dram = 0.014;
! 			   curr_vdd_dram_cell = 0.8;	//Divya changed as near threshold or super threshold not valid anymore
! 			   c_ox_dram = 3.52e-14;
! 			   c_fringe_dram = 0.8e-16;
! 			   c_junc_dram = 0.5e-15;
! 
! 			   I_on_n_dram = 8.367e-04;
! 			   I_on_p_dram = 5.012e-04;
! 			   I_off_n_dram = 9.662e-08;
! 			   I_off_p_dram = 1.095e-07;
! 			}
! //    		cout << "technology.cc:: 14nm , finfet: " << g_ip->is_finfet << ", vdd:" << g_ip->vdd << endl;
! 			//-------------------- cell parameters begin --------------------------
! 			Lphy 	= 0.02;	//20-nm represented in um
! 			Xj 		= 0;
! 
! 			//Divya 14-11-2021
! 			//Fixing geometries to 14-nm Fin/NC-FinFET transistor type as we working only for it
! 
! 			//for finfet or cmos check. finfets can be FinFET or NCFET which is captured in is_ncfet
! 			if(g_ip->is_finfet) {
! 				if(g_ip->is_ncfet)	//NCFET
! 					t_ox = 0.00043;	//0.43nm represented in um
! 				else	//Finfet
! 					t_ox = 0.001;	//1nm represented in um
  			}
  
! 			//FinFET and NCFET have same values for below parameters
! 			if ( g_ip->is_finfet ) {
! 				t_si 	= 0.008;	//8-nm
! 				h_fin 	= 0.042;	//42nm represented in um
! 				p_fin 	= 0.042; 	//42nm represented in um
! 				w_fin 	= 0.008;	//8-nm
! 			}
  
! 			vdd_cell = g_ip->vdd;
  
! 			//for finfet or cmos check. finfets can be FinFET or NCFET which is captured in is_ncfet
! 			if ( g_ip->is_finfet ) {
! 				if(g_ip->is_ncfet)	//NCFET
! 				{
! 					if(vdd_cell == 0.2)
! 						v_th = 0.202;
! 					else if(vdd_cell == 0.3)
! 						v_th = 0.201;
! 					else if(vdd_cell == 0.4)
! 						v_th = 0.205;
! 					else if(vdd_cell == 0.5)
! 						v_th = 0.21;
! 					else if(vdd_cell == 0.6)
! 						v_th = 0.215;
! 					else if(vdd_cell == 0.7)
! 						v_th = 0.2195;
! 					else if(vdd_cell == 0.8)
! 						v_th = 0.2245;
! 				}
! 				else //FinFET
! 				{
! 					if(vdd_cell == 0.2)
! 						v_th = 0.262;
! 					else if(vdd_cell == 0.3)
! 						v_th = 0.261;
! 					else if(vdd_cell == 0.4)
! 						v_th = 0.2565;
! 					else if(vdd_cell == 0.5)
! 						v_th = 0.251;
! 					else if(vdd_cell == 0.6)
! 						v_th = 0.2455;
! 					else if(vdd_cell == 0.7)
! 						v_th = 0.24;
! 					else if(vdd_cell == 0.8)
! 						v_th = 0.235;
! 				}
! 			}
  
! 			//for finfet or cmos check. finfets can be FinFET or NCFET which is captured in is_ncfet
! 			if ( g_ip->is_finfet ) {
! 				if(g_ip->is_ncfet)	//NCFET
! 				{
! 					c_ox = 2.9e-13;	//f/um2
! 					c_fringe = 2.29891e-16; //f/um
! 					c_junc = 5.0e-16; //f/um2
! 					c_junc_sidewall = 5.0e-16; //f/um
! 					c_junc_sidewall_gate = 0;
! 
! 					if(vdd_cell == 0.2)
! 						c_gate = 2.53804e-16;	//f/um
! 					else if(vdd_cell == 0.3)
! 						c_gate = 6.09783e-16;
! 					else if(vdd_cell == 0.4)
! 						c_gate = 6.79891e-16;
! 					else if(vdd_cell == 0.5)
! 						c_gate = 7.33696e-16;
! 					else if(vdd_cell == 0.6)
! 						c_gate = 7.760874e-16;
! 					else if(vdd_cell == 0.7)
! 						c_gate = 8.11957e-16;
! 					else if(vdd_cell == 0.8)
! 						c_gate = 8.375e-16;
! 				}
! 				else //FinFET
! 				{
! 					c_ox = 3.67e-14;	//f/um2
! 					c_fringe = 2.29891e-16; //f/um
! 					c_junc = 5.0e-16; //f/um2
! 					c_junc_sidewall = 5.0e-16; //f/um
! 					c_junc_sidewall_gate = 0;
! 
! 					if(vdd_cell == 0.2)
! 						c_gate = 4.18478e-18;
! 					else if(vdd_cell == 0.3)
! 						c_gate = 5.49457e-17;
! 					else if(vdd_cell == 0.4)
! 						c_gate = 1.375e-16;
! 					else if(vdd_cell == 0.5)
! 						c_gate = 1.85326e-16;
! 					else if(vdd_cell == 0.6)
! 						c_gate = 2.14674e-16;
! 					else if(vdd_cell == 0.7)
! 						c_gate = 2.364133e-16;
! 					else if(vdd_cell == 0.8)
! 						c_gate = 2.52717e-16;
! 				}
! 			}
  
! 			//for finfet or cmos check. finfets can be FinFET or NCFET which is captured in is_ncfet
! 			if ( g_ip->is_finfet ) {
! 				if(g_ip->is_ncfet)	//NCFET
! 				{
! 					SENSE_AMP_D = 3.101e-12;
! 					SENSE_AMP_P = 3.630e-19;
! 				}
! 				else //FinFET
! 				{
! 					SENSE_AMP_D = 3.101e-12;
! 					SENSE_AMP_P = 3.630e-19;
! 				}
! 			}
! 
! 			//for finfet or cmos check. finfets can be FinFET or NCFET which is captured in is_ncfet
! 			if ( g_ip->is_finfet ) {
! 				if(g_ip->is_ncfet)	//NCFET
! 				{
! 					if(vdd_cell == 0.2)
! 					{
! 						I_on_n = 4.456522e-06;	// Amp/um
! 						I_on_p = 3.043478e-06;	// Amp/um
! 						I_off_n = 1.51087e-09;	// Amp/um
! 						I_off_p = 2.163043e-09;	// Amp/um
! 					}
! 					else if(vdd_cell == 0.3)
! 					{
! 						I_on_n = 4.315217e-05;
! 						I_on_p = 3.75e-05;
! 						I_off_n = 1.304348e-09;
! 						I_off_p = 1.771739e-09;
! 					}
! 					else if(vdd_cell == 0.4)
! 					{
! 						I_on_n = 1.6413e-04;
! 						I_on_p = 1.59783e-04;
! 						I_off_n = 1.119565e-09;
! 						I_off_p = 1.456522e-09;
! 					}
! 					else if(vdd_cell == 0.5)
! 					{
! 						I_on_n = 3.82609e-04;
! 						I_on_p = 3.53261e-04;
! 						I_off_n = 1.0e-09;
! 						I_off_p = 1.184783e-09;
! 					}
! 					else if(vdd_cell == 0.6)
! 					{
! 						I_on_n = 6.59783e-04;
! 						I_on_p = 5.81522e-04;
! 						I_off_n = 8.119565e-10;
! 						I_off_p = 1.0e-09;
! 					}
! 					else if(vdd_cell == 0.7)
! 					{
! 						I_on_n = 9.65217e-04;
! 						I_on_p = 8.09783e-04;
! 						I_off_n = 6.880435e-10;
! 						I_off_p = 7.836957e-10;
! 					}
! 					else if(vdd_cell == 0.8)
! 					{
! 						I_on_n = 1.206522e-03;
! 						I_on_p = 1.047826e-03;
! 						I_off_n = 5.836957e-10;
! 						I_off_p = 6.39565e-10;
! 					}
! 					I_on_n_to_I_on_p_ratio = 1.4642857143;
! 				}
! 				else //FinFET
! 				{
! 					if(vdd_cell == 0.2)
! 					{
! 						I_on_n = 7.728261e-07;
! 						I_on_p = 6.586957e-07;
! 						I_off_n = 1.489133e-09;
! 						I_off_p = 1.532609e-09;
! 					}
! 					else if(vdd_cell == 0.3)
! 					{
! 						I_on_n = 1.3913e-05;
! 						I_on_p = 1.1413e-05;
! 						I_off_n = 2.0e-09;
! 						I_off_p = 2.0e-09;
! 					}
! 					else if(vdd_cell == 0.4)
! 					{
! 						I_on_n = 7.663043e-05;
! 						I_on_p = 6.456522e-05;
! 						I_off_n = 2.565217e-09;
! 						I_off_p = 2.5e-09;
! 					}
! 					else if(vdd_cell == 0.5)
! 					{
! 						I_on_n = 1.91304e-04;
! 						I_on_p = 1.66304e-04;
! 						I_off_n = 3.304348e-09;
! 						I_off_p = 3.195652e-09;
! 					}
! 					else if(vdd_cell == 0.6)
! 					{
! 						I_on_n = 3.40217e-04;
! 						I_on_p = 3.02174e-04;
! 						I_off_n = 4.217391e-09;
! 						I_off_p = 4.054348e-09;
! 					}
! 					else if(vdd_cell == 0.7)
! 					{
! 						I_on_n = 5.07609e-04;
! 						I_on_p = 4.57609e-04;
! 						I_off_n = 5.336957e-09;
! 						I_off_p = 5.130435e-09;
! 					}
! 					else if(vdd_cell == 0.8)
! 					{
! 						I_on_n = 6.86957e-04;
! 						I_on_p = 6.23913e-04;
! 						I_off_n = 6.684783e-09;
! 						I_off_p = 6.478261e-09;
! 					}
! 					I_on_n_to_I_on_p_ratio = 1.219047619;
! 				}
  			}
  
! 			/***** Alireza - BEGIN *****/
! 			if (g_ip->is_finfet) {
! 				vbit_sense_min = 0.04;
! 				g_tp.sram_cell.P_fin   += curr_alpha * p_fin;
! 				g_tp.sram_cell.H_fin   += curr_alpha * h_fin;
! 				g_tp.sram_cell.T_si    += curr_alpha * t_si;
! 				g_tp.sram_cell.W_fin   += curr_alpha * w_fin;
! 				// FinFET-based SRAM cell properties:
! 				double sram_cell_height, sram_cell_width;
! 				sram_cell_height = g_ip->sram_cell_design.calc_height(lambda_um);
! 				sram_cell_width = g_ip->sram_cell_design.calc_width(lambda_um, p_fin, t_si);
! 				int n[5];
! 				g_ip->sram_cell_design.getNfins(n);
! 
! 				curr_Wmemcella_sram      = n[0] * (2*h_fin + w_fin); //w_fin;
! 				curr_Wmemcellpmos_sram   = n[1] * (2*h_fin + w_fin); //w_fin;
! 				curr_Wmemcellnmos_sram   = n[2] * (2*h_fin + w_fin); //w_fin;
! 				curr_Wmemcellrdiso_sram  = n[3] * (2*h_fin + w_fin); //w_fin;
! 				curr_Wmemcellrda_sram    = n[4] * (2*h_fin + w_fin); //w_fin;
! 				curr_area_cell_sram      = sram_cell_height * sram_cell_width;
! 				curr_asp_ratio_cell_sram = sram_cell_height / sram_cell_width;
! 
! 				//CAM cell properties //TODO: data need to be revisited
! 				//divya added 12-11-2021
! 				curr_Wmemcella_cam 		= curr_Wmemcella_sram;
! 				curr_Wmemcellpmos_cam 	= curr_Wmemcellpmos_sram;
! 				curr_Wmemcellnmos_cam 	= curr_Wmemcellnmos_sram;
! 				curr_area_cell_cam 		= 2*curr_area_cell_sram;	//divya added based on ratios found in mcpat cacti
! 				curr_asp_ratio_cell_cam = 2*curr_asp_ratio_cell_sram; //divya added based on ratios found in mcpat cacti
! 
! 			} else {	//cmos
! 				vbit_sense_min = 0.08;
! 				// CMOS-based SRAM cell properties:
! 				if ( g_ip->sram_cell_design.getType() == std_6T ) {
! 					curr_Wmemcella_sram      = 1.31 * g_ip->F_sz_um;
! 					curr_Wmemcellpmos_sram   = 1.23 * g_ip->F_sz_um;
! 					curr_Wmemcellnmos_sram   = 2.08 * g_ip->F_sz_um;
! 					curr_area_cell_sram      = 146 * g_ip->F_sz_um * g_ip->F_sz_um;
! 					curr_asp_ratio_cell_sram = 1.46;
! 				} else if ( g_ip->sram_cell_design.getType() == std_8T ) {
! 					// Source: Chang et al., "Stable SRAM cell design for the 32 nm node and beyond," VLSI Symposia 2005.
! 					curr_Wmemcella_sram      = 1.0 * g_ip->F_sz_um;
! 					curr_Wmemcellpmos_sram   = 1.0 * g_ip->F_sz_um;
! 					curr_Wmemcellnmos_sram   = 1.0 * g_ip->F_sz_um;
! 					curr_Wmemcellrda_sram    = 1.0 * g_ip->F_sz_um;
! 					curr_Wmemcellrdiso_sram  = 3.5 * g_ip->F_sz_um;
! 					curr_area_cell_sram      = 195 * g_ip->F_sz_um * g_ip->F_sz_um;
! 					curr_asp_ratio_cell_sram = 0.36;
! 				} else {
! 					cout << "ERROR: Invalid SRAM cell type in technology.cc!\n";
! 					exit(0);
! 				}
! 			}
  
! 			g_tp.Vbit_sense_min = vbit_sense_min;
  
! 			delta_L = (g_ip->is_finfet) ? (2*0.8*Xj) : (0.8*Xj);
! 	//		c_g_ideal = Lphy * c_ox;	//Divya :: c_g_ideal changes with voltage for NCFET, this is no longer valid
! 			c_g_ideal = (g_ip->is_finfet) ? c_gate : (Lphy * c_ox);	//Divya added this . (in F, not in F/um)
! 
! 			Lelec = Lphy - delta_L;
! 			if ( Lelec <=0 ) {
! 				cout << "ERROR: Lelec (ram_cell) is not a positive value! Please check the Lphy or the Xj value.\n";
! 				exit(0);
  			}
! 			n_to_p_eff_curr_drv_ratio = I_on_n_to_I_on_p_ratio; //1.219047619; //Finfet //I_on_n / I_on_p; (original) //Divya replaced this value with Max(I_on_n/I_on_p for all voltages) //1.4642857143 //NCFET
! 			Rnchannelon = vdd_cell / I_on_n;
! 			Rpchannelon = vdd_cell / I_on_p;
! 			g_tp.sram_cell.Vdd       += curr_alpha * vdd_cell;
! 			g_tp.sram_cell.l_phy     += curr_alpha * Lphy;
! 			g_tp.sram_cell.l_elec    += curr_alpha * Lelec;
! 			g_tp.sram_cell.t_ox      += curr_alpha * t_ox;
! 			g_tp.sram_cell.Vth       += curr_alpha * v_th;
! 			g_tp.sram_cell.C_g_ideal += curr_alpha * c_g_ideal;
! 			g_tp.sram_cell.C_fringe  += curr_alpha * c_fringe;
! 			g_tp.sram_cell.C_junc    += curr_alpha * c_junc;
! 			g_tp.sram_cell.C_junc_sidewall = c_junc_sidewall;
! 			g_tp.sram_cell.I_on_n    += curr_alpha * I_on_n;
! 			g_tp.sram_cell.I_on_p    += curr_alpha * I_on_p;
! 			g_tp.sram_cell.I_off_n   += curr_alpha * I_off_n;
! 			g_tp.sram_cell.I_off_p   += curr_alpha * I_off_p;
! 			g_tp.sram_cell.R_nch_on  += curr_alpha * Rnchannelon;
! 			g_tp.sram_cell.R_pch_on  += curr_alpha * Rpchannelon;
! 			g_tp.sram_cell.n_to_p_eff_curr_drv_ratio += curr_alpha * n_to_p_eff_curr_drv_ratio;
! 			/****** Alireza - END ******/
! 			//divya adding 12-11-2021
! 			g_tp.cam_cell.Vdd       += curr_alpha * vdd_cell;
! 			g_tp.cam_cell.l_phy     += curr_alpha * Lphy;
! 			g_tp.cam_cell.l_elec    += curr_alpha * Lelec;
! 			g_tp.cam_cell.t_ox      += curr_alpha * t_ox;
! 			g_tp.cam_cell.Vth       += curr_alpha * v_th;
! 			g_tp.cam_cell.C_g_ideal += curr_alpha * c_g_ideal;
! 			g_tp.cam_cell.C_fringe  += curr_alpha * c_fringe;
! 			g_tp.cam_cell.C_junc    += curr_alpha * c_junc;
! 			g_tp.cam_cell.C_junc_sidewall = c_junc_sidewall;
! 			g_tp.cam_cell.I_on_n    += curr_alpha * I_on_n;
! 			g_tp.cam_cell.I_on_p    += curr_alpha * I_on_p;
! 			g_tp.cam_cell.R_nch_on  += curr_alpha * Rnchannelon;
! 			g_tp.cam_cell.R_pch_on  += curr_alpha * Rpchannelon;
! 			g_tp.cam_cell.n_to_p_eff_curr_drv_ratio += curr_alpha * n_to_p_eff_curr_drv_ratio;
! 			g_tp.cam_cell.I_off_n   += curr_alpha * I_off_n;//*pow(g_tp.cam_cell.Vdd/g_tp.cam_cell.Vdd_default,4);
! 			g_tp.cam_cell.I_off_p   += curr_alpha * I_off_n;//**pow(g_tp.cam_cell.Vdd/g_tp.cam_cell.Vdd_default,4);
! 
! 
! 			// Divya begin. To update SRAM cell Ioff when dvs is true
! //			if(g_ip->is_dvs && g_ip->is_finfet) {
! 			if((!g_ip->dvs_voltage.empty()) && g_ip->is_finfet) {
! 			//Considering for 6T SRAM cell only, not for 8T sram cell
! 				Ioffs[0] = g_tp.sram_cell.I_off_n;	//acc
! 				Ioffs[1] = g_tp.sram_cell.I_off_p; //pup
! 				Ioffs[2] = g_tp.sram_cell.I_off_n; //pdn
  
! 				g_ip->sram_cell_design.setTransistorParams(g_ip->Nfins, g_ip->Lphys, Ioffs);
! //				cout << "Io : " << Ioffs[0] << ", I1 : " << Ioffs[1] << ", I2 : " << Ioffs[2] << endl;
! 			}
! 			//-------------------- cell parameters end ----------------------------
  
! 			//-------------------- peripheral parameters begin --------------------
! 			Lphy = 0.02;	//20-nm represented in um
! 			Xj = 0;
! 
! 			//for finfet or cmos check. finfets can be FinFET or NCFET which is captured in is_ncfet
! 			if(g_ip->is_finfet) {
! 				if(g_ip->is_ncfet)	//NCFET
! 					t_ox = 0.00043;	//0.43nm represented in um
! 				else	//Finfet
! 					t_ox = 0.001;	//1nm represented in um
! 			}
  
! 			//FinFET and NCFET have same values for below parameters
! 			if ( g_ip->is_finfet ) {
! 				t_si = 0.008;	//8-nm
! 				h_fin = 0.042;	//42nm represented in um
! 				p_fin = 0.042; 	//42nm represented in um
! 				w_fin = 0.008;	//8-nm
! 			}
  
! 			vdd_peri = g_ip->vdd;
! 			//for finfet or cmos check. finfets can be FinFET or NCFET which is captured in is_ncfet
! 			if ( g_ip->is_finfet ) {
! 				if(g_ip->is_ncfet)	//NCFET
! 				{
! 					if(vdd_peri == 0.2) {
! 						v_th = 0.202;
! 						Vdsat= 0.0569;
! 					} else if(vdd_peri == 0.3) {
! 						v_th = 0.201;
! 						Vdsat= 0.0782;
! 					} else if(vdd_peri == 0.4) {
! 						v_th = 0.205;
! 						Vdsat= 0.1315;
! 					} else if(vdd_peri == 0.5) {
! 						v_th = 0.21;
! 						Vdsat= 0.21;
! 					} else if(vdd_peri == 0.6) {
! 						v_th = 0.215;
! 						Vdsat= 0.3015;
! 					} else if(vdd_peri == 0.7) {
! 						v_th = 0.2195;
! 						Vdsat= 0.3995;
! 					} else if(vdd_peri == 0.8) {
! 						v_th = 0.2245;
! 						Vdsat= 0.5005;
! 					}
! 				}
! 				else //FinFET
! 				{
! 					if(vdd_peri == 0.2) {
! 						v_th = 0.262;
! 						Vdsat= 0.048;
! 					} else if(vdd_peri == 0.3) {
! 						v_th = 0.261;
! 						Vdsat= 0.05675;
! 					} else if(vdd_peri == 0.4) {
! 						v_th = 0.2565;
! 						Vdsat= 0.08705;
! 					} else if(vdd_peri == 0.5) {
! 						v_th = 0.251;
! 						Vdsat= 0.132;
! 					} else if(vdd_peri == 0.6) {
! 						v_th = 0.2455;
! 						Vdsat= 0.1845;
! 					} else if(vdd_peri == 0.7) {
! 						v_th = 0.24;
! 						Vdsat= 0.242;
! 					} else if(vdd_peri == 0.8) {
! 						v_th = 0.235;
! 						Vdsat= 0.3025;
! 					}
! 				}
! 			}
  
! 			//for finfet or cmos check. finfets can be FinFET or NCFET which is captured in is_ncfet
! 			if ( g_ip->is_finfet ) {
! 				if(g_ip->is_ncfet)	//NCFET
! 				{
! 					c_ox 					= 2.9e-13;	//f/um2
! 					c_fringe 				= 2.29891e-16; //f/um
! 					c_junc 					= 5.0e-16; //f/um2
! 					c_junc_sidewall 		= 5.0e-16; //f/um
! 					c_junc_sidewall_gate 	= 0;
! 					mobility_eff 			= 242e8;
! 					gmp_to_gmn_multiplier 	= 1.38;
! 
! 					if(vdd_peri == 0.2)
! 						c_gate = 2.53804e-16;	//f/um
! 					else if(vdd_peri == 0.3)
! 						c_gate = 6.09783e-16;
! 					else if(vdd_peri == 0.4)
! 						c_gate = 6.79891e-16;
! 					else if(vdd_peri == 0.5)
! 						c_gate = 7.33696e-16;
! 					else if(vdd_peri == 0.6)
! 						c_gate = 7.760874e-16;
! 					else if(vdd_peri == 0.7)
! 						c_gate = 8.11957e-16;
! 					else if(vdd_peri == 0.8)
! 						c_gate = 8.375e-16;
! 				}
! 				else //FinFET
! 				{
! 					c_ox 					= 3.67e-14;	//f/um2
! 					c_fringe 				= 2.29891e-16; //f/um
! 					c_junc 					= 5.0e-16; //f/um2
! 					c_junc_sidewall 		= 5.0e-16; //f/um
! 					c_junc_sidewall_gate 	= 0;
! 					mobility_eff 			= 242e8;
! 					gmp_to_gmn_multiplier 	= 1.38;
! 
! 					if(vdd_peri == 0.2)
! 						c_gate = 4.18478e-18;
! 					else if(vdd_peri == 0.3)
! 						c_gate = 5.49457e-17;
! 					else if(vdd_peri == 0.4)
! 						c_gate = 1.375e-16;
! 					else if(vdd_peri == 0.5)
! 						c_gate = 1.85326e-16;
! 					else if(vdd_peri == 0.6)
! 						c_gate = 2.14674e-16;
! 					else if(vdd_peri == 0.7)
! 						c_gate = 2.364133e-16;
! 					else if(vdd_peri == 0.8)
! 						c_gate = 2.52717e-16;
! 				}
! 			}
! 			//Divya : end
  
! 			//for finfet or cmos check. finfets can be FinFET or NCFET which is captured in is_ncfet
! 			if ( g_ip->is_finfet ) {
! 				if(g_ip->is_ncfet)	//NCFET
! 				{
! 					if(vdd_peri == 0.2)
! 					{
! 						I_on_n = 4.456522e-06;	// Amp/um
! 						I_on_p = 3.043478e-06;	// Amp/um
! 						I_off_n = 1.51087e-09;	// Amp/um
! 						I_off_p = 2.163043e-09;	// Amp/um
! 					}
! 					else if(vdd_peri == 0.3)
! 					{
! 						I_on_n = 4.315217e-05;
! 						I_on_p = 3.75e-05;
! 						I_off_n = 1.304348e-09;
! 						I_off_p = 1.771739e-09;
! 					}
! 					else if(vdd_peri == 0.4)
! 					{
! 						I_on_n = 1.6413e-04;
! 						I_on_p = 1.59783e-04;
! 						I_off_n = 1.119565e-09;
! 						I_off_p = 1.456522e-09;
! 					}
! 					else if(vdd_peri == 0.5)
! 					{
! 						I_on_n = 3.82609e-04;
! 						I_on_p = 3.53261e-04;
! 						I_off_n = 1.0e-09;
! 						I_off_p = 1.184783e-09;
! 					}
! 					else if(vdd_peri == 0.6)
! 					{
! 						I_on_n = 6.59783e-04;
! 						I_on_p = 5.81522e-04;
! 						I_off_n = 8.119565e-10;
! 						I_off_p = 1.0e-09;
! 					}
! 					else if(vdd_peri == 0.7)
! 					{
! 						I_on_n = 9.65217e-04;
! 						I_on_p = 8.09783e-04;
! 						I_off_n = 6.880435e-10;
! 						I_off_p = 7.836957e-10;
! 					}
! 					else if(vdd_peri == 0.8)
! 					{
! 						I_on_n = 1.206522e-03;
! 						I_on_p = 1.047826e-03;
! 						I_off_n = 5.836957e-10;
! 						I_off_p = 6.39565e-10;
! 					}
! 					I_on_n_to_I_on_p_ratio = 1.4642857143;
! 				}
! 				else //FinFET
! 				{
! 					if(vdd_peri == 0.2)
! 					{
! 						I_on_n = 7.728261e-07;
! 						I_on_p = 6.586957e-07;
! 						I_off_n = 1.489133e-09;
! 						I_off_p = 1.532609e-09;
! 					}
! 					else if(vdd_peri == 0.3)
! 					{
! 						I_on_n = 1.3913e-05;
! 						I_on_p = 1.1413e-05;
! 						I_off_n = 2.0e-09;
! 						I_off_p = 2.0e-09;
! 					}
! 					else if(vdd_peri == 0.4)
! 					{
! 						I_on_n = 7.663043e-05;
! 						I_on_p = 6.456522e-05;
! 						I_off_n = 2.565217e-09;
! 						I_off_p = 2.5e-09;
! 					}
! 					else if(vdd_peri == 0.5)
! 					{
! 						I_on_n = 1.91304e-04;
! 						I_on_p = 1.66304e-04;
! 						I_off_n = 3.304348e-09;
! 						I_off_p = 3.195652e-09;
! 					}
! 					else if(vdd_peri == 0.6)
! 					{
! 						I_on_n = 3.40217e-04;
! 						I_on_p = 3.02174e-04;
! 						I_off_n = 4.217391e-09;
! 						I_off_p = 4.054348e-09;
! 					}
! 					else if(vdd_peri == 0.7)
! 					{
! 						I_on_n = 5.07609e-04;
! 						I_on_p = 4.57609e-04;
! 						I_off_n = 5.336957e-09;
! 						I_off_p = 5.130435e-09;
! 					}
! 					else if(vdd_peri == 0.8)
! 					{
! 						I_on_n = 6.86957e-04;
! 						I_on_p = 6.23913e-04;
! 						I_off_n = 6.684783e-09;
! 						I_off_p = 6.478261e-09;
! 					}
! 					I_on_n_to_I_on_p_ratio = 1.219047619;
! 				}
! 			}
  
! 	        //Empirical undifferetiated core/FU coefficient
! 	        curr_logic_scaling_co_eff = 0.7*0.7*0.7*0.7*0.7;	//at 16-nm cmos
! 	        curr_core_tx_density      = 1.25/0.7/0.7/0.7;		//at 16-nm cmos
! 
! //	        curr_logic_scaling_co_eff = 0.7*0.7*0.7*0.7*0.7*0.7;
! //	        curr_core_tx_density      = 1.25/0.7/0.7/0.7/0.7;
! 
! 	        curr_sckt_co_eff           = 1.1296;
! 	        curr_chip_layout_overhead  = 1.2;//die measurement results based on Niagara 1 and 2
! 	        curr_macro_layout_overhead = 1.1;//EDA placement and routing tool rule of thumb
! /*
! 			//Empirical undifferetiated core/FU coefficient
! 			curr_logic_scaling_co_eff 	= 1.0;
! 			curr_core_tx_density      	= 1.0;
! 			curr_sckt_co_eff           	= 1.0;
! 			curr_chip_layout_overhead  	= 1.0;//die measurement results based on Niagara 1 and 2
! 			curr_macro_layout_overhead 	= 1.0;//EDA placement and routing tool rule of thumb
! */
! 			if (g_ip->is_finfet) {
! 				g_tp.peri_global.P_fin += curr_alpha * p_fin;
! 				g_tp.peri_global.H_fin += curr_alpha * h_fin;
! 				g_tp.peri_global.T_si  += curr_alpha * t_si;
! 				g_tp.peri_global.W_fin += curr_alpha * w_fin;
! 			}
! 			c_g_ideal = c_gate;	// Divya modified this to include data given (in F, not in F/um)
  
+ 			delta_L = (g_ip->is_finfet) ? (2*0.8*Xj) : (0.8*Xj);
+ 
+ 			Lelec = Lphy - delta_L;
+ 			if ( Lelec <= 0 ) {
+ 				cout << "ERROR: Lelec (peri_global) is not a positive value! Please check the Lphy or the Xj value.\n";
+ 				exit(0);
+ 			}
+ 			n_to_p_eff_curr_drv_ratio = I_on_n_to_I_on_p_ratio; //Divya added; //1.219047619; //Finfet //I_on_n / I_on_p; (original) //Divya replaced this value with Max(I_on_n/I_on_p for all voltages) //1.4642857143 //NCFET
+ 			Rnchannelon = vdd_peri / I_on_n;
+ 			Rpchannelon = vdd_peri / I_on_p;
+ 			g_tp.peri_global.Vdd       += curr_alpha * vdd_peri;
+ 			g_tp.peri_global.t_ox      += curr_alpha * t_ox;
+ 			g_tp.peri_global.Vth       += curr_alpha * v_th;
+ 			g_tp.peri_global.C_ox      += curr_alpha * c_ox;
+ 			g_tp.peri_global.C_g_ideal += curr_alpha * c_g_ideal;
+ 			g_tp.peri_global.C_fringe  += curr_alpha * c_fringe;
+ 			g_tp.peri_global.C_junc    += curr_alpha * c_junc;
+ 			g_tp.peri_global.C_junc_sidewall = c_junc_sidewall;
+ 			g_tp.peri_global.l_phy     += curr_alpha * Lphy;
+ 			g_tp.peri_global.l_elec    += curr_alpha * Lelec;
+ 			g_tp.peri_global.I_on_n    += curr_alpha * I_on_n;
+ 			g_tp.peri_global.I_off_n   += curr_alpha * I_off_n;
+ 			g_tp.peri_global.I_off_p   += curr_alpha * I_off_p;
+ 			g_tp.peri_global.R_nch_on  += curr_alpha * Rnchannelon;
+ 			g_tp.peri_global.R_pch_on  += curr_alpha * Rpchannelon;
+ 			g_tp.peri_global.n_to_p_eff_curr_drv_ratio += curr_alpha * n_to_p_eff_curr_drv_ratio;
+ 			gmp_to_gmn_multiplier_periph_global += curr_alpha * gmp_to_gmn_multiplier;
  
+ 		}	//end of 14-nm data
+ // Divya Modifying end --
  
  		// TO DO: Update This!
  		//-------------------- dram parameters begin --------------------------
  		c_g_ideal = Lphy_dram * c_ox_dram;
  		Lelec = Lphy_dram - delta_L;
! 
  		n_to_p_eff_curr_drv_ratio = I_on_n_dram / I_on_p_dram;
! 		Rnchannelon = nmos_effective_resistance_multiplier*curr_vdd_dram_cell / I_on_n_dram;
! 		Rpchannelon = n_to_p_eff_curr_drv_ratio*Rnchannelon;
! 		g_tp.dram_cell_Vdd      += curr_alpha * curr_vdd_dram_cell;	//ok
! 		g_tp.dram_acc.Vth       += curr_alpha * curr_v_th_dram_access_transistor;	//ok
! 		g_tp.dram_acc.l_phy     += curr_alpha * Lphy_dram;	//ok
  		g_tp.dram_acc.l_elec    += curr_alpha * Lelec;
! 		g_tp.dram_acc.C_g_ideal += curr_alpha * c_g_ideal;	//c_g_ideal
  		g_tp.dram_acc.C_fringe  += curr_alpha * c_fringe_dram;
  		g_tp.dram_acc.C_junc    += curr_alpha * c_junc_dram;
! 		g_tp.dram_acc.C_junc_sidewall = (g_ip->is_finfet) ? c_junc_sidewall:  0.25e-15; //F/um
  		g_tp.dram_cell_I_on     += curr_alpha * curr_I_on_dram_cell;
  		g_tp.dram_cell_I_off_worst_case_len_temp += curr_alpha * curr_I_off_dram_cell_worst_case_length_temp;
  		g_tp.dram_acc.I_on_n    += curr_alpha * I_on_n_dram;
***************
*** 558,573 ****
  		g_tp.dram_wl.C_g_ideal  += curr_alpha * c_g_ideal;
  		g_tp.dram_wl.C_fringe   += curr_alpha * c_fringe_dram;
  		g_tp.dram_wl.C_junc     += curr_alpha * c_junc_dram;
! 		g_tp.dram_wl.C_junc_sidewall = c_junc_sidewall;
  		g_tp.dram_wl.I_on_n     += curr_alpha * I_on_n_dram;
  		g_tp.dram_wl.I_off_n    += curr_alpha * I_off_n_dram;
! 		g_tp.dram_wl.I_off_p    += curr_alpha * I_off_p_dram;
  		g_tp.dram_wl.R_nch_on   += curr_alpha * Rnchannelon;
  		g_tp.dram_wl.R_pch_on   += curr_alpha * Rpchannelon;
  		g_tp.dram_wl.n_to_p_eff_curr_drv_ratio += curr_alpha * n_to_p_eff_curr_drv_ratio;
  		//-------------------- dram parameters end ----------------------------
  
- 
  		g_tp.dram.cell_a_w    += curr_alpha * curr_Wmemcella_dram;
  		g_tp.dram.cell_pmos_w += curr_alpha * curr_Wmemcellpmos_dram;
  		g_tp.dram.cell_nmos_w += curr_alpha * curr_Wmemcellnmos_dram;
--- 1088,1102 ----
  		g_tp.dram_wl.C_g_ideal  += curr_alpha * c_g_ideal;
  		g_tp.dram_wl.C_fringe   += curr_alpha * c_fringe_dram;
  		g_tp.dram_wl.C_junc     += curr_alpha * c_junc_dram;
! 		g_tp.dram_wl.C_junc_sidewall =  (g_ip->is_finfet) ? c_junc_sidewall:  0.25e-15; //F/um;
  		g_tp.dram_wl.I_on_n     += curr_alpha * I_on_n_dram;
  		g_tp.dram_wl.I_off_n    += curr_alpha * I_off_n_dram;
! 		g_tp.dram_wl.I_off_p    += curr_alpha * I_off_n_dram;
  		g_tp.dram_wl.R_nch_on   += curr_alpha * Rnchannelon;
  		g_tp.dram_wl.R_pch_on   += curr_alpha * Rpchannelon;
  		g_tp.dram_wl.n_to_p_eff_curr_drv_ratio += curr_alpha * n_to_p_eff_curr_drv_ratio;
  		//-------------------- dram parameters end ----------------------------
  
  		g_tp.dram.cell_a_w    += curr_alpha * curr_Wmemcella_dram;
  		g_tp.dram.cell_pmos_w += curr_alpha * curr_Wmemcellpmos_dram;
  		g_tp.dram.cell_nmos_w += curr_alpha * curr_Wmemcellnmos_dram;
***************
*** 582,592 ****
  		area_cell_sram          += curr_alpha * curr_area_cell_sram;
  		asp_ratio_cell_sram     += curr_alpha * curr_asp_ratio_cell_sram;
  		
  		//Sense amplifier latch Gm calculation
  		mobility_eff_periph_global += curr_alpha * mobility_eff; 
  		Vdsat_periph_global        += curr_alpha * Vdsat;
- 	}
  
  	
  	// TO DO: Update transistor sizes for FinFETs
  	// Alireza: for CMOS we have "N * g_ip->F_sz_um", but this should be changed for FinFETs
--- 1111,1137 ----
  		area_cell_sram          += curr_alpha * curr_area_cell_sram;
  		asp_ratio_cell_sram     += curr_alpha * curr_asp_ratio_cell_sram;
  		
+ 	//			cout << "sram : curr_Wmemcella_sram : " << curr_Wmemcella_sram << ", curr_Wmemcellpmos_sram : " << curr_Wmemcellpmos_sram  << ", curr_Wmemcellnmos_sram : " << curr_Wmemcellnmos_sram <<
+ 	//			", curr_area_cell_sram : " << curr_area_cell_sram << ", curr_asp_ratio_cell_sram : " << curr_asp_ratio_cell_sram << ", curr_alpha : " << curr_alpha << endl;
+ 	    g_tp.cam.cell_a_w    += curr_alpha * curr_Wmemcella_cam;//sheng
+ 	    g_tp.cam.cell_pmos_w += curr_alpha * curr_Wmemcellpmos_cam;
+ 	    g_tp.cam.cell_nmos_w += curr_alpha * curr_Wmemcellnmos_cam;
+ 	    area_cell_cam += curr_alpha * curr_area_cell_cam;
+ 	    asp_ratio_cell_cam += curr_alpha * curr_asp_ratio_cell_cam;
+ 
  		//Sense amplifier latch Gm calculation
  		mobility_eff_periph_global += curr_alpha * mobility_eff; 
  		Vdsat_periph_global        += curr_alpha * Vdsat;
  
+ 	    //Empirical undifferetiated core/FU coefficient
+ 	    g_tp.scaling_factor.logic_scaling_co_eff += curr_alpha * curr_logic_scaling_co_eff;
+ 	    g_tp.scaling_factor.core_tx_density += curr_alpha * curr_core_tx_density;
+ 	    g_tp.chip_layout_overhead  += curr_alpha * curr_chip_layout_overhead;
+ 	    g_tp.macro_layout_overhead += curr_alpha * curr_macro_layout_overhead;
+ 	    g_tp.sckt_co_eff           += curr_alpha * curr_sckt_co_eff;
+ 
+ //	    cout << "tech: " << tech << ", scaling: " << g_tp.scaling_factor.logic_scaling_co_eff << endl;
+ 	}	//end of iter loop
  	
  	// TO DO: Update transistor sizes for FinFETs
  	// Alireza: for CMOS we have "N * g_ip->F_sz_um", but this should be changed for FinFETs
***************
*** 611,626 ****
  	g_tp.spacing_poly_to_poly = 1.5 * g_ip->F_sz_um;
  	g_tp.ram_wl_stitching_overhead_ = 7.5 * g_ip->F_sz_um;
  	
! 	/***** Alireza - BEGIN *****/
! 	if ( g_ip->is_finfet ) {
! 		g_tp.min_w_nmos_ = 2 * g_tp.peri_global.H_fin;
  		// transistor sizing of the finfet-based sense amplifier
! 		g_tp.w_iso       = 1 * 2 * h_fin; // 1 fin
! 		g_tp.w_sense_n   = 1 * 2 * h_fin; // 1 fin
! 		g_tp.w_sense_p   = 1 * 2 * h_fin; // 1 fin
! 		g_tp.w_sense_en  = 1 * 2 * h_fin; // 1 fin
! 		//g_tp.NAND2_LEAK_STACK_FACTOR = 
! 	} else {
  		g_tp.min_w_nmos_ = 3 * g_ip->F_sz_um / 2;
  		// transistor sizing of the cmos-based sense amplifier
  		g_tp.w_iso       = 12.5 * g_ip->F_sz_um; // was 10 micron for the 0.8 micron process
--- 1156,1172 ----
  	g_tp.spacing_poly_to_poly = 1.5 * g_ip->F_sz_um;
  	g_tp.ram_wl_stitching_overhead_ = 7.5 * g_ip->F_sz_um;
  	
! //Divya changes begin
! 	if ( g_ip->is_finfet) {	//  && g_ip->F_sz_um == 0.014 ) {
! 		g_tp.min_w_nmos_ = 2 * g_tp.peri_global.H_fin + g_tp.peri_global.W_fin; //g_tp.peri_global.W_fin;
  		// transistor sizing of the finfet-based sense amplifier
! 		g_tp.w_iso       = 1 * (2 * h_fin + w_fin); //w_fin; // 1 fin
! 		g_tp.w_sense_n   = 1 * (2 * h_fin + w_fin); //w_fin;; // 1 fin
! 		g_tp.w_sense_p   = 1 * (2 * h_fin + w_fin); //w_fin;; // 1 fin
! 		g_tp.w_sense_en  = 1 * (2 * h_fin + w_fin); //w_fin;; // 1 fin
! 		//g_tp.NAND2_LEAK_STACK_FACTOR =
! 	} //Divya changes end
! 	else {
  		g_tp.min_w_nmos_ = 3 * g_ip->F_sz_um / 2;
  		// transistor sizing of the cmos-based sense amplifier
  		g_tp.w_iso       = 12.5 * g_ip->F_sz_um; // was 10 micron for the 0.8 micron process
***************
*** 642,676 ****
  		g_tp.h_dec          = 4;  // in the unit of memory cell height
  	}
  
! 	g_tp.peri_global.C_overlap = 0.2 * g_tp.peri_global.C_g_ideal;
! 	g_tp.sram_cell.C_overlap   = 0.2 * g_tp.sram_cell.C_g_ideal;
  
- 	g_tp.dram_acc.C_overlap = 0.2 * g_tp.dram_acc.C_g_ideal;
  	g_tp.dram_acc.R_nch_on = g_tp.dram_cell_Vdd / g_tp.dram_acc.I_on_n;
  	//g_tp.dram_acc.R_pch_on = g_tp.dram_cell_Vdd / g_tp.dram_acc.I_on_p;
  
- 	g_tp.dram_wl.C_overlap = 0.2 * g_tp.dram_wl.C_g_ideal;
- 
  	double gmn_sense_amp_latch = (mobility_eff_periph_global / 2) * g_tp.peri_global.C_ox * (g_tp.w_sense_n / g_tp.peri_global.l_elec) * Vdsat_periph_global;
  	double gmp_sense_amp_latch = gmp_to_gmn_multiplier_periph_global * gmn_sense_amp_latch;
! 	g_tp.gm_sense_amp_latch = gmn_sense_amp_latch + gmp_sense_amp_latch;
  
  	g_tp.dram.b_w = sqrt(area_cell_dram / (asp_ratio_cell_dram));
  	g_tp.dram.b_h = asp_ratio_cell_dram * g_tp.dram.b_w;
  	g_tp.sram.b_w = sqrt(area_cell_sram / (asp_ratio_cell_sram));
  	g_tp.sram.b_h = asp_ratio_cell_sram * g_tp.sram.b_w;
  
  	g_tp.dram.Vbitpre = g_tp.dram_cell_Vdd;
! 	g_tp.sram.Vbitpre = vdd_cell;
  	pmos_to_nmos_sizing_r = pmos_to_nmos_sz_ratio();
  	g_tp.w_pmos_bl_precharge = 6 * pmos_to_nmos_sizing_r * g_tp.min_w_nmos_;
  	g_tp.w_pmos_bl_eq = pmos_to_nmos_sizing_r * g_tp.min_w_nmos_;
  
- 	 
  	//-------------------- interconnect (wire) parameters begin --------------------------
      double wire_pitch       [NUMBER_INTERCONNECT_PROJECTION_TYPES][NUMBER_WIRE_TYPES],
             wire_r_per_micron[NUMBER_INTERCONNECT_PROJECTION_TYPES][NUMBER_WIRE_TYPES],
!            wire_c_per_micron[NUMBER_INTERCONNECT_PROJECTION_TYPES][NUMBER_WIRE_TYPES];
  
      for (iter=0; iter<=1; ++iter)
      {
--- 1188,1276 ----
  		g_tp.h_dec          = 4;  // in the unit of memory cell height
  	}
  
! 	if ( g_ip->is_finfet) {	//  && g_ip->F_sz_um == 0.014) {
! 		g_tp.peri_global.C_overlap = 0;
! 		g_tp.sram_cell.C_overlap   = 0;
! 		g_tp.cam_cell.C_overlap    = 0;
! 		g_tp.dram_acc.C_overlap    = 0;
! 		g_tp.dram_wl.C_overlap 	   = 0;
! 	} else {
! 	  g_tp.peri_global.C_overlap = 0.2 * g_tp.peri_global.C_g_ideal;
! 	  g_tp.sram_cell.C_overlap   = 0.2 * g_tp.sram_cell.C_g_ideal;
! 	  g_tp.cam_cell.C_overlap    = 0.2 * g_tp.cam_cell.C_g_ideal;
! 	  g_tp.dram_acc.C_overlap 	 = 0.2 * g_tp.dram_acc.C_g_ideal;
! 	  g_tp.dram_wl.C_overlap 	 = 0.2 * g_tp.dram_wl.C_g_ideal;
! 	}
  
  	g_tp.dram_acc.R_nch_on = g_tp.dram_cell_Vdd / g_tp.dram_acc.I_on_n;
  	//g_tp.dram_acc.R_pch_on = g_tp.dram_cell_Vdd / g_tp.dram_acc.I_on_p;
  
  	double gmn_sense_amp_latch = (mobility_eff_periph_global / 2) * g_tp.peri_global.C_ox * (g_tp.w_sense_n / g_tp.peri_global.l_elec) * Vdsat_periph_global;
  	double gmp_sense_amp_latch = gmp_to_gmn_multiplier_periph_global * gmn_sense_amp_latch;
! 
! 	if(g_ip->is_finfet)
! 		g_tp.gm_sense_amp_latch = gmn_sense_amp_latch + gmp_sense_amp_latch;
! 	else
! 		g_tp.gm_sense_amp_latch = gmn_sense_amp_latch + gmp_sense_amp_latch * pow((g_tp.peri_global.Vdd-g_tp.peri_global.Vth)/(1.0 - g_tp.peri_global.Vth),1.3)/(g_tp.peri_global.Vdd/1.0);
  
  	g_tp.dram.b_w = sqrt(area_cell_dram / (asp_ratio_cell_dram));
  	g_tp.dram.b_h = asp_ratio_cell_dram * g_tp.dram.b_w;
  	g_tp.sram.b_w = sqrt(area_cell_sram / (asp_ratio_cell_sram));
  	g_tp.sram.b_h = asp_ratio_cell_sram * g_tp.sram.b_w;
+ 	g_tp.cam.b_w =  sqrt(area_cell_cam / (asp_ratio_cell_cam));//Sheng
+ 	g_tp.cam.b_h = asp_ratio_cell_cam * g_tp.cam.b_w;
  
  	g_tp.dram.Vbitpre = g_tp.dram_cell_Vdd;
! 	g_tp.sram.Vbitpre = g_tp.sram_cell.Vdd;
!     g_tp.cam.Vbitpre = g_tp.cam_cell.Vdd;//vdd[ram_cell_tech_type];//Sheng
  	pmos_to_nmos_sizing_r = pmos_to_nmos_sz_ratio();
  	g_tp.w_pmos_bl_precharge = 6 * pmos_to_nmos_sizing_r * g_tp.min_w_nmos_;
  	g_tp.w_pmos_bl_eq = pmos_to_nmos_sizing_r * g_tp.min_w_nmos_;
  
  	//-------------------- interconnect (wire) parameters begin --------------------------
      double wire_pitch       [NUMBER_INTERCONNECT_PROJECTION_TYPES][NUMBER_WIRE_TYPES],
             wire_r_per_micron[NUMBER_INTERCONNECT_PROJECTION_TYPES][NUMBER_WIRE_TYPES],
!            wire_c_per_micron[NUMBER_INTERCONNECT_PROJECTION_TYPES][NUMBER_WIRE_TYPES],
!     horiz_dielectric_constant[NUMBER_INTERCONNECT_PROJECTION_TYPES][NUMBER_WIRE_TYPES],
!     vert_dielectric_constant[NUMBER_INTERCONNECT_PROJECTION_TYPES][NUMBER_WIRE_TYPES],
!     aspect_ratio[NUMBER_INTERCONNECT_PROJECTION_TYPES][NUMBER_WIRE_TYPES],
!     miller_value[NUMBER_INTERCONNECT_PROJECTION_TYPES][NUMBER_WIRE_TYPES],
!     ild_thickness[NUMBER_INTERCONNECT_PROJECTION_TYPES][NUMBER_WIRE_TYPES];
! 
!     if ( wire_technology == 90 ) {        // 90nm CMOS
! 		tech_lo = 90; tech_hi = 90;
! 	} else if ( wire_technology == 65 ) { // 65nm CMOS
! 		tech_lo = 65; tech_hi = 65;
! 	} else if ( wire_technology == 45 ) { // 45nm CMOS
! 		tech_lo = 45; tech_hi = 45;
! 	} else if ( wire_technology == 32 ) { // 32nm CMOS
! 		tech_lo = 32; tech_hi = 32;
! 	} else if ( wire_technology == 22 ) { // 22nm CMOS
! 		tech_lo = 22; tech_hi = 22;
! 	} else if ( wire_technology == 16 ) { // 16nm CMOS
! 		tech_lo = 16; tech_hi = 16;
! 	} else if ( wire_technology == 14 ) { // 14nm CMOS
! 		tech_lo = 14; tech_hi = 14;
! 	} else if ( wire_technology == 7 ) {  // 7nm FinFET
! 		tech_lo = 7; tech_hi = 7;
! 	} else if ( wire_technology == 5 ) {  // 5nm FinFET
! 		tech_lo = 5; tech_hi = 5;
! 	} else if ( wire_technology < 90 && wire_technology > 65 ) { // 89nm -- 66nm
! 		tech_lo = 90; tech_hi = 65;
! 	} else if ( wire_technology < 65 && wire_technology > 45 ) { // 64nm -- 46nm
! 		tech_lo = 65; tech_hi = 45;
! 	} else if ( wire_technology < 45 && wire_technology > 32 ) { // 44nm -- 33nm
! 		tech_lo = 45; tech_hi = 32;
! 	} else if ( wire_technology < 32 && wire_technology > 22 ) { // 31nm -- 23nm
! 		tech_lo = 32; tech_hi = 22;
! 	} else if ( wire_technology < 22 && wire_technology > 16 ) { // 21nm -- 17nm
! 		tech_lo = 22; tech_hi = 16;
! 	} else if ( wire_technology < 16 && wire_technology > 14 ) { // 15nm
! 		tech_lo = 16; tech_hi = 14;
! 	} else {
! 		cout << "ERROR: Invalid technology node!" << endl;
! 		exit(0);
! 	}
  
      for (iter=0; iter<=1; ++iter)
      {
***************
*** 680,1054 ****
          if (tech_lo == tech_hi) {
            curr_alpha = 1;
          } else {
!           curr_alpha = (technology - tech_hi)/(tech_lo - tech_hi);
          }
        } else {
          tech = tech_hi;
          if (tech_lo == tech_hi) {
            break;  
          } else {
!           curr_alpha = (tech_lo - technology)/(tech_lo - tech_hi);
          }
        }
  
        if (tech == 90) {
!         //Aggressive projections
!         wire_pitch[0][0] = 2.5 * g_ip->F_sz_um;//micron
!         aspect_ratio = 2.4;
!         wire_width = wire_pitch[0][0] / 2; //micron
!         wire_thickness = aspect_ratio * wire_width;//micron
!         wire_spacing = wire_pitch[0][0] - wire_width;//micron
!         barrier_thickness = 0.01;//micron
!         dishing_thickness = 0;//micron
!         alpha_scatter = 1;
!         wire_r_per_micron[0][0] = wire_resistance(CU_RESISTIVITY, wire_width,
!             wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);//ohm/micron
!         ild_thickness = 0.48;//micron
!         miller_value = 1.5;
!         horiz_dielectric_constant = 2.709;
!         vert_dielectric_constant = 3.9;
!         fringe_cap = 0.115e-15; //F/micron
!         wire_c_per_micron[0][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!             ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
!             fringe_cap);//F/micron.
! 
!         wire_pitch[0][1] = 4 * g_ip->F_sz_um;
!         wire_width = wire_pitch[0][1] / 2;
!         wire_thickness = aspect_ratio * wire_width;
!         wire_spacing = wire_pitch[0][1] - wire_width;
!         wire_r_per_micron[0][1] = wire_resistance(CU_RESISTIVITY, wire_width,
!             wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!         wire_c_per_micron[0][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!             ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
!             fringe_cap);
! 
!         wire_pitch[0][2] = 8 * g_ip->F_sz_um;
!         aspect_ratio = 2.7;
!         wire_width = wire_pitch[0][2] / 2;
!         wire_thickness = aspect_ratio * wire_width;
!         wire_spacing = wire_pitch[0][2] - wire_width;
!         wire_r_per_micron[0][2] = wire_resistance(CU_RESISTIVITY, wire_width,
!             wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!         ild_thickness = 0.96;
!         wire_c_per_micron[0][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!             ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
!             fringe_cap);
! 
!         //Conservative projections
!         wire_pitch[1][0] = 2.5 * g_ip->F_sz_um;
!         aspect_ratio = 2.0;
!         wire_width = wire_pitch[1][0] / 2;
!         wire_thickness = aspect_ratio * wire_width;
!         wire_spacing = wire_pitch[1][0] - wire_width;
!         barrier_thickness = 0.008;
!         dishing_thickness = 0;
!         alpha_scatter = 1;
!         wire_r_per_micron[1][0] = wire_resistance(CU_RESISTIVITY, wire_width,
!             wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!         ild_thickness = 0.48;
!         miller_value = 1.5;
!         horiz_dielectric_constant = 3.038;
!         vert_dielectric_constant = 3.9;
!         fringe_cap = 0.115e-15; 
!         wire_c_per_micron[1][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!             ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
!             fringe_cap);
! 
!         wire_pitch[1][1] = 4 * g_ip->F_sz_um;
!         wire_width = wire_pitch[1][1] / 2;
!         aspect_ratio = 2.0;
!         wire_thickness = aspect_ratio * wire_width;
!         wire_spacing = wire_pitch[1][1] - wire_width;
!         wire_r_per_micron[1][1] = wire_resistance(CU_RESISTIVITY, wire_width,
!             wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!         wire_c_per_micron[1][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!             ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
!             fringe_cap);
! 
!         wire_pitch[1][2] = 8 * g_ip->F_sz_um;
!         aspect_ratio = 2.2;
!         wire_width = wire_pitch[1][2] / 2;
!         wire_thickness = aspect_ratio * wire_width;
!         wire_spacing = wire_pitch[1][2] - wire_width;
!         dishing_thickness = 0.1 *  wire_thickness; 
!         wire_r_per_micron[1][2] = wire_resistance(CU_RESISTIVITY, wire_width,
!             wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!         ild_thickness = 1.1;
!         wire_c_per_micron[1][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!             ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
!             fringe_cap);
!         //Nominal projections for commodity DRAM wordline/bitline
!         wire_pitch[1][3] = 2 * 0.09;
!         wire_c_per_micron[1][3] = 60e-15 / (256 * 2 * 0.09);
!         wire_r_per_micron[1][3] = 12 / 0.09;
!       }
!       else if (tech == 65) {
!         //Aggressive projections
!         wire_pitch[0][0] = 2.5 * g_ip->F_sz_um;
!         aspect_ratio = 2.7;
!         wire_width = wire_pitch[0][0] / 2;
!         wire_thickness = aspect_ratio * wire_width;
!         wire_spacing = wire_pitch[0][0] - wire_width;
!         barrier_thickness = 0;
!         dishing_thickness = 0;
!         alpha_scatter = 1;
!         wire_r_per_micron[0][0] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
!             wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!         ild_thickness = 0.405;
!         miller_value = 1.5;
!         horiz_dielectric_constant = 2.303;
!         vert_dielectric_constant = 3.9;
!         fringe_cap = 0.115e-15; 
!         wire_c_per_micron[0][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!             ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
!             fringe_cap);
  
!         wire_pitch[0][1] = 4 * g_ip->F_sz_um;
!         wire_width = wire_pitch[0][1] / 2;
!         wire_thickness = aspect_ratio * wire_width;
!         wire_spacing = wire_pitch[0][1] - wire_width;
!         wire_r_per_micron[0][1] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
!             wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!         wire_c_per_micron[0][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!             ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
!             fringe_cap);
  
!         wire_pitch[0][2] = 8 * g_ip->F_sz_um;
!         aspect_ratio = 2.8;
!         wire_width = wire_pitch[0][2] / 2;
!         wire_thickness = aspect_ratio * wire_width;
!         wire_spacing = wire_pitch[0][2] - wire_width;
!         wire_r_per_micron[0][2] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
!             wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!         ild_thickness = 0.81;
!         wire_c_per_micron[0][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!             ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
!             fringe_cap);
  
!         //Conservative projections
!         wire_pitch[1][0] = 2.5 * g_ip->F_sz_um;
!         aspect_ratio = 2.0;
!         wire_width = wire_pitch[1][0] / 2;
!         wire_thickness = aspect_ratio * wire_width;
!         wire_spacing = wire_pitch[1][0] - wire_width;
!         barrier_thickness = 0.006;
!         dishing_thickness = 0;
!         alpha_scatter = 1;
!         wire_r_per_micron[1][0] = wire_resistance(CU_RESISTIVITY, wire_width,
!             wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!         ild_thickness = 0.405;
!         miller_value = 1.5;
!         horiz_dielectric_constant = 2.734;
!         vert_dielectric_constant = 3.9;
!         fringe_cap = 0.115e-15; 
!         wire_c_per_micron[1][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!             ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
!             fringe_cap);
  
!         wire_pitch[1][1] = 4 * g_ip->F_sz_um;
!         wire_width = wire_pitch[1][1] / 2;
!         wire_thickness = aspect_ratio * wire_width;
!         wire_spacing = wire_pitch[1][1] - wire_width;
!         wire_r_per_micron[1][1] = wire_resistance(CU_RESISTIVITY, wire_width,
!             wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!         wire_c_per_micron[1][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!             ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
!             fringe_cap);
  
!         wire_pitch[1][2] = 8 * g_ip->F_sz_um;
!         aspect_ratio = 2.2;
!         wire_width = wire_pitch[1][2] / 2;
!         wire_thickness = aspect_ratio * wire_width;
!         wire_spacing = wire_pitch[1][2] - wire_width;
!         dishing_thickness = 0.1 *  wire_thickness; 
!         wire_r_per_micron[1][2] = wire_resistance(CU_RESISTIVITY, wire_width,
!             wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!         ild_thickness = 0.77;
!         wire_c_per_micron[1][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!             ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
!             fringe_cap);
!         //Nominal projections for commodity DRAM wordline/bitline
!         wire_pitch[1][3] = 2 * 0.065;
!         wire_c_per_micron[1][3] = 52.5e-15 / (256 * 2 * 0.065);
!         wire_r_per_micron[1][3] = 12 / 0.065;
!       }
!       else if (tech == 45) {
!         //Aggressive projections.
!         wire_pitch[0][0] = 2.5 * g_ip->F_sz_um;
!         aspect_ratio = 3.0;
!         wire_width = wire_pitch[0][0] / 2;
!         wire_thickness = aspect_ratio * wire_width;
!         wire_spacing = wire_pitch[0][0] - wire_width;
!         barrier_thickness = 0;
!         dishing_thickness = 0;
!         alpha_scatter = 1;
!         wire_r_per_micron[0][0] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
!             wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!         ild_thickness = 0.315;
!         miller_value = 1.5;
!         horiz_dielectric_constant = 1.958;
!         vert_dielectric_constant = 3.9;
!         fringe_cap = 0.115e-15; 
!         wire_c_per_micron[0][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!             ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
!             fringe_cap);
  
!         wire_pitch[0][1] = 4 * g_ip->F_sz_um;
!         wire_width = wire_pitch[0][1] / 2;
!         wire_thickness = aspect_ratio * wire_width;
!         wire_spacing = wire_pitch[0][1] - wire_width;
!         wire_r_per_micron[0][1] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
!             wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!         wire_c_per_micron[0][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!             ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
!             fringe_cap);
  
!         wire_pitch[0][2] = 8 * g_ip->F_sz_um;
!         aspect_ratio = 3.0;
!         wire_width = wire_pitch[0][2] / 2;
!         wire_thickness = aspect_ratio * wire_width;
!         wire_spacing = wire_pitch[0][2] - wire_width;
!         wire_r_per_micron[0][2] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
!             wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!         ild_thickness = 0.63;
!         wire_c_per_micron[0][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!             ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
!             fringe_cap);
  
!         //Conservative projections
!         wire_pitch[1][0] = 2.5 * g_ip->F_sz_um;
!         aspect_ratio = 2.0;
!         wire_width = wire_pitch[1][0] / 2;
!         wire_thickness = aspect_ratio * wire_width;
!         wire_spacing = wire_pitch[1][0] - wire_width;
!         barrier_thickness = 0.004;
!         dishing_thickness = 0;
!         alpha_scatter = 1;
!         wire_r_per_micron[1][0] = wire_resistance(CU_RESISTIVITY, wire_width,
!             wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!         ild_thickness = 0.315;
!         miller_value = 1.5;
!         horiz_dielectric_constant = 2.46;
!         vert_dielectric_constant = 3.9;
!         fringe_cap = 0.115e-15; 
!         wire_c_per_micron[1][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!             ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
!             fringe_cap);
  
!         wire_pitch[1][1] = 4 * g_ip->F_sz_um;
!         wire_width = wire_pitch[1][1] / 2;
!         wire_thickness = aspect_ratio * wire_width;
!         wire_spacing = wire_pitch[1][1] - wire_width;
!         wire_r_per_micron[1][1] = wire_resistance(CU_RESISTIVITY, wire_width,
!             wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!         wire_c_per_micron[1][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!             ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
!             fringe_cap);
  
!         wire_pitch[1][2] = 8 * g_ip->F_sz_um;
!         aspect_ratio = 2.2;
!         wire_width = wire_pitch[1][2] / 2;
!         wire_thickness = aspect_ratio * wire_width;
!         wire_spacing = wire_pitch[1][2] - wire_width;
!         dishing_thickness = 0.1 * wire_thickness; 
!         wire_r_per_micron[1][2] = wire_resistance(CU_RESISTIVITY, wire_width,
!             wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!         ild_thickness = 0.55;
!         wire_c_per_micron[1][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!             ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
!             fringe_cap);
!         //Nominal projections for commodity DRAM wordline/bitline
!         wire_pitch[1][3] = 2 * 0.045;
!         wire_c_per_micron[1][3] = 37.5e-15 / (256 * 2 * 0.045);
!         wire_r_per_micron[1][3] = 12 / 0.045;
!       }
!       else if (tech == 32) {
!         if ( !g_ip->is_itrs2012 ) { // wire data from Ron Ho's PhD Thesis, Stanford, 2003.
            //Aggressive projections.
            wire_pitch[0][0] = 2.5 * g_ip->F_sz_um;
!           aspect_ratio = 3.0;
            wire_width = wire_pitch[0][0] / 2;
!           wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[0][0] - wire_width;
            barrier_thickness = 0;
            dishing_thickness = 0;
            alpha_scatter = 1;
            wire_r_per_micron[0][0] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness = 0.21;
!           miller_value = 1.5;
!           horiz_dielectric_constant = 1.664;
!           vert_dielectric_constant = 3.9;
!           fringe_cap = 0.115e-15; 
!           wire_c_per_micron[0][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
!           
            wire_pitch[0][1] = 4 * g_ip->F_sz_um;
            wire_width = wire_pitch[0][1] / 2;
!           wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[0][1] - wire_width;
            wire_r_per_micron[0][1] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           wire_c_per_micron[0][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
!           
            wire_pitch[0][2] = 8 * g_ip->F_sz_um;
!           aspect_ratio = 3.0;
            wire_width = wire_pitch[0][2] / 2;
!           wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[0][2] - wire_width;
            wire_r_per_micron[0][2] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness = 0.42;
!           wire_c_per_micron[0][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
!           
!           //Conservative projections
            wire_pitch[1][0] = 2.5 * g_ip->F_sz_um;
!           aspect_ratio = 2.0;
            wire_width = wire_pitch[1][0] / 2;
!           wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[1][0] - wire_width;
!           barrier_thickness = 0.003;
            dishing_thickness = 0;
            alpha_scatter = 1;
            wire_r_per_micron[1][0] = wire_resistance(CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness = 0.21;
!           miller_value = 1.5;
!           horiz_dielectric_constant = 2.214;
!           vert_dielectric_constant = 3.9;
!           fringe_cap = 0.115e-15; 
!           wire_c_per_micron[1][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
!           
            wire_pitch[1][1] = 4 * g_ip->F_sz_um;
            wire_width = wire_pitch[1][1] / 2;
!           wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[1][1] - wire_width;
            wire_r_per_micron[1][1] = wire_resistance(CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           wire_c_per_micron[1][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
!           
            wire_pitch[1][2] = 8 * g_ip->F_sz_um;
!           aspect_ratio = 2.2;
            wire_width = wire_pitch[1][2] / 2;
!           wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[1][2] - wire_width;
!           dishing_thickness = 0.1 *  wire_thickness; 
            wire_r_per_micron[1][2] = wire_resistance(CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness = 0.385;
!           wire_c_per_micron[1][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
          }
          else { // wire data from ITRS 2012 reports, by Woojoo Lee, USC.
            wire_pitch[0][0]        = 0.112;
            wire_pitch[0][1]        = 0.112;
--- 1280,1737 ----
          if (tech_lo == tech_hi) {
            curr_alpha = 1;
          } else {
!           curr_alpha = (wire_technology - tech_hi)/(tech_lo - tech_hi);
          }
        } else {
          tech = tech_hi;
          if (tech_lo == tech_hi) {
            break;  
          } else {
!           curr_alpha = (tech_lo - wire_technology)/(tech_lo - tech_hi);
          }
        }
+ //      cout << "interconnects tech: " << tech << ", asap7: " << g_ip->is_asap7 << endl;
  
        if (tech == 90) {
!           //Aggressive projections
!           wire_pitch[0][0] = 2.5 * g_ip->F_sz_um;//micron
!           aspect_ratio[0][0] = 2.4;
!           wire_width = wire_pitch[0][0] / 2; //micron
!           wire_thickness = aspect_ratio[0][0] * wire_width;//micron
!           wire_spacing = wire_pitch[0][0] - wire_width;//micron
!           barrier_thickness = 0.01;//micron
!           dishing_thickness = 0;//micron
!           alpha_scatter = 1;
!           wire_r_per_micron[0][0] = wire_resistance(CU_RESISTIVITY, wire_width,
!               wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);//ohm/micron
!           ild_thickness[0][0] = 0.48;//micron
!           miller_value[0][0] = 1.5;
!           horiz_dielectric_constant[0][0] = 2.709;
!           vert_dielectric_constant[0][0] = 3.9;
!           fringe_cap = 0.115e-15; //F/micron
!           wire_c_per_micron[0][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!               ild_thickness[0][0], miller_value[0][0], horiz_dielectric_constant[0][0],
!               vert_dielectric_constant[0][0],
!               fringe_cap);//F/micron.
  
!           wire_pitch[0][1] = 4 * g_ip->F_sz_um;
!           wire_width = wire_pitch[0][1] / 2;
!           aspect_ratio[0][1] = 2.4;
!           wire_thickness = aspect_ratio[0][1] * wire_width;
!           wire_spacing = wire_pitch[0][1] - wire_width;
!           wire_r_per_micron[0][1] = wire_resistance(CU_RESISTIVITY, wire_width,
!               wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[0][1] = 0.48;//micron
!           miller_value[0][1] = 1.5;
!           horiz_dielectric_constant[0][1] = 2.709;
!           vert_dielectric_constant[0][1] = 3.9;
!           wire_c_per_micron[0][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!               ild_thickness[0][1], miller_value[0][1], horiz_dielectric_constant[0][1],
!               vert_dielectric_constant[0][1],
!               fringe_cap);
  
!           wire_pitch[0][2] = 8 * g_ip->F_sz_um;
!           aspect_ratio[0][2] = 2.7;
!           wire_width = wire_pitch[0][2] / 2;
!           wire_thickness = aspect_ratio[0][2] * wire_width;
!           wire_spacing = wire_pitch[0][2] - wire_width;
!           wire_r_per_micron[0][2] = wire_resistance(CU_RESISTIVITY, wire_width,
!               wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[0][2] = 0.96;
!           miller_value[0][2] = 1.5;
!           horiz_dielectric_constant[0][2] = 2.709;
!           vert_dielectric_constant[0][2] = 3.9;
!           wire_c_per_micron[0][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!               ild_thickness[0][2], miller_value[0][2], horiz_dielectric_constant[0][2], vert_dielectric_constant[0][2],
!               fringe_cap);
  
!           //Conservative projections
!           wire_pitch[1][0] = 2.5 * g_ip->F_sz_um;
!           aspect_ratio[1][0]  = 2.0;
!           wire_width = wire_pitch[1][0] / 2;
!           wire_thickness = aspect_ratio[1][0] * wire_width;
!           wire_spacing = wire_pitch[1][0] - wire_width;
!           barrier_thickness = 0.008;
!           dishing_thickness = 0;
!           alpha_scatter = 1;
!           wire_r_per_micron[1][0] = wire_resistance(CU_RESISTIVITY, wire_width,
!               wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[1][0]  = 0.48;
!           miller_value[1][0]  = 1.5;
!           horiz_dielectric_constant[1][0]  = 3.038;
!           vert_dielectric_constant[1][0]  = 3.9;
!           fringe_cap = 0.115e-15;
!           wire_c_per_micron[1][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!               ild_thickness[1][0], miller_value[1][0], horiz_dielectric_constant[1][0],
!               vert_dielectric_constant[1][0],
!               fringe_cap);
  
!           wire_pitch[1][1] = 4 * g_ip->F_sz_um;
!           wire_width = wire_pitch[1][1] / 2;
!           aspect_ratio[1][1] = 2.0;
!           wire_thickness = aspect_ratio[1][1] * wire_width;
!           wire_spacing = wire_pitch[1][1] - wire_width;
!           wire_r_per_micron[1][1] = wire_resistance(CU_RESISTIVITY, wire_width,
!               wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[1][1]  = 0.48;
!           miller_value[1][1]  = 1.5;
!           horiz_dielectric_constant[1][1]  = 3.038;
!           vert_dielectric_constant[1][1]  = 3.9;
!           wire_c_per_micron[1][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!               ild_thickness[1][1], miller_value[1][1], horiz_dielectric_constant[1][1],
!               vert_dielectric_constant[1][1],
!               fringe_cap);
  
!           wire_pitch[1][2] = 8 * g_ip->F_sz_um;
!           aspect_ratio[1][2]  = 2.2;
!           wire_width = wire_pitch[1][2] / 2;
!           wire_thickness = aspect_ratio[1][2] * wire_width;
!           wire_spacing = wire_pitch[1][2] - wire_width;
!           dishing_thickness = 0.1 *  wire_thickness;
!           wire_r_per_micron[1][2] = wire_resistance(CU_RESISTIVITY, wire_width,
!               wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[1][2]  = 1.1;
!           miller_value[1][2]  = 1.5;
!           horiz_dielectric_constant[1][2]  = 3.038;
!           vert_dielectric_constant[1][2]  = 3.9;
!           wire_c_per_micron[1][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!               ild_thickness[1][2] , miller_value[1][2], horiz_dielectric_constant[1][2], vert_dielectric_constant[1][2],
!               fringe_cap);
!           //Nominal projections for commodity DRAM wordline/bitline
!           wire_pitch[1][3] = 2 * 0.09;
!           wire_c_per_micron[1][3] = 60e-15 / (256 * 2 * 0.09);
!           wire_r_per_micron[1][3] = 12 / 0.09;
!         }
!         else if (tech == 65)
!         {
!           //Aggressive projections
!           wire_pitch[0][0] = 2.5 * g_ip->F_sz_um;
!           aspect_ratio[0][0]  = 2.7;
!           wire_width = wire_pitch[0][0] / 2;
!           wire_thickness = aspect_ratio[0][0]  * wire_width;
!           wire_spacing = wire_pitch[0][0] - wire_width;
!           barrier_thickness = 0;
!           dishing_thickness = 0;
!           alpha_scatter = 1;
!           wire_r_per_micron[0][0] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
!               wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[0][0]  = 0.405;
!           miller_value[0][0]   = 1.5;
!           horiz_dielectric_constant[0][0]  = 2.303;
!           vert_dielectric_constant[0][0]   = 3.9;
!           fringe_cap = 0.115e-15;
!           wire_c_per_micron[0][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!               ild_thickness[0][0] , miller_value[0][0] , horiz_dielectric_constant[0][0] , vert_dielectric_constant[0][0] ,
!               fringe_cap);
  
!           wire_pitch[0][1] = 4 * g_ip->F_sz_um;
!           wire_width = wire_pitch[0][1] / 2;
!           aspect_ratio[0][1]  = 2.7;
!           wire_thickness = aspect_ratio[0][1]  * wire_width;
!           wire_spacing = wire_pitch[0][1] - wire_width;
!           wire_r_per_micron[0][1] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
!               wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[0][1]  = 0.405;
!           miller_value[0][1]   = 1.5;
!           horiz_dielectric_constant[0][1]  = 2.303;
!           vert_dielectric_constant[0][1]   = 3.9;
!           wire_c_per_micron[0][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!               ild_thickness[0][1], miller_value[0][1], horiz_dielectric_constant[0][1],
!               vert_dielectric_constant[0][1],
!               fringe_cap);
  
!           wire_pitch[0][2] = 8 * g_ip->F_sz_um;
!           aspect_ratio[0][2] = 2.8;
!           wire_width = wire_pitch[0][2] / 2;
!           wire_thickness = aspect_ratio[0][2] * wire_width;
!           wire_spacing = wire_pitch[0][2] - wire_width;
!           wire_r_per_micron[0][2] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
!               wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[0][2] = 0.81;
!           miller_value[0][2]   = 1.5;
!           horiz_dielectric_constant[0][2]  = 2.303;
!           vert_dielectric_constant[0][2]   = 3.9;
!           wire_c_per_micron[0][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!               ild_thickness[0][2], miller_value[0][2], horiz_dielectric_constant[0][2], vert_dielectric_constant[0][2],
!               fringe_cap);
  
!           //Conservative projections
!           wire_pitch[1][0] = 2.5 * g_ip->F_sz_um;
!           aspect_ratio[1][0] = 2.0;
!           wire_width = wire_pitch[1][0] / 2;
!           wire_thickness = aspect_ratio[1][0] * wire_width;
!           wire_spacing = wire_pitch[1][0] - wire_width;
!           barrier_thickness = 0.006;
!           dishing_thickness = 0;
!           alpha_scatter = 1;
!           wire_r_per_micron[1][0] = wire_resistance(CU_RESISTIVITY, wire_width,
!               wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[1][0] = 0.405;
!           miller_value[1][0] = 1.5;
!           horiz_dielectric_constant[1][0] = 2.734;
!           vert_dielectric_constant[1][0] = 3.9;
!           fringe_cap = 0.115e-15;
!           wire_c_per_micron[1][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!               ild_thickness[1][0], miller_value[1][0], horiz_dielectric_constant[1][0], vert_dielectric_constant[1][0],
!               fringe_cap);
  
!           wire_pitch[1][1] = 4 * g_ip->F_sz_um;
!           wire_width = wire_pitch[1][1] / 2;
!           aspect_ratio[1][1] = 2.0;
!           wire_thickness = aspect_ratio[1][1] * wire_width;
!           wire_spacing = wire_pitch[1][1] - wire_width;
!           wire_r_per_micron[1][1] = wire_resistance(CU_RESISTIVITY, wire_width,
!               wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[1][1] = 0.405;
!           miller_value[1][1] = 1.5;
!           horiz_dielectric_constant[1][1] = 2.734;
!           vert_dielectric_constant[1][1] = 3.9;
!           wire_c_per_micron[1][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!               ild_thickness[1][1], miller_value[1][1], horiz_dielectric_constant[1][1], vert_dielectric_constant[1][1],
!               fringe_cap);
  
!           wire_pitch[1][2] = 8 * g_ip->F_sz_um;
!           aspect_ratio[1][2] = 2.2;
!           wire_width = wire_pitch[1][2] / 2;
!           wire_thickness = aspect_ratio[1][2] * wire_width;
!           wire_spacing = wire_pitch[1][2] - wire_width;
!           dishing_thickness = 0.1 *  wire_thickness;
!           wire_r_per_micron[1][2] = wire_resistance(CU_RESISTIVITY, wire_width,
!               wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[1][2] = 0.77;
!           miller_value[1][2] = 1.5;
!           horiz_dielectric_constant[1][2] = 2.734;
!           vert_dielectric_constant[1][2] = 3.9;
!           wire_c_per_micron[1][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!               ild_thickness[1][2], miller_value[1][2], horiz_dielectric_constant[1][2], vert_dielectric_constant[1][2],
!               fringe_cap);
!           //Nominal projections for commodity DRAM wordline/bitline
!           wire_pitch[1][3] = 2 * 0.065;
!           wire_c_per_micron[1][3] = 52.5e-15 / (256 * 2 * 0.065);
!           wire_r_per_micron[1][3] = 12 / 0.065;
!         }
!       else if (tech == 45) {
            //Aggressive projections.
            wire_pitch[0][0] = 2.5 * g_ip->F_sz_um;
!           aspect_ratio[0][0]  = 3.0;
            wire_width = wire_pitch[0][0] / 2;
!           wire_thickness = aspect_ratio[0][0]  * wire_width;
            wire_spacing = wire_pitch[0][0] - wire_width;
            barrier_thickness = 0;
            dishing_thickness = 0;
            alpha_scatter = 1;
            wire_r_per_micron[0][0] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[0][0]  = 0.315;
!           miller_value[0][0]  = 1.5;
!           horiz_dielectric_constant[0][0]  = 1.958;
!           vert_dielectric_constant[0][0]  = 3.9;
!           fringe_cap = 0.115e-15;
!           wire_c_per_micron[0][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!               ild_thickness[0][0] , miller_value[0][0] , horiz_dielectric_constant[0][0] , vert_dielectric_constant[0][0] ,
                fringe_cap);
! 
            wire_pitch[0][1] = 4 * g_ip->F_sz_um;
            wire_width = wire_pitch[0][1] / 2;
!           aspect_ratio[0][1]  = 3.0;
!           wire_thickness = aspect_ratio[0][1] * wire_width;
            wire_spacing = wire_pitch[0][1] - wire_width;
            wire_r_per_micron[0][1] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[0][1]  = 0.315;
!           miller_value[0][1]  = 1.5;
!           horiz_dielectric_constant[0][1]  = 1.958;
!           vert_dielectric_constant[0][1]  = 3.9;
!           wire_c_per_micron[0][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!               ild_thickness[0][1], miller_value[0][1], horiz_dielectric_constant[0][1], vert_dielectric_constant[0][1],
                fringe_cap);
! 
            wire_pitch[0][2] = 8 * g_ip->F_sz_um;
!           aspect_ratio[0][2] = 3.0;
            wire_width = wire_pitch[0][2] / 2;
!           wire_thickness = aspect_ratio[0][2] * wire_width;
            wire_spacing = wire_pitch[0][2] - wire_width;
            wire_r_per_micron[0][2] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[0][2] = 0.63;
!           miller_value[0][2]  = 1.5;
!           horiz_dielectric_constant[0][2]  = 1.958;
!           vert_dielectric_constant[0][2]  = 3.9;
!           wire_c_per_micron[0][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!               ild_thickness[0][2], miller_value[0][2], horiz_dielectric_constant[0][2], vert_dielectric_constant[0][2],
                fringe_cap);
!     /*
!           cout << "wire_pitch[0][0]: " << wire_pitch[0][0]
!     				<< ", wire_r_per_micron[0][0]: " << wire_r_per_micron[0][0]
!     				<< ", wire_c_per_micron[0][0]: "  << wire_c_per_micron[0][0]
!     			  << "wire_pitch[0][1]: " << wire_pitch[0][1]
!     				<< ", wire_r_per_micron[0][1]: " << wire_r_per_micron[0][1]
!     				<< ", wire_c_per_micron[0][1]: "  << wire_c_per_micron[0][1]
!     				  << "wire_pitch[0][2]: " <<wire_pitch[0][2]
!     				<< ", wire_r_per_micron[0][2]: " << wire_r_per_micron[0][2]
!     				<< ", wire_c_per_micron[0][2]: "  << wire_c_per_micron[0][2]
!     								<< endl;
!     */
!          //Conservative projections
            wire_pitch[1][0] = 2.5 * g_ip->F_sz_um;
!           aspect_ratio[1][0] = 2.0;
            wire_width = wire_pitch[1][0] / 2;
!           wire_thickness = aspect_ratio[1][0] * wire_width;
            wire_spacing = wire_pitch[1][0] - wire_width;
!           barrier_thickness = 0.004;
            dishing_thickness = 0;
            alpha_scatter = 1;
            wire_r_per_micron[1][0] = wire_resistance(CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[1][0] = 0.315;
!           miller_value[1][0] = 1.5;
!           horiz_dielectric_constant[1][0] = 2.46;
!           vert_dielectric_constant[1][0] = 3.9;
!           fringe_cap = 0.115e-15;
!           wire_c_per_micron[1][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!               ild_thickness[1][0], miller_value[1][0], horiz_dielectric_constant[1][0], vert_dielectric_constant[1][0],
                fringe_cap);
! 
            wire_pitch[1][1] = 4 * g_ip->F_sz_um;
            wire_width = wire_pitch[1][1] / 2;
!           aspect_ratio[1][1] = 2.0;
!           wire_thickness = aspect_ratio[1][1] * wire_width;
            wire_spacing = wire_pitch[1][1] - wire_width;
            wire_r_per_micron[1][1] = wire_resistance(CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[1][1] = 0.315;
!           miller_value[1][1] = 1.5;
!           horiz_dielectric_constant[1][1] = 2.46;
!           vert_dielectric_constant[1][1] = 3.9;
!           fringe_cap = 0.115e-15;
!           wire_c_per_micron[1][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!               ild_thickness[1][1], miller_value[1][1], horiz_dielectric_constant[1][1], vert_dielectric_constant[1][1],
                fringe_cap);
! 
            wire_pitch[1][2] = 8 * g_ip->F_sz_um;
!           aspect_ratio[1][2] = 2.2;
            wire_width = wire_pitch[1][2] / 2;
!           wire_thickness = aspect_ratio[1][2] * wire_width;
            wire_spacing = wire_pitch[1][2] - wire_width;
!           dishing_thickness = 0.1 * wire_thickness;
            wire_r_per_micron[1][2] = wire_resistance(CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[1][2] = 0.55;
!           miller_value[1][2] = 1.5;
!           horiz_dielectric_constant[1][2] = 2.46;
!           vert_dielectric_constant[1][2] = 3.9;
!           wire_c_per_micron[1][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!               ild_thickness[1][2], miller_value[1][2], horiz_dielectric_constant[1][2], vert_dielectric_constant[1][2],
                fringe_cap);
+           //Nominal projections for commodity DRAM wordline/bitline
+           wire_pitch[1][3] = 2 * 0.045;
+           wire_c_per_micron[1][3] = 37.5e-15 / (256 * 2 * 0.045);
+           wire_r_per_micron[1][3] = 12 / 0.045;
          }
+       else if (tech == 32) {
+         if ( !g_ip->is_itrs2012 ) { // wire data from Ron Ho's PhD Thesis, Stanford, 2003.
+           //Aggressive projections.
+             //Aggressive projections.
+             wire_pitch[0][0] = 2.5 * g_ip->F_sz_um;
+             aspect_ratio[0][0] = 3.0;
+             wire_width = wire_pitch[0][0] / 2;
+             wire_thickness = aspect_ratio[0][0] * wire_width;
+             wire_spacing = wire_pitch[0][0] - wire_width;
+             barrier_thickness = 0;
+             dishing_thickness = 0;
+             alpha_scatter = 1;
+             wire_r_per_micron[0][0] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
+                 wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
+             ild_thickness[0][0] = 0.21;
+             miller_value[0][0] = 1.5;
+             horiz_dielectric_constant[0][0] = 1.664;
+             vert_dielectric_constant[0][0] = 3.9;
+             fringe_cap = 0.115e-15;
+             wire_c_per_micron[0][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
+                 ild_thickness[0][0], miller_value[0][0], horiz_dielectric_constant[0][0], vert_dielectric_constant[0][0],
+                 fringe_cap);
+ 
+             wire_pitch[0][1] = 4 * g_ip->F_sz_um;
+             wire_width = wire_pitch[0][1] / 2;
+             aspect_ratio[0][1] = 3.0;
+             wire_thickness = aspect_ratio[0][1] * wire_width;
+             wire_spacing = wire_pitch[0][1] - wire_width;
+             wire_r_per_micron[0][1] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
+                 wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
+             ild_thickness[0][1] = 0.21;
+             miller_value[0][1] = 1.5;
+             horiz_dielectric_constant[0][1] = 1.664;
+             vert_dielectric_constant[0][1] = 3.9;
+             wire_c_per_micron[0][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
+                 ild_thickness[0][1], miller_value[0][1], horiz_dielectric_constant[0][1], vert_dielectric_constant[0][1],
+                 fringe_cap);
+ 
+             wire_pitch[0][2] = 8 * g_ip->F_sz_um;
+             aspect_ratio[0][2] = 3.0;
+             wire_width = wire_pitch[0][2] / 2;
+             wire_thickness = aspect_ratio[0][2] * wire_width;
+             wire_spacing = wire_pitch[0][2] - wire_width;
+             wire_r_per_micron[0][2] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
+                 wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
+             ild_thickness[0][2] = 0.42;
+             miller_value[0][2] = 1.5;
+             horiz_dielectric_constant[0][2] = 1.664;
+             vert_dielectric_constant[0][2] = 3.9;
+             wire_c_per_micron[0][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
+                 ild_thickness[0][2], miller_value[0][2], horiz_dielectric_constant[0][2], vert_dielectric_constant[0][2],
+                 fringe_cap);
+ 
+             //Conservative projections
+             wire_pitch[1][0] = 2.5 * g_ip->F_sz_um;
+             aspect_ratio[1][0] = 2.0;
+             wire_width = wire_pitch[1][0] / 2;
+             wire_thickness = aspect_ratio[1][0] * wire_width;
+             wire_spacing = wire_pitch[1][0] - wire_width;
+             barrier_thickness = 0.003;
+             dishing_thickness = 0;
+             alpha_scatter = 1;
+             wire_r_per_micron[1][0] = wire_resistance(CU_RESISTIVITY, wire_width,
+                 wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
+             ild_thickness[1][0] = 0.21;
+             miller_value[1][0] = 1.5;
+             horiz_dielectric_constant[1][0] = 2.214;
+             vert_dielectric_constant[1][0] = 3.9;
+             fringe_cap = 0.115e-15;
+             wire_c_per_micron[1][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
+                 ild_thickness[1][0], miller_value[1][0], horiz_dielectric_constant[1][0], vert_dielectric_constant[1][0],
+                 fringe_cap);
+ 
+             wire_pitch[1][1] = 4 * g_ip->F_sz_um;
+             aspect_ratio[1][1] = 2.0;
+             wire_width = wire_pitch[1][1] / 2;
+             wire_thickness = aspect_ratio[1][1] * wire_width;
+             wire_spacing = wire_pitch[1][1] - wire_width;
+             wire_r_per_micron[1][1] = wire_resistance(CU_RESISTIVITY, wire_width,
+                 wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
+             ild_thickness[1][1] = 0.21;
+             miller_value[1][1] = 1.5;
+             horiz_dielectric_constant[1][1] = 2.214;
+             vert_dielectric_constant[1][1] = 3.9;
+             wire_c_per_micron[1][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
+                 ild_thickness[1][1], miller_value[1][1], horiz_dielectric_constant[1][1], vert_dielectric_constant[1][1],
+                 fringe_cap);
+ 
+             wire_pitch[1][2] = 8 * g_ip->F_sz_um;
+             aspect_ratio[1][2] = 2.2;
+             wire_width = wire_pitch[1][2] / 2;
+             wire_thickness = aspect_ratio[1][2] * wire_width;
+             wire_spacing = wire_pitch[1][2] - wire_width;
+             dishing_thickness = 0.1 *  wire_thickness;
+             wire_r_per_micron[1][2] = wire_resistance(CU_RESISTIVITY, wire_width,
+                 wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
+             ild_thickness[1][2] = 0.385;
+             miller_value[1][2] = 1.5;
+             horiz_dielectric_constant[1][2] = 2.214;
+             vert_dielectric_constant[1][2] = 3.9;
+             wire_c_per_micron[1][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
+                 ild_thickness[1][2], miller_value[1][2], horiz_dielectric_constant[1][2], vert_dielectric_constant[1][2],
+                 fringe_cap);
+           }
          else { // wire data from ITRS 2012 reports, by Woojoo Lee, USC.
            wire_pitch[0][0]        = 0.112;
            wire_pitch[0][1]        = 0.112;
***************
*** 1066,1072 ****
            wire_c_per_micron[1][1] = 2.10e-16;
            wire_c_per_micron[1][2] = 2.30e-16;
          }
-         
          //Nominal projections for commodity DRAM wordline/bitline
          wire_pitch[1][3] = 2 * 0.032;//micron
          wire_c_per_micron[1][3] = 31e-15 / (256 * 2 * 0.032);//F/micron
--- 1749,1754 ----
***************
*** 1075,1180 ****
        else if (tech == 22) {
          if ( !g_ip->is_itrs2012 ) { // wire data from Ron Ho's PhD Thesis, Stanford, 2003.
            //Aggressive projections.
!           wire_pitch[0][0] = 2.5 * g_ip->F_sz_um;//local
!           aspect_ratio = 3.0;
            wire_width = wire_pitch[0][0] / 2;
!           wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[0][0] - wire_width;
            barrier_thickness = 0;
            dishing_thickness = 0;
            alpha_scatter = 1;
            wire_r_per_micron[0][0] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
                 wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness = 0.15;
!           miller_value = 1.5;
!           horiz_dielectric_constant = 1.414;
!           vert_dielectric_constant = 3.9;
            fringe_cap = 0.115e-15;
            wire_c_per_micron[0][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!             ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);
            
!           wire_pitch[0][1] = 4 * g_ip->F_sz_um;//semi-global
            wire_width = wire_pitch[0][1] / 2;
!           aspect_ratio = 3.0;
!           wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[0][1] - wire_width;
            wire_r_per_micron[0][1] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
                 wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness = 0.15;
!           miller_value = 1.5;
!           horiz_dielectric_constant = 1.414;
!           vert_dielectric_constant = 3.9;
            wire_c_per_micron[0][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!             ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);
            
!           wire_pitch[0][2] = 8 * g_ip->F_sz_um;//global
!           aspect_ratio = 3.0;
            wire_width = wire_pitch[0][2] / 2;
!           wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[0][2] - wire_width;
            wire_r_per_micron[0][2] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
            	  wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness = 0.3;
!           miller_value = 1.5;
!           horiz_dielectric_constant = 1.414;
!           vert_dielectric_constant = 3.9;
            wire_c_per_micron[0][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!           	  ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
            	  fringe_cap);
            
            //Conservative projections
!           wire_pitch[1][0] = 2.5 * g_ip->F_sz_um;
!           aspect_ratio = 2.0;
            wire_width = wire_pitch[1][0] / 2;
!           wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[1][0] - wire_width;
            barrier_thickness = 0.003;
            dishing_thickness = 0;
            alpha_scatter = 1.05;
            wire_r_per_micron[1][0] = wire_resistance(CU_RESISTIVITY, wire_width,
              wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness = 0.15;
!           miller_value = 1.5;
!           horiz_dielectric_constant = 2.104;
!           vert_dielectric_constant = 3.9;
            fringe_cap = 0.115e-15;
            wire_c_per_micron[1][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!             ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);
!           
!           wire_pitch[1][1] = 4 * g_ip->F_sz_um;
            wire_width = wire_pitch[1][1] / 2;
!           aspect_ratio = 2.0;
!           wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[1][1] - wire_width;
            wire_r_per_micron[1][1] = wire_resistance(CU_RESISTIVITY, wire_width,
              wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness = 0.15;
!           miller_value = 1.5;
!           horiz_dielectric_constant = 2.104;
!           vert_dielectric_constant = 3.9;
            wire_c_per_micron[1][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!             ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);
!           
!           wire_pitch[1][2] = 8 * g_ip->F_sz_um;
!           aspect_ratio = 2.2;
            wire_width = wire_pitch[1][2] / 2;
!           wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[1][2] - wire_width;
            dishing_thickness = 0.1 *  wire_thickness;
            wire_r_per_micron[1][2] = wire_resistance(CU_RESISTIVITY, wire_width,
            		wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness = 0.275;
!           miller_value = 1.5;
!           horiz_dielectric_constant = 2.104;
!           vert_dielectric_constant = 3.9;
            wire_c_per_micron[1][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!           		ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
            		fringe_cap);
          }
          else { // wire data from ITRS 2012 reports, by Woojoo Lee, USC.
            wire_pitch[0][0]        = 0.076;
            wire_pitch[0][1]        = 0.076;
--- 1757,1868 ----
        else if (tech == 22) {
          if ( !g_ip->is_itrs2012 ) { // wire data from Ron Ho's PhD Thesis, Stanford, 2003.
            //Aggressive projections.
!           wire_pitch[0][0] = 2.5 * g_ip->wire_F_sz_um;//local
!           aspect_ratio[0][0] = 3.0;
            wire_width = wire_pitch[0][0] / 2;
!           wire_thickness = aspect_ratio[0][0] * wire_width;
            wire_spacing = wire_pitch[0][0] - wire_width;
            barrier_thickness = 0;
            dishing_thickness = 0;
            alpha_scatter = 1;
            wire_r_per_micron[0][0] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
                 wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[0][0] = 0.15;
!           miller_value[0][0] = 1.5;
!           horiz_dielectric_constant[0][0] = 1.414;
!           vert_dielectric_constant[0][0] = 3.9;
            fringe_cap = 0.115e-15;
            wire_c_per_micron[0][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!             ild_thickness[0][0], miller_value[0][0], horiz_dielectric_constant[0][0],
! 			vert_dielectric_constant[0][0],
              fringe_cap);
            
!           wire_pitch[0][1] = 4 * g_ip->wire_F_sz_um;//semi-global
            wire_width = wire_pitch[0][1] / 2;
!           aspect_ratio[0][1] = 3.0;
!           wire_thickness = aspect_ratio[0][1] * wire_width;
            wire_spacing = wire_pitch[0][1] - wire_width;
            wire_r_per_micron[0][1] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
                 wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[0][1] = 0.15;
!           miller_value[0][1] = 1.5;
!           horiz_dielectric_constant[0][1] = 1.414;
!           vert_dielectric_constant[0][1] = 3.9;
            wire_c_per_micron[0][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!             ild_thickness[0][1], miller_value[0][1], horiz_dielectric_constant[0][1],
! 			vert_dielectric_constant[0][1],
              fringe_cap);
            
!           wire_pitch[0][2] = 8 * g_ip->wire_F_sz_um;//global
!           aspect_ratio[0][2] = 3.0;
            wire_width = wire_pitch[0][2] / 2;
!           wire_thickness = aspect_ratio[0][2] * wire_width;
            wire_spacing = wire_pitch[0][2] - wire_width;
            wire_r_per_micron[0][2] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
            	  wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[0][2] = 0.3;
!           miller_value[0][2] = 1.5;
!           horiz_dielectric_constant[0][2] = 1.414;
!           vert_dielectric_constant[0][2] = 3.9;
            wire_c_per_micron[0][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!           	  ild_thickness[0][2], miller_value[0][2], horiz_dielectric_constant[0][2],
! 			  vert_dielectric_constant[0][2],
            	  fringe_cap);
            
            //Conservative projections
!           wire_pitch[1][0] = 2.5 * g_ip->wire_F_sz_um;
!           aspect_ratio[1][0] = 2.0;
            wire_width = wire_pitch[1][0] / 2;
!           wire_thickness = aspect_ratio[1][0] * wire_width;
            wire_spacing = wire_pitch[1][0] - wire_width;
            barrier_thickness = 0.003;
            dishing_thickness = 0;
            alpha_scatter = 1.05;
            wire_r_per_micron[1][0] = wire_resistance(CU_RESISTIVITY, wire_width,
              wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[1][0] = 0.15;
!           miller_value[1][0] = 1.5;
!           horiz_dielectric_constant[1][0] = 2.104;
!           vert_dielectric_constant[1][0] = 3.9;
            fringe_cap = 0.115e-15;
            wire_c_per_micron[1][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!             ild_thickness[1][0], miller_value[1][0], horiz_dielectric_constant[1][0],
! 			vert_dielectric_constant[1][0],
              fringe_cap);
! 
!           wire_pitch[1][1] = 4 * g_ip->wire_F_sz_um;
            wire_width = wire_pitch[1][1] / 2;
!           aspect_ratio[1][1] = 2.0;
!           wire_thickness = aspect_ratio[1][1] * wire_width;
            wire_spacing = wire_pitch[1][1] - wire_width;
            wire_r_per_micron[1][1] = wire_resistance(CU_RESISTIVITY, wire_width,
              wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[1][1] = 0.15;
!           miller_value[1][1] = 1.5;
!           horiz_dielectric_constant[1][1] = 2.104;
!           vert_dielectric_constant[1][1] = 3.9;
            wire_c_per_micron[1][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!             ild_thickness[1][1], miller_value[1][1], horiz_dielectric_constant[1][1], vert_dielectric_constant[1][1],
              fringe_cap);
! 
!           wire_pitch[1][2] = 8 * g_ip->wire_F_sz_um;
!           aspect_ratio[1][2] = 2.2;
            wire_width = wire_pitch[1][2] / 2;
!           wire_thickness = aspect_ratio[1][2] * wire_width;
            wire_spacing = wire_pitch[1][2] - wire_width;
            dishing_thickness = 0.1 *  wire_thickness;
            wire_r_per_micron[1][2] = wire_resistance(CU_RESISTIVITY, wire_width,
            		wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[1][2] = 0.275;
!           miller_value[1][2] = 1.5;
!           horiz_dielectric_constant[1][2] = 2.104;
!           vert_dielectric_constant[1][2] = 3.9;
            wire_c_per_micron[1][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!           		ild_thickness[1][2], miller_value[1][2], horiz_dielectric_constant[1][2], vert_dielectric_constant[1][2],
            		fringe_cap);
+ 
          }
+ 
          else { // wire data from ITRS 2012 reports, by Woojoo Lee, USC.
            wire_pitch[0][0]        = 0.076;
            wire_pitch[0][1]        = 0.076;
***************
*** 1198,1289 ****
          wire_c_per_micron[1][3] = 26.6e-15 / (256 * 2 * 0.022);//F/micron  // Alireza: scaling
          wire_r_per_micron[1][3] = 12 / 0.022;//ohm/micron
        }
!       else if (tech == 16 || tech == 14) { // Alireza2
!         if ( !g_ip->is_itrs2012 ) { // wire data from Ron Ho's PhD Thesis, Stanford, 2003.
!           //Aggressive projections.
!           wire_pitch[0][0] = 2.5 * g_ip->F_sz_um;
!           aspect_ratio = 3.0;
!           wire_width = wire_pitch[0][0] / 2;
!           wire_thickness = aspect_ratio * wire_width;
!           wire_spacing = wire_pitch[0][0] - wire_width;
!           barrier_thickness = 0;
!           dishing_thickness = 0;
!           alpha_scatter = 1;
!           wire_r_per_micron[0][0] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
!               wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness = 0.108;
!           miller_value = 1.5;
!           horiz_dielectric_constant = 1.202;
!           vert_dielectric_constant = 3.9;
!           fringe_cap = 0.115e-15; 
!           wire_c_per_micron[0][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
!               fringe_cap);
!           
!           wire_pitch[0][1] = 4 * g_ip->F_sz_um;
!           wire_width = wire_pitch[0][1] / 2;
!           wire_thickness = aspect_ratio * wire_width;
!           wire_spacing = wire_pitch[0][1] - wire_width;
!           wire_r_per_micron[0][1] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
!               wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           wire_c_per_micron[0][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
!               fringe_cap);
!           
!           wire_pitch[0][2] = 8 * g_ip->F_sz_um;
!           aspect_ratio = 3.0;
!           wire_width = wire_pitch[0][2] / 2;
!           wire_thickness = aspect_ratio * wire_width;
!           wire_spacing = wire_pitch[0][2] - wire_width;
!           wire_r_per_micron[0][2] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
!               wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness = 0.216;
!           wire_c_per_micron[0][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
!               fringe_cap);
!           
!           //Conservative projections
!           wire_pitch[1][0] = 2.5 * g_ip->F_sz_um;
!           aspect_ratio = 2.0;
!           wire_width = wire_pitch[1][0] / 2;
!           wire_thickness = aspect_ratio * wire_width;
!           wire_spacing = wire_pitch[1][0] - wire_width;
!           barrier_thickness = 0.002;
!           dishing_thickness = 0;
!           alpha_scatter = 1.05;
!           wire_r_per_micron[1][0] = wire_resistance(CU_RESISTIVITY, wire_width,
!               wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness = 0.108;
!           miller_value = 1.5;
!           horiz_dielectric_constant = 1.998;
!           vert_dielectric_constant = 3.9;
!           fringe_cap = 0.115e-15; 
!           wire_c_per_micron[1][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
!               fringe_cap);
!           
!           wire_pitch[1][1] = 4 * g_ip->F_sz_um;
!           wire_width = wire_pitch[1][1] / 2;
!           wire_thickness = aspect_ratio * wire_width;
!           wire_spacing = wire_pitch[1][1] - wire_width;
!           wire_r_per_micron[1][1] = wire_resistance(CU_RESISTIVITY, wire_width,
!               wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           wire_c_per_micron[1][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
!               fringe_cap);
!           
!           wire_pitch[1][2] = 8 * g_ip->F_sz_um;
!           aspect_ratio = 2.2;
!           wire_width = wire_pitch[1][2] / 2;
!           wire_thickness = aspect_ratio * wire_width;
!           wire_spacing = wire_pitch[1][2] - wire_width;
!           dishing_thickness = 0.1 *  wire_thickness; 
!           wire_r_per_micron[1][2] = wire_resistance(CU_RESISTIVITY, wire_width,
!               wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness = 0.198;
!           wire_c_per_micron[1][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
!               fringe_cap);
          }
          else { // wire data from ITRS 2012 reports, by Woojoo Lee, USC.
            wire_pitch[0][0]        = 0.054;
--- 1886,1994 ----
          wire_c_per_micron[1][3] = 26.6e-15 / (256 * 2 * 0.022);//F/micron  // Alireza: scaling
          wire_r_per_micron[1][3] = 12 / 0.022;//ohm/micron
        }
!       else if (tech == 16)// || tech == 14) { // Alireza2
!       {
!     	  if ( !g_ip->is_itrs2012 ) { // wire data from Ron Ho's PhD Thesis, Stanford, 2003.
!             //Aggressive projections.
!             wire_pitch[0][0] = 2.5 * g_ip->F_sz_um;//local
!             aspect_ratio[0][0] = 3.0;
!             wire_width = wire_pitch[0][0] / 2;
!             wire_thickness = aspect_ratio[0][0] * wire_width;
!             wire_spacing = wire_pitch[0][0] - wire_width;
!             barrier_thickness = 0;
!             dishing_thickness = 0;
!             alpha_scatter = 1;
!             wire_r_per_micron[0][0] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
!               wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!             ild_thickness[0][0] = 0.108;
!             miller_value[0][0] = 1.5;
!             horiz_dielectric_constant[0][0] = 1.202;
!             vert_dielectric_constant[0][0] = 3.9;
!             fringe_cap = 0.115e-15;
!             wire_c_per_micron[0][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!               ild_thickness[0][0], miller_value[0][0], horiz_dielectric_constant[0][0], vert_dielectric_constant[0][0],
!               fringe_cap);
! 
!             wire_pitch[0][1] = 4 * g_ip->F_sz_um;//semi-global
!             aspect_ratio[0][1] = 3.0;
!             wire_width = wire_pitch[0][1] / 2;
!             wire_thickness = aspect_ratio[0][1] * wire_width;
!             wire_spacing = wire_pitch[0][1] - wire_width;
!             wire_r_per_micron[0][1] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
!               wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!             ild_thickness[0][1] = 0.108;
!             miller_value[0][1] = 1.5;
!             horiz_dielectric_constant[0][1] = 1.202;
!             vert_dielectric_constant[0][1] = 3.9;
!             wire_c_per_micron[0][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!               ild_thickness[0][1], miller_value[0][1], horiz_dielectric_constant[0][1], vert_dielectric_constant[0][1],
!               fringe_cap);
! 
!             wire_pitch[0][2] = 8 * g_ip->F_sz_um;//global
!             aspect_ratio[0][2] = 3.0;
!             wire_width = wire_pitch[0][2] / 2;
!             wire_thickness = aspect_ratio[0][2] * wire_width;
!             wire_spacing = wire_pitch[0][2] - wire_width;
!             wire_r_per_micron[0][2] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
!           		  wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!             ild_thickness[0][2] = 0.216;
!             miller_value[0][2] = 1.5;
!             horiz_dielectric_constant[0][2] = 1.202;
!             vert_dielectric_constant[0][2] = 3.9;
!             wire_c_per_micron[0][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!           		  ild_thickness[0][2], miller_value[0][2], horiz_dielectric_constant[0][2], vert_dielectric_constant[0][2],
!           		  fringe_cap);
! 
!             //Conservative projections
!             wire_pitch[1][0] = 2.5 * g_ip->F_sz_um;
!             aspect_ratio[1][0] = 2.0;
!             wire_width = wire_pitch[1][0] / 2;
!             wire_thickness = aspect_ratio[1][0] * wire_width;
!             wire_spacing = wire_pitch[1][0] - wire_width;
!             barrier_thickness = 0.002;
!             dishing_thickness = 0;
!             alpha_scatter = 1.05;
!             wire_r_per_micron[1][0] = wire_resistance(CU_RESISTIVITY, wire_width,
!               wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!             ild_thickness[1][0] = 0.108;
!             miller_value[1][0] = 1.5;
!             horiz_dielectric_constant[1][0] = 1.998;
!             vert_dielectric_constant[1][0] = 3.9;
!             fringe_cap = 0.115e-15;
!             wire_c_per_micron[1][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!               ild_thickness[1][0], miller_value[1][0], horiz_dielectric_constant[1][0], vert_dielectric_constant[1][0],
!               fringe_cap);
! 
!             wire_pitch[1][1] = 4 * g_ip->F_sz_um;
!             wire_width = wire_pitch[1][1] / 2;
!             aspect_ratio[1][1] = 2.0;
!             wire_thickness = aspect_ratio[1][1] * wire_width;
!             wire_spacing = wire_pitch[1][1] - wire_width;
!             wire_r_per_micron[1][1] = wire_resistance(CU_RESISTIVITY, wire_width,
!               wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!             ild_thickness[1][1] = 0.108;
!             miller_value[1][1] = 1.5;
!             horiz_dielectric_constant[1][1] = 1.998;
!             vert_dielectric_constant[1][1] = 3.9;
!               wire_c_per_micron[1][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!               ild_thickness[1][1], miller_value[1][1], horiz_dielectric_constant[1][1], vert_dielectric_constant[1][1],
!               fringe_cap);
! 
!               wire_pitch[1][2] = 8 * g_ip->F_sz_um;
!               aspect_ratio[1][2] = 2.2;
!               wire_width = wire_pitch[1][2] / 2;
!               wire_thickness = aspect_ratio[1][2] * wire_width;
!               wire_spacing = wire_pitch[1][2] - wire_width;
!               dishing_thickness = 0.1 *  wire_thickness;
!               wire_r_per_micron[1][2] = wire_resistance(CU_RESISTIVITY, wire_width,
!               		wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!               ild_thickness[1][2] = 0.198;
!               miller_value[1][2] = 1.5;
!               horiz_dielectric_constant[1][2] = 1.998;
!               vert_dielectric_constant[1][2] = 3.9;
!               wire_c_per_micron[1][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!               		ild_thickness[1][2], miller_value[1][2], horiz_dielectric_constant[1][2], vert_dielectric_constant[1][2],
!               		fringe_cap);
          }
          else { // wire data from ITRS 2012 reports, by Woojoo Lee, USC.
            wire_pitch[0][0]        = 0.054;
***************
*** 1311,1398 ****
        else if (tech == 10) { // Alireza
          if ( !g_ip->is_itrs2012 ) { // wire data from Ron Ho's PhD Thesis, Stanford, 2003.
            //Aggressive projections.
!           wire_pitch[0][0] = 2.5 * g_ip->F_sz_um;
!           aspect_ratio = 3.0;
            wire_width = wire_pitch[0][0] / 2;
!           wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[0][0] - wire_width;
            barrier_thickness = 0;
            dishing_thickness = 0;
            alpha_scatter = 1;
            wire_r_per_micron[0][0] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness = 0.078;
!           miller_value = 1.5;
!           horiz_dielectric_constant = 1.022;
!           vert_dielectric_constant = 3.9;
            fringe_cap = 0.115e-15; 
            wire_c_per_micron[0][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[0][1] = 4 * g_ip->F_sz_um;
            wire_width = wire_pitch[0][1] / 2;
!           wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[0][1] - wire_width;
            wire_r_per_micron[0][1] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
            wire_c_per_micron[0][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[0][2] = 8 * g_ip->F_sz_um;
!           aspect_ratio = 3.0;
            wire_width = wire_pitch[0][2] / 2;
!           wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[0][2] - wire_width;
            wire_r_per_micron[0][2] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness = 0.156;
            wire_c_per_micron[0][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
            //Conservative projections
!           wire_pitch[1][0] = 2.5 * g_ip->F_sz_um;
!           aspect_ratio = 2.0;
            wire_width = wire_pitch[1][0] / 2;
!           wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[1][0] - wire_width;
            barrier_thickness = 0.002;
            dishing_thickness = 0;
            alpha_scatter = 1.05;
            wire_r_per_micron[1][0] = wire_resistance(CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness = 0.078;
!           miller_value = 1.5;
!           horiz_dielectric_constant = 1.899;
!           vert_dielectric_constant = 3.9;
            fringe_cap = 0.115e-15; 
            wire_c_per_micron[1][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[1][1] = 4 * g_ip->F_sz_um;
            wire_width = wire_pitch[1][1] / 2;
!           wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[1][1] - wire_width;
            wire_r_per_micron[1][1] = wire_resistance(CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
            wire_c_per_micron[1][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[1][2] = 8 * g_ip->F_sz_um;
!           aspect_ratio = 2.2;
            wire_width = wire_pitch[1][2] / 2;
!           wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[1][2] - wire_width;
            dishing_thickness = 0.1 *  wire_thickness; 
            wire_r_per_micron[1][2] = wire_resistance(CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness = 0.143;
            wire_c_per_micron[1][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
          }
          else { // wire data from ITRS 2012 reports, by Woojoo Lee, USC.
--- 2016,2121 ----
        else if (tech == 10) { // Alireza
          if ( !g_ip->is_itrs2012 ) { // wire data from Ron Ho's PhD Thesis, Stanford, 2003.
            //Aggressive projections.
!           wire_pitch[0][0] = 2.5 * g_ip->wire_F_sz_um;
!           aspect_ratio[0][0] = 3.0;
            wire_width = wire_pitch[0][0] / 2;
!           wire_thickness = aspect_ratio[0][0] * wire_width;
            wire_spacing = wire_pitch[0][0] - wire_width;
            barrier_thickness = 0;
            dishing_thickness = 0;
            alpha_scatter = 1;
            wire_r_per_micron[0][0] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[0][0] = 0.078;
!           miller_value[0][0] = 1.5;
!           horiz_dielectric_constant[0][0] = 1.022;
!           vert_dielectric_constant[0][0] = 3.9;
            fringe_cap = 0.115e-15; 
            wire_c_per_micron[0][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness[0][0], miller_value[0][0], horiz_dielectric_constant[0][0],
! 			  vert_dielectric_constant[0][0],
                fringe_cap);
            
!           wire_pitch[0][1] = 4 * g_ip->wire_F_sz_um;
            wire_width = wire_pitch[0][1] / 2;
!           aspect_ratio[0][1] = 3.0;
!           wire_thickness = aspect_ratio[0][1] * wire_width;
            wire_spacing = wire_pitch[0][1] - wire_width;
            wire_r_per_micron[0][1] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
+           ild_thickness[0][1] = 0.078;
+           miller_value[0][1] = 1.5;
+           horiz_dielectric_constant[0][1] = 1.022;
+           vert_dielectric_constant[0][1] = 3.9;
            wire_c_per_micron[0][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness[0][1], miller_value[0][1], horiz_dielectric_constant[0][1],
! 			  vert_dielectric_constant[0][1],
                fringe_cap);
            
!           wire_pitch[0][2] = 8 * g_ip->wire_F_sz_um;
!           aspect_ratio[0][2] = 3.0;
            wire_width = wire_pitch[0][2] / 2;
!           wire_thickness = aspect_ratio[0][2] * wire_width;
            wire_spacing = wire_pitch[0][2] - wire_width;
            wire_r_per_micron[0][2] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[0][2] = 0.156;
!           miller_value[0][2] = 1.5;
!           horiz_dielectric_constant[0][2] = 1.022;
!           vert_dielectric_constant[0][2] = 3.9;
            wire_c_per_micron[0][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness[0][2], miller_value[0][2], horiz_dielectric_constant[0][2], vert_dielectric_constant[0][2],
                fringe_cap);
            
            //Conservative projections
!           wire_pitch[1][0] = 2.5 * g_ip->wire_F_sz_um;
!           aspect_ratio[1][0]  = 2.0;
            wire_width = wire_pitch[1][0] / 2;
!           wire_thickness = aspect_ratio[1][0] * wire_width;
            wire_spacing = wire_pitch[1][0] - wire_width;
            barrier_thickness = 0.002;
            dishing_thickness = 0;
            alpha_scatter = 1.05;
            wire_r_per_micron[1][0] = wire_resistance(CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[1][0]  = 0.078;
!           miller_value[1][0]  = 1.5;
!           horiz_dielectric_constant[1][0]  = 1.899;
!           vert_dielectric_constant[1][0]  = 3.9;
            fringe_cap = 0.115e-15; 
            wire_c_per_micron[1][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness[1][0] , miller_value[1][0] , horiz_dielectric_constant[1][0] , vert_dielectric_constant[1][0] ,
                fringe_cap);
            
!           wire_pitch[1][1] = 4 * g_ip->wire_F_sz_um;
!           aspect_ratio[1][1]  = 2.0;
            wire_width = wire_pitch[1][1] / 2;
!           wire_thickness = aspect_ratio[1][1]  * wire_width;
            wire_spacing = wire_pitch[1][1] - wire_width;
            wire_r_per_micron[1][1] = wire_resistance(CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
+           ild_thickness[1][1]  = 0.078;
+           miller_value[1][1]  = 1.5;
+           horiz_dielectric_constant[1][1]  = 1.899;
+           vert_dielectric_constant[1][1]  = 3.9;
            wire_c_per_micron[1][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness[1][1], miller_value[1][1], horiz_dielectric_constant[1][1] , vert_dielectric_constant[1][1] ,
                fringe_cap);
            
!           wire_pitch[1][2] = 8 * g_ip->wire_F_sz_um;
!           aspect_ratio[1][2] = 2.2;
            wire_width = wire_pitch[1][2] / 2;
!           wire_thickness = aspect_ratio[1][2] * wire_width;
            wire_spacing = wire_pitch[1][2] - wire_width;
            dishing_thickness = 0.1 *  wire_thickness; 
            wire_r_per_micron[1][2] = wire_resistance(CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[1][2] = 0.143;
!           miller_value[1][2]  = 1.5;
!           horiz_dielectric_constant[1][2]  = 1.899;
!           vert_dielectric_constant[1][2]  = 3.9;
            wire_c_per_micron[1][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness[1][2], miller_value[1][2], horiz_dielectric_constant[1][2], vert_dielectric_constant[1][2],
                fringe_cap);
          }
          else { // wire data from ITRS 2012 reports, by Woojoo Lee, USC.
***************
*** 1418,1510 ****
          wire_c_per_micron[1][3] = 20.4e-15 / (256 * 2 * 0.010);//F/micron
          wire_r_per_micron[1][3] = 12 / 0.010;//ohm/micron
        }
!       else if (tech == 7) {
!         if ( !g_ip->is_itrs2012 ) { // wire data from Ron Ho's PhD Thesis, Stanford, 2003.
            //Aggressive projections.
!           wire_pitch[0][0] = 2.5 * g_ip->F_sz_um;
!           aspect_ratio = 3.0;
!           wire_width = wire_pitch[0][0] / 2;
!           wire_thickness = aspect_ratio * wire_width;
!           wire_spacing = wire_pitch[0][0] - wire_width;
            barrier_thickness = 0;
            dishing_thickness = 0;
            alpha_scatter = 1;
            wire_r_per_micron[0][0] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness = 0.065;
!           miller_value = 1.5;
!           horiz_dielectric_constant = 0.864;
!           vert_dielectric_constant = 3.9;
            fringe_cap = 0.115e-15; 
            wire_c_per_micron[0][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[0][1] = 4 * g_ip->F_sz_um;
            wire_width = wire_pitch[0][1] / 2;
!           wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[0][1] - wire_width;
            wire_r_per_micron[0][1] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
            wire_c_per_micron[0][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[0][2] = 8 * g_ip->F_sz_um;
!           aspect_ratio = 3.0;
!           wire_width = wire_pitch[0][2] / 2;
!           wire_thickness = aspect_ratio * wire_width;
!           wire_spacing = wire_pitch[0][2] - wire_width;
!           wire_r_per_micron[0][2] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness = 0.130;
            wire_c_per_micron[0][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
!           
            //Conservative projections
!           wire_pitch[1][0] = 2.5 * g_ip->F_sz_um;
!           aspect_ratio = 2.0;
            wire_width = wire_pitch[1][0] / 2;
!           wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[1][0] - wire_width;
            barrier_thickness = 0.002;
            dishing_thickness = 0;
            alpha_scatter = 1.05;
            wire_r_per_micron[1][0] = wire_resistance(CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness = 0.065;
!           miller_value = 1.5;
!           horiz_dielectric_constant = 1.884;
!           vert_dielectric_constant = 3.9;
            fringe_cap = 0.115e-15; 
            wire_c_per_micron[1][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
!           
!           wire_pitch[1][1] = 4 * g_ip->F_sz_um;
!           wire_width = wire_pitch[1][1] / 2;
!           wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[1][1] - wire_width;
            wire_r_per_micron[1][1] = wire_resistance(CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           wire_c_per_micron[1][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
!           
!           wire_pitch[1][2] = 8 * g_ip->F_sz_um;
!           aspect_ratio = 2.2;
            wire_width = wire_pitch[1][2] / 2;
!           wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[1][2] - wire_width;
            dishing_thickness = 0.1 *  wire_thickness; 
            wire_r_per_micron[1][2] = wire_resistance(CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness = 0.103;
            wire_c_per_micron[1][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
          }
          else { // wire data from ITRS 2012 reports, by Woojoo Lee, USC.
            wire_pitch[0][0]        = 0.034;
            wire_pitch[0][1]        = 0.034;
--- 2141,2298 ----
          wire_c_per_micron[1][3] = 20.4e-15 / (256 * 2 * 0.010);//F/micron
          wire_r_per_micron[1][3] = 12 / 0.010;//ohm/micron
        }
!       else if (tech == 7 || tech == 14)	//divya including tech ==14 here {
!       {
!     	  if ( !g_ip->is_itrs2012 ) { // wire data from Ron Ho's PhD Thesis, Stanford, 2003.
            //Aggressive projections.
!         	//Divya adding for ASAP7 wire data. If itrs_2012 = false and asap7 = true . *** ONLY FOR AGGRESSIVE PROJECTIONS ***
!         	if(g_ip->is_asap7) { //Local wires
! //        		cout << "technology.cc:: wire : " << g_ip->wire_F_sz_um << ", tech: " << tech << ", asap7" << endl;
!         		wire_pitch[0][0] = 0.036;	//Local wires
!         		wire_width = 0.018;
! 			    wire_spacing = 0.018;
! 			    wire_thickness = 0.036;
!         		aspect_ratio[0][0]  = 2.0;
!         	}
!         	else { //Rohno 2003 PhD
! 			  wire_pitch[0][0] = 2.5 * g_ip->wire_F_sz_um;
! 			  aspect_ratio[0][0]  = 3.0;
! 			  wire_width = wire_pitch[0][0] / 2;
! 			  wire_thickness = aspect_ratio[0][0] * wire_width;
! 			  wire_spacing = wire_pitch[0][0] - wire_width;
!         	}
!         	//divya end
            barrier_thickness = 0;
            dishing_thickness = 0;
            alpha_scatter = 1;
            wire_r_per_micron[0][0] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[0][0]  = 0.065;
!           miller_value[0][0]  = 1.5;
!           horiz_dielectric_constant[0][0]  = 0.864;
!           vert_dielectric_constant[0][0]  = 3.9;
            fringe_cap = 0.115e-15; 
            wire_c_per_micron[0][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness[0][0] , miller_value[0][0] , horiz_dielectric_constant[0][0] , vert_dielectric_constant[0][0] ,
                fringe_cap);
            
!           //Divya adding for ASAP7 wire data. If itrs_2012 = false and asap7 = true
!           if(g_ip->is_asap7) { //semi-global wires
!         	  wire_pitch[0][1] = 0.048;	//semi-global wires
! 			  wire_width = 0.024;
! 			  wire_spacing = 0.024;
! 			  wire_thickness = 0.048;
! 			  aspect_ratio[0][1] = 2.0;
!           } else {
!           wire_pitch[0][1] = 4 * g_ip->wire_F_sz_um;
! 		  aspect_ratio[0][1]  = 3.0;
            wire_width = wire_pitch[0][1] / 2;
!           wire_thickness = aspect_ratio[0][1] * wire_width;
            wire_spacing = wire_pitch[0][1] - wire_width;
+           }
+           //divya end
+           ild_thickness[0][1]  = 0.065;
+           miller_value[0][1]  = 1.5;
+           horiz_dielectric_constant[0][1]  = 0.864;
+           vert_dielectric_constant[0][1]  = 3.9;
+ 
            wire_r_per_micron[0][1] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
            wire_c_per_micron[0][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness[0][1], miller_value[0][1], horiz_dielectric_constant[0][1], vert_dielectric_constant[0][1],
                fringe_cap);
            
!           //Divya adding for ASAP7 wire data. If itrs_2012 = false and asap7 = true
! 		   if(g_ip->is_asap7) { //Global wires
! 			  wire_pitch[0][2] = 0.08;	//global wires
! 			  wire_width = 0.04;
! 			  wire_spacing = 0.032;
! 			  wire_thickness = 0.08;
! 			  aspect_ratio[0][2] = 2.0;
! 		   } else {
! 			  wire_pitch[0][2] = 8 * g_ip->wire_F_sz_um;
! 			  aspect_ratio[0][2] = 3.0;
! 			  wire_width = wire_pitch[0][2] / 2;
! 			  wire_thickness = aspect_ratio[0][2] * wire_width;
! 			  wire_spacing = wire_pitch[0][2] - wire_width;
!            }
! 		   //divya end
! 	          miller_value[0][2]  = 1.5;
! 	          horiz_dielectric_constant[0][2]  = 0.864;
! 	          vert_dielectric_constant[0][2]  = 3.9;
! 
! 	       wire_r_per_micron[0][2] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[0][2] = 0.130;
            wire_c_per_micron[0][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness[0][2], miller_value[0][2], horiz_dielectric_constant[0][2], vert_dielectric_constant[0][2],
                fringe_cap);
!   /*
!           cout << " wire_r_per_micron[0][0]: " <<  wire_r_per_micron[0][0] <<
!         		  ", wire_c_per_micron[0][0]: " << wire_c_per_micron[0][0] <<
! 				  ", wire_r_per_micron[0][1]: " << wire_r_per_micron[0][1] <<
! 				  ", wire_c_per_micron[0][1]: " << wire_c_per_micron[0][1] <<
! 				  ", wire_r_per_micron[0][2]: " << wire_r_per_micron[0][2] <<
! 				   ", wire_c_per_micron[0][2]: " << wire_c_per_micron[0][2] << endl;
! */
            //Conservative projections
!           wire_pitch[1][0] = 2.5 * g_ip->wire_F_sz_um;
!           aspect_ratio[1][0] = 2.0;
            wire_width = wire_pitch[1][0] / 2;
!           wire_thickness = aspect_ratio[1][0] * wire_width;
            wire_spacing = wire_pitch[1][0] - wire_width;
            barrier_thickness = 0.002;
            dishing_thickness = 0;
            alpha_scatter = 1.05;
            wire_r_per_micron[1][0] = wire_resistance(CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[1][0] = 0.065;
!           miller_value[1][0] = 1.5;
!           horiz_dielectric_constant[1][0] = 1.884;
!           vert_dielectric_constant[1][0] = 3.9;
            fringe_cap = 0.115e-15; 
            wire_c_per_micron[1][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness[1][0], miller_value[1][0], horiz_dielectric_constant[1][0],
! 			  vert_dielectric_constant[1][0],
                fringe_cap);
! 
!           wire_pitch[1][1] = 4 * g_ip->wire_F_sz_um;
!           aspect_ratio[1][1] = 2.0;
!          wire_width = wire_pitch[1][1] / 2;
!           wire_thickness = aspect_ratio[1][1] * wire_width;
            wire_spacing = wire_pitch[1][1] - wire_width;
            wire_r_per_micron[1][1] = wire_resistance(CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[1][1] = 0.065;
!           miller_value[1][1] = 1.5;
!           horiz_dielectric_constant[1][1] = 1.884;
!           vert_dielectric_constant[1][1] = 3.9;
!          wire_c_per_micron[1][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!               ild_thickness[1][1], miller_value[1][1], horiz_dielectric_constant[1][1],
! 			  vert_dielectric_constant[1][1],
                fringe_cap);
! 
!           wire_pitch[1][2] = 8 * g_ip->wire_F_sz_um;
!           aspect_ratio[1][2] = 2.2;
            wire_width = wire_pitch[1][2] / 2;
!           wire_thickness = aspect_ratio[1][2] * wire_width;
            wire_spacing = wire_pitch[1][2] - wire_width;
            dishing_thickness = 0.1 *  wire_thickness; 
            wire_r_per_micron[1][2] = wire_resistance(CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[1][2] = 0.103;
!           miller_value[1][2] = 1.5;
!           horiz_dielectric_constant[1][2] = 1.884;
!           vert_dielectric_constant[1][2] = 3.9;
            wire_c_per_micron[1][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness[1][2], miller_value[1][2], horiz_dielectric_constant[1][2], vert_dielectric_constant[1][2],
                fringe_cap);
+ 
+ //---------------------------------------------------------------------------------------
+ //---------------------------------------------------------------------------------------
+ //---------------------------------------------------------------------------------------
          }
+ 
          else { // wire data from ITRS 2012 reports, by Woojoo Lee, USC.
            wire_pitch[0][0]        = 0.034;
            wire_pitch[0][1]        = 0.034;
***************
*** 1531,1618 ****
        else if (tech == 5) {
          if ( !g_ip->is_itrs2012 ) { // wire data from Ron Ho's PhD Thesis, Stanford, 2003.
            //Aggressive projections.
!           wire_pitch[0][0] = 2.5 * g_ip->F_sz_um;
!           aspect_ratio = 3.0;
            wire_width = wire_pitch[0][0] / 2;
!           wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[0][0] - wire_width;
            barrier_thickness = 0;
            dishing_thickness = 0;
            alpha_scatter = 1;
            wire_r_per_micron[0][0] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness = 0.065;
!           miller_value = 1.5;
!           horiz_dielectric_constant = 0.864;
!           vert_dielectric_constant = 3.9;
            fringe_cap = 0.115e-15; 
            wire_c_per_micron[0][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[0][1] = 4 * g_ip->F_sz_um;
            wire_width = wire_pitch[0][1] / 2;
!           wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[0][1] - wire_width;
            wire_r_per_micron[0][1] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           wire_c_per_micron[0][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[0][2] = 8 * g_ip->F_sz_um;
!           aspect_ratio = 3.0;
            wire_width = wire_pitch[0][2] / 2;
!           wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[0][2] - wire_width;
            wire_r_per_micron[0][2] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness = 0.130;
            wire_c_per_micron[0][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
            //Conservative projections
!           wire_pitch[1][0] = 2.5 * g_ip->F_sz_um;
!           aspect_ratio = 2.0;
            wire_width = wire_pitch[1][0] / 2;
!           wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[1][0] - wire_width;
            barrier_thickness = 0.002;
            dishing_thickness = 0;
            alpha_scatter = 1.05;
            wire_r_per_micron[1][0] = wire_resistance(CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness = 0.065;
!           miller_value = 1.5;
!           horiz_dielectric_constant = 1.884;
!           vert_dielectric_constant = 3.9;
            fringe_cap = 0.115e-15; 
            wire_c_per_micron[1][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[1][1] = 4 * g_ip->F_sz_um;
            wire_width = wire_pitch[1][1] / 2;
!           wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[1][1] - wire_width;
            wire_r_per_micron[1][1] = wire_resistance(CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
            wire_c_per_micron[1][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[1][2] = 8 * g_ip->F_sz_um;
!           aspect_ratio = 2.2;
            wire_width = wire_pitch[1][2] / 2;
!           wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[1][2] - wire_width;
            dishing_thickness = 0.1 *  wire_thickness; 
            wire_r_per_micron[1][2] = wire_resistance(CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness = 0.103;
            wire_c_per_micron[1][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
          }
          else { // wire data from ITRS 2012 reports, by Woojoo Lee, USC.
--- 2319,2422 ----
        else if (tech == 5) {
          if ( !g_ip->is_itrs2012 ) { // wire data from Ron Ho's PhD Thesis, Stanford, 2003.
            //Aggressive projections.
!           wire_pitch[0][0] = 2.5 * g_ip->wire_F_sz_um;
!           aspect_ratio[0][0] = 3.0;
            wire_width = wire_pitch[0][0] / 2;
!           wire_thickness = aspect_ratio[0][0] * wire_width;
            wire_spacing = wire_pitch[0][0] - wire_width;
            barrier_thickness = 0;
            dishing_thickness = 0;
            alpha_scatter = 1;
            wire_r_per_micron[0][0] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[0][0] = 0.065;
!           miller_value[0][0] = 1.5;
!           horiz_dielectric_constant[0][0] = 0.864;
!           vert_dielectric_constant[0][0] = 3.9;
            fringe_cap = 0.115e-15; 
            wire_c_per_micron[0][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness[0][0], miller_value[0][0], horiz_dielectric_constant[0][0], vert_dielectric_constant[0][0],
                fringe_cap);
            
!           wire_pitch[0][1] = 4 * g_ip->wire_F_sz_um;
!           aspect_ratio[0][1] = 3.0;
            wire_width = wire_pitch[0][1] / 2;
!           wire_thickness = aspect_ratio[0][1] * wire_width;
            wire_spacing = wire_pitch[0][1] - wire_width;
            wire_r_per_micron[0][1] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[0][1] = 0.065;
!           miller_value[0][1] = 1.5;
!           horiz_dielectric_constant[0][1] = 0.864;
!           vert_dielectric_constant[0][1] = 3.9;
!          wire_c_per_micron[0][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
!               ild_thickness[0][1], miller_value[0][1], horiz_dielectric_constant[0][1], vert_dielectric_constant[0][1],
                fringe_cap);
            
!           wire_pitch[0][2] = 8 * g_ip->wire_F_sz_um;
!           aspect_ratio[0][2] = 3.0;
            wire_width = wire_pitch[0][2] / 2;
!           wire_thickness = aspect_ratio[0][2] * wire_width;
            wire_spacing = wire_pitch[0][2] - wire_width;
            wire_r_per_micron[0][2] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[0][2] = 0.130;
!           miller_value[0][2] = 1.5;
!           horiz_dielectric_constant[0][2] = 0.864;
!           vert_dielectric_constant[0][2] = 3.9;
            wire_c_per_micron[0][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness[0][2], miller_value[0][2], horiz_dielectric_constant[0][2], vert_dielectric_constant[0][2],
                fringe_cap);
            
            //Conservative projections
!           wire_pitch[1][0] = 2.5 * g_ip->wire_F_sz_um;
!           aspect_ratio[1][0] = 2.0;
            wire_width = wire_pitch[1][0] / 2;
!           wire_thickness = aspect_ratio[1][0] * wire_width;
            wire_spacing = wire_pitch[1][0] - wire_width;
            barrier_thickness = 0.002;
            dishing_thickness = 0;
            alpha_scatter = 1.05;
            wire_r_per_micron[1][0] = wire_resistance(CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[1][0] = 0.065;
!           miller_value[1][0] = 1.5;
!           horiz_dielectric_constant[1][0] = 1.884;
!           vert_dielectric_constant[1][0] = 3.9;
            fringe_cap = 0.115e-15; 
            wire_c_per_micron[1][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness[1][0], miller_value[1][0], horiz_dielectric_constant[1][0], vert_dielectric_constant[1][0],
                fringe_cap);
            
!           wire_pitch[1][1] = 4 * g_ip->wire_F_sz_um;
!           aspect_ratio[1][1] = 2.0;
            wire_width = wire_pitch[1][1] / 2;
!           wire_thickness = aspect_ratio[1][1] * wire_width;
            wire_spacing = wire_pitch[1][1] - wire_width;
            wire_r_per_micron[1][1] = wire_resistance(CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
+           ild_thickness[1][1] = 0.065;
+           miller_value[1][1] = 1.5;
+           horiz_dielectric_constant[1][1] = 1.884;
+           vert_dielectric_constant[1][1] = 3.9;
            wire_c_per_micron[1][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness[1][1], miller_value[1][1], horiz_dielectric_constant[1][1], vert_dielectric_constant[1][1],
                fringe_cap);
            
!           wire_pitch[1][2] = 8 * g_ip->wire_F_sz_um;
!           aspect_ratio[1][2] = 2.2;
            wire_width = wire_pitch[1][2] / 2;
!           wire_thickness = aspect_ratio[1][2] * wire_width;
            wire_spacing = wire_pitch[1][2] - wire_width;
            dishing_thickness = 0.1 *  wire_thickness; 
            wire_r_per_micron[1][2] = wire_resistance(CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
!           ild_thickness[1][2] = 0.103;
!           miller_value[1][2] = 1.5;
!           horiz_dielectric_constant[1][2] = 1.884;
!           vert_dielectric_constant[1][2] = 3.9;
            wire_c_per_micron[1][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
!               ild_thickness[1][2], miller_value[1][2], horiz_dielectric_constant[1][2], vert_dielectric_constant[1][2],
                fringe_cap);
          }
          else { // wire data from ITRS 2012 reports, by Woojoo Lee, USC.
***************
*** 1643,1657 ****
        g_tp.wire_local.pitch    += curr_alpha * wire_pitch[g_ip->ic_proj_type][(ram_cell_tech_type == comm_dram)?3:0];
        g_tp.wire_local.R_per_um += curr_alpha * wire_r_per_micron[g_ip->ic_proj_type][(ram_cell_tech_type == comm_dram)?3:0];
        g_tp.wire_local.C_per_um += curr_alpha * wire_c_per_micron[g_ip->ic_proj_type][(ram_cell_tech_type == comm_dram)?3:0];
        
        g_tp.wire_inside_mat.pitch     += curr_alpha * wire_pitch[g_ip->ic_proj_type][g_ip->wire_is_mat_type];
        g_tp.wire_inside_mat.R_per_um  += curr_alpha * wire_r_per_micron[g_ip->ic_proj_type][g_ip->wire_is_mat_type];
        g_tp.wire_inside_mat.C_per_um  += curr_alpha * wire_c_per_micron[g_ip->ic_proj_type][g_ip->wire_is_mat_type];
        
        g_tp.wire_outside_mat.pitch    += curr_alpha * wire_pitch[g_ip->ic_proj_type][g_ip->wire_os_mat_type];
        g_tp.wire_outside_mat.R_per_um += curr_alpha * wire_r_per_micron[g_ip->ic_proj_type][g_ip->wire_os_mat_type];
        g_tp.wire_outside_mat.C_per_um += curr_alpha * wire_c_per_micron[g_ip->ic_proj_type][g_ip->wire_os_mat_type];
!       
        g_tp.unit_len_wire_del = g_tp.wire_inside_mat.R_per_um * g_tp.wire_inside_mat.C_per_um / 2;
      }
  	//-------------------- interconnect (wire) parameters end ----------------------------
--- 2447,2476 ----
        g_tp.wire_local.pitch    += curr_alpha * wire_pitch[g_ip->ic_proj_type][(ram_cell_tech_type == comm_dram)?3:0];
        g_tp.wire_local.R_per_um += curr_alpha * wire_r_per_micron[g_ip->ic_proj_type][(ram_cell_tech_type == comm_dram)?3:0];
        g_tp.wire_local.C_per_um += curr_alpha * wire_c_per_micron[g_ip->ic_proj_type][(ram_cell_tech_type == comm_dram)?3:0];
+       g_tp.wire_local.aspect_ratio  += curr_alpha * aspect_ratio[g_ip->ic_proj_type][(ram_cell_tech_type == comm_dram)?3:0];
+       g_tp.wire_local.ild_thickness += curr_alpha * ild_thickness[g_ip->ic_proj_type][(ram_cell_tech_type == comm_dram)?3:0];
+       g_tp.wire_local.miller_value   += curr_alpha * miller_value[g_ip->ic_proj_type][(ram_cell_tech_type == comm_dram)?3:0];
+       g_tp.wire_local.horiz_dielectric_constant += curr_alpha* horiz_dielectric_constant[g_ip->ic_proj_type][(ram_cell_tech_type == comm_dram)?3:0];
+       g_tp.wire_local.vert_dielectric_constant  += curr_alpha* vert_dielectric_constant [g_ip->ic_proj_type][(ram_cell_tech_type == comm_dram)?3:0];
        
        g_tp.wire_inside_mat.pitch     += curr_alpha * wire_pitch[g_ip->ic_proj_type][g_ip->wire_is_mat_type];
        g_tp.wire_inside_mat.R_per_um  += curr_alpha * wire_r_per_micron[g_ip->ic_proj_type][g_ip->wire_is_mat_type];
        g_tp.wire_inside_mat.C_per_um  += curr_alpha * wire_c_per_micron[g_ip->ic_proj_type][g_ip->wire_is_mat_type];
+       g_tp.wire_inside_mat.aspect_ratio  += curr_alpha * aspect_ratio[g_ip->ic_proj_type][g_ip->wire_is_mat_type];
+       g_tp.wire_inside_mat.ild_thickness += curr_alpha * ild_thickness[g_ip->ic_proj_type][g_ip->wire_is_mat_type];
+       g_tp.wire_inside_mat.miller_value   += curr_alpha * miller_value[g_ip->ic_proj_type][g_ip->wire_is_mat_type];
+       g_tp.wire_inside_mat.horiz_dielectric_constant += curr_alpha* horiz_dielectric_constant[g_ip->ic_proj_type][g_ip->wire_is_mat_type];
+       g_tp.wire_inside_mat.vert_dielectric_constant  += curr_alpha* vert_dielectric_constant [g_ip->ic_proj_type][g_ip->wire_is_mat_type];
        
        g_tp.wire_outside_mat.pitch    += curr_alpha * wire_pitch[g_ip->ic_proj_type][g_ip->wire_os_mat_type];
        g_tp.wire_outside_mat.R_per_um += curr_alpha * wire_r_per_micron[g_ip->ic_proj_type][g_ip->wire_os_mat_type];
        g_tp.wire_outside_mat.C_per_um += curr_alpha * wire_c_per_micron[g_ip->ic_proj_type][g_ip->wire_os_mat_type];
!       g_tp.wire_outside_mat.aspect_ratio  += curr_alpha * aspect_ratio[g_ip->ic_proj_type][g_ip->wire_os_mat_type];
!       g_tp.wire_outside_mat.ild_thickness += curr_alpha * ild_thickness[g_ip->ic_proj_type][g_ip->wire_os_mat_type];
!       g_tp.wire_outside_mat.miller_value   += curr_alpha * miller_value[g_ip->ic_proj_type][g_ip->wire_os_mat_type];
!       g_tp.wire_outside_mat.horiz_dielectric_constant += curr_alpha* horiz_dielectric_constant[g_ip->ic_proj_type][g_ip->wire_os_mat_type];
!       g_tp.wire_outside_mat.vert_dielectric_constant  += curr_alpha* vert_dielectric_constant [g_ip->ic_proj_type][g_ip->wire_os_mat_type];
! 
        g_tp.unit_len_wire_del = g_tp.wire_inside_mat.R_per_um * g_tp.wire_inside_mat.C_per_um / 2;
      }
  	//-------------------- interconnect (wire) parameters end ----------------------------
***************
*** 1659,1668 ****
  	 
  	g_tp.sense_delay = SENSE_AMP_D;
  	g_tp.sense_dy_power = SENSE_AMP_P;
! 	g_tp.horiz_dielectric_constant = horiz_dielectric_constant;
  	g_tp.vert_dielectric_constant = vert_dielectric_constant;
  	g_tp.aspect_ratio = aspect_ratio;
  	g_tp.miller_value = miller_value;
  
  	double rd = tr_R_on(g_tp.min_w_nmos_, NCH, 1);
  	double p_to_n_sizing_r = pmos_to_nmos_sz_ratio();
--- 2478,2490 ----
  	 
  	g_tp.sense_delay = SENSE_AMP_D;
  	g_tp.sense_dy_power = SENSE_AMP_P;
! /*
!  	g_tp.horiz_dielectric_constant = horiz_dielectric_constant;
  	g_tp.vert_dielectric_constant = vert_dielectric_constant;
  	g_tp.aspect_ratio = aspect_ratio;
  	g_tp.miller_value = miller_value;
+ */
+ 	  g_tp.fringe_cap = fringe_cap;
  
  	double rd = tr_R_on(g_tp.min_w_nmos_, NCH, 1);
  	double p_to_n_sizing_r = pmos_to_nmos_sz_ratio();
Only in FN-CACTI: technology_orig.cc
diff -crB pcacti_xml/uca.cc FN-CACTI/uca.cc
*** pcacti_xml/uca.cc	2014-07-03 09:50:06.000000000 +0200
--- FN-CACTI/uca.cc	2023-04-05 13:30:15.947235000 +0200
***************
*** 57,86 ****
      RWP  = dp.num_rw_ports;
      ERP  = dp.num_rd_ports;
      EWP  = dp.num_wr_ports;
    }
    else
    {
      RWP  = g_ip->num_rw_ports;
      ERP  = g_ip->num_rd_ports;
      EWP  = g_ip->num_wr_ports;
    }
  
    num_addr_b_bank = (dp.number_addr_bits_mat + dp.number_subbanks_decode)*(RWP+ERP+EWP);
!   num_di_b_bank   = dp.num_di_b_bank_per_port * (RWP + ERP);
!   num_do_b_bank   = dp.num_do_b_bank_per_port * (RWP + EWP);
  
-   if (g_ip->fast_access && dp.is_tag == false)
-   {
-     num_do_b_bank *= g_ip->data_assoc;
    }
  
!   htree_in_add   = new Htree2(g_ip->wt, bank.area.w, bank.area.h, 
!       num_addr_b_bank, num_di_b_bank, num_do_b_bank, num_banks_ver_dir*2, num_banks_hor_dir*2, Add_htree, true);
!   htree_in_data  = new Htree2(g_ip->wt, bank.area.w, bank.area.h,
!       num_addr_b_bank, num_di_b_bank, num_do_b_bank, num_banks_ver_dir*2, num_banks_hor_dir*2, Data_in_htree, true);
!   htree_out_data = new Htree2(g_ip->wt, bank.area.w, bank.area.h, 
!       num_addr_b_bank, num_di_b_bank, num_do_b_bank, num_banks_ver_dir*2, num_banks_hor_dir*2, Data_out_htree, true);
! 
    area.w = htree_in_data->area.w;
    area.h = htree_in_data->area.h;
  
--- 57,113 ----
      RWP  = dp.num_rw_ports;
      ERP  = dp.num_rd_ports;
      EWP  = dp.num_wr_ports;
+ 	SCHP = dp.num_search_ports;
    }
    else
    {
      RWP  = g_ip->num_rw_ports;
      ERP  = g_ip->num_rd_ports;
      EWP  = g_ip->num_wr_ports;
+ 	SCHP = g_ip->num_search_ports;
    }
  
    num_addr_b_bank = (dp.number_addr_bits_mat + dp.number_subbanks_decode)*(RWP+ERP+EWP);
!   num_di_b_bank   = dp.num_di_b_bank_per_port * (RWP + EWP);
!   num_do_b_bank   = dp.num_do_b_bank_per_port * (RWP + ERP);
!   num_si_b_bank   = dp.num_si_b_bank_per_port * SCHP;
!   num_so_b_bank   = dp.num_so_b_bank_per_port * SCHP;
! 
! //  cout << "uca initialized \n";
! //  cout << "fa : " << dp.fully_assoc << "cam : " << dp.pure_cam << endl;
! 
!   if (!dp.fully_assoc && !dp.pure_cam)
!   {
! 	  if (g_ip->fast_access && dp.is_tag == false)
! 	  {
! 		num_do_b_bank *= g_ip->data_assoc;
! 	  }
! /*	  cout << "wt " << g_ip->wt << "a.w: " << bank.area.w << ", a.h: " << bank.area.h <<
! 			  "addr_b: " << num_addr_b_bank << "di_bank: " << num_di_b_bank << "do_bank: " << num_do_b_bank <<
! 			  ", num_banks_ver_dir: " << num_banks_ver_dir << ", num_banks_hor_dir " << num_banks_hor_dir << endl;
! */
! 	  htree_in_add   = new Htree2(g_ip->wt, bank.area.w, bank.area.h,
! 		  num_addr_b_bank, num_di_b_bank, 0, num_do_b_bank, 0, num_banks_ver_dir*2, num_banks_hor_dir*2, Add_htree, true);
! 	  htree_in_data  = new Htree2(g_ip->wt, bank.area.w, bank.area.h,
! 		  num_addr_b_bank, num_di_b_bank, 0, num_do_b_bank, 0, num_banks_ver_dir*2, num_banks_hor_dir*2, Data_in_htree, true);
! 	  htree_out_data = new Htree2(g_ip->wt, bank.area.w, bank.area.h,
! 		  num_addr_b_bank, num_di_b_bank, 0, num_do_b_bank, 0, num_banks_ver_dir*2, num_banks_hor_dir*2, Data_out_htree, true);
  
    }
+   else
+   {
+ 	  htree_in_add   = new Htree2(g_ip->wt, bank.area.w, bank.area.h,
+ 	  			  num_addr_b_bank, num_di_b_bank, num_si_b_bank, num_do_b_bank, num_so_b_bank, num_banks_ver_dir*2, num_banks_hor_dir*2, Add_htree, true);
+ 	  htree_in_data  = new Htree2(g_ip->wt, bank.area.w, bank.area.h,
+ 			  num_addr_b_bank, num_di_b_bank,num_si_b_bank, num_do_b_bank, num_so_b_bank, num_banks_ver_dir*2, num_banks_hor_dir*2, Data_in_htree, true);
+ 	  htree_out_data = new Htree2(g_ip->wt, bank.area.w, bank.area.h,
+ 			  num_addr_b_bank, num_di_b_bank,num_si_b_bank, num_do_b_bank, num_so_b_bank, num_banks_ver_dir*2, num_banks_hor_dir*2, Data_out_htree, true);
+ 	  htree_in_search  = new Htree2(g_ip->wt, bank.area.w, bank.area.h,
+ 			  num_addr_b_bank, num_di_b_bank,num_si_b_bank, num_do_b_bank, num_so_b_bank, num_banks_ver_dir*2, num_banks_hor_dir*2, Data_in_htree, true);
+ 	  htree_out_search = new Htree2(g_ip->wt, bank.area.w, bank.area.h,
+ 	  			  num_addr_b_bank, num_di_b_bank,num_si_b_bank, num_do_b_bank, num_so_b_bank, num_banks_ver_dir*2, num_banks_hor_dir*2, Data_out_htree, true);
  
!   }
    area.w = htree_in_data->area.w;
    area.h = htree_in_data->area.h;
  
***************
*** 99,104 ****
--- 126,136 ----
    delete htree_in_add;
    delete htree_in_data;
    delete htree_out_data;
+   if (dp.fully_assoc || dp.pure_cam)
+   {
+ 	  delete htree_in_search;
+ 	  delete htree_out_search;
+   }
  }
  
  
***************
*** 125,134 ****
    delay_from_subarray_out_drv_to_out = bank.mat.delay_subarray_out_drv_htree +
                                         bank.htree_out_data->delay + htree_out_data->delay;
    access_time                        = bank.mat.delay_comparator;
  
    if (g_ip->fully_assoc)
    {
!     if (dp.is_tag)
      { //delay of fully-associative tag decoder
        access_time = htree_in_add->delay + bank.htree_in_add->delay + bank.mat.delay_fa_decoder;
      }
--- 156,187 ----
    delay_from_subarray_out_drv_to_out = bank.mat.delay_subarray_out_drv_htree +
                                         bank.htree_out_data->delay + htree_out_data->delay;
    access_time                        = bank.mat.delay_comparator;
+ /*
+   cout << "uca:: outrise: " << outrisetime << endl;
+   cout << "uca:: delay_array_to_mat: " << delay_array_to_mat << endl;
+   cout << "htree_in_add->delay : " << htree_in_add->delay << "\n, bank.htree_in_add->delay : " << bank.htree_in_add->delay << endl;
+ 
+   cout << "delay_array_to_mat : " << delay_array_to_mat << "\n, bank.mat.r_predec->delay : " << bank.mat.r_predec->delay <<
+ 		   "\n, bank.mat.sa_mux_lev_1_predec->delay : " << bank.mat.sa_mux_lev_1_predec->delay <<
+ 		   "\n, bank.mat.sa_mux_lev_1_dec->delay: " << bank.mat.sa_mux_lev_1_dec->delay
+ 		  << "\n, bank.mat.sa_mux_lev_2_predec->delay : " << bank.mat.sa_mux_lev_2_predec->delay <<
+ 		   "\n, bank.mat.sa_mux_lev_2_dec->delay: " << bank.mat.sa_mux_lev_2_dec->delay
+ 		   << "\n, bank.mat.row_dec->delay: " << bank.mat.row_dec->delay <<
+ 		   "\n ,bank.mat.delay_bitline: " << bank.mat.delay_bitline <<
+ 		   "\n ,bank.mat.delay_sa: " << bank.mat.delay_sa <<
+ 
+ 		   "\n, bank.mat.b_mux_predec->delay : " << bank.mat.b_mux_predec->delay << "\n, bank.mat.bit_mux_dec->delay : " << bank.mat.bit_mux_dec->delay <<
+ 		  "\n, bank.mat.delay_sa : " << bank.mat.delay_sa <<
+ 		  "\n, bank.mat.delay_subarray_out_drv_htree: " << bank.mat.delay_subarray_out_drv_htree <<
+ 		  "\n ,bank.htree_out_data->delay: " << bank.htree_out_data->delay <<
+ 		  "\n ,htree_out_data->delay: " << htree_out_data->delay<<
+ 		   "\n, access_time : " << access_time << endl << endl;
+ */
  
+   double ram_delay_inside_mat;
    if (g_ip->fully_assoc)
    {
! /*    if (dp.is_tag)
      { //delay of fully-associative tag decoder
        access_time = htree_in_add->delay + bank.htree_in_add->delay + bank.mat.delay_fa_decoder;
      }
***************
*** 136,147 ****
      { //delay of fully-associative data array
        access_time = delay_inside_mat + delay_from_subarray_out_drv_to_out;
      }
    }
    else
    {
      access_time = delay_before_subarray_output_driver + delay_from_subarray_out_drv_to_out; //data_acc_path
    }
! 
    if (dp.is_main_mem)
    {
      double t_rcd       = max_delay_before_row_decoder + delay_inside_mat;
--- 189,208 ----
      { //delay of fully-associative data array
        access_time = delay_inside_mat + delay_from_subarray_out_drv_to_out;
      }
+ */
+ 	  //delay of FA contains both CAM tag and RAM data
+ 	    { //delay of CAM
+ 	      ram_delay_inside_mat = bank.mat.delay_bitline + bank.mat.delay_matchchline;
+ 	      access_time = htree_in_add->delay + bank.htree_in_add->delay;
+ 	      //delay of fully-associative data array
+ 	      access_time += ram_delay_inside_mat + delay_from_subarray_out_drv_to_out;
+ 	    }
    }
    else
    {
      access_time = delay_before_subarray_output_driver + delay_from_subarray_out_drv_to_out; //data_acc_path
    }
! //  cout << "access_time : " << access_time << endl;
    if (dp.is_main_mem)
    {
      double t_rcd       = max_delay_before_row_decoder + delay_inside_mat;
***************
*** 151,175 ****
    }
  
    double temp;
!   if (dp.is_tag && g_ip->fully_assoc)
!   {
!     temp = bank.mat.delay_fa_decoder;
!   }
!   else
    {
      temp = delay_inside_mat + bank.mat.delay_wl_reset + bank.mat.delay_bl_restore;
      if (dp.is_dram)
      {
        temp += bank.mat.delay_writeback;  // temp stores random cycle time
      }
-   }
  
    temp = MAX(temp, bank.mat.r_predec->delay);
    temp = MAX(temp, bank.mat.b_mux_predec->delay);
    temp = MAX(temp, bank.mat.sa_mux_lev_1_predec->delay);
    temp = MAX(temp, bank.mat.sa_mux_lev_2_predec->delay);
  
!   // The following is true only if the input parameter "repeaters_in_htree" is set to false --Nav 
    if (g_ip->rpters_in_htree == false)
    {
      temp = MAX(temp, bank.htree_in_add->max_unpipelined_link_delay);
--- 212,251 ----
    }
  
    double temp;
!  if(!dp.fully_assoc)
    {
      temp = delay_inside_mat + bank.mat.delay_wl_reset + bank.mat.delay_bl_restore;
      if (dp.is_dram)
      {
        temp += bank.mat.delay_writeback;  // temp stores random cycle time
      }
  
+ /*  cout << "bank.mat.row_dec->delay : " << bank.mat.row_dec->delay << ", bank.mat.delay_bitline : " <<
+   bank.mat.delay_bitline << ", bank.mat.delay_sa : " << bank.mat.delay_sa << endl;
+   cout << "delay_inside_mat : " << delay_inside_mat << "\n, delay_wl_reset : " << bank.mat.delay_wl_reset << "\n, delay_bl_restore : " << bank.mat.delay_bl_restore <<
+ 		  "\n, cycle_time : " << temp <<endl;
+ */
    temp = MAX(temp, bank.mat.r_predec->delay);
    temp = MAX(temp, bank.mat.b_mux_predec->delay);
    temp = MAX(temp, bank.mat.sa_mux_lev_1_predec->delay);
    temp = MAX(temp, bank.mat.sa_mux_lev_2_predec->delay);
+ /*  cout << "bank.mat.r_predec->delay : " << bank.mat.r_predec->delay << "\n, bank.mat.b_mux_predec->delay : " << bank.mat.b_mux_predec->delay <<
+ 		  "\n, bank.mat.sa_mux_lev_1_predec->delay : " << bank.mat.sa_mux_lev_1_predec->delay <<
+   		  "\n, bank.mat.sa_mux_lev_2_predec->delay : " << bank.mat.sa_mux_lev_2_predec->delay <<endl;
+ */
+   }
+  else {
+ 	  ram_delay_inside_mat = bank.mat.delay_bitline + bank.mat.delay_matchchline;
+ 	  temp = ram_delay_inside_mat + bank.mat.delay_cam_sl_restore + bank.mat.delay_cam_ml_reset + bank.mat.delay_bl_restore
+ 	         + bank.mat.delay_hit_miss_reset + bank.mat.delay_wl_reset;
+ 
+ 	  temp = MAX(temp, bank.mat.b_mux_predec->delay);//TODO: Sheng revisit whether distinguish cam and ram bitline etc.
+ 	  temp = MAX(temp, bank.mat.sa_mux_lev_1_predec->delay);
+ 	  temp = MAX(temp, bank.mat.sa_mux_lev_2_predec->delay);
  
!  }
! 
! // The following is true only if the input parameter "repeaters_in_htree" is set to false --Nav
    if (g_ip->rpters_in_htree == false)
    {
      temp = MAX(temp, bank.htree_in_add->max_unpipelined_link_delay);
***************
*** 192,198 ****
    {
      precharge_delay = 0;
    }
! 
    double dram_array_availability = 0;
    if (dp.is_dram)
    {
--- 268,274 ----
    {
      precharge_delay = 0;
    }
! //  cout << "cycle time : " << cycle_time << endl << endl;
    double dram_array_availability = 0;
    if (dp.is_dram)
    {
***************
*** 212,235 ****
  
    power_routing_to_bank.readOp.dynamic  = htree_in_add->power.readOp.dynamic + htree_out_data->power.readOp.dynamic;
    power_routing_to_bank.writeOp.dynamic = htree_in_add->power.readOp.dynamic + htree_in_data->power.readOp.dynamic;
    power_routing_to_bank.readOp.leakage += htree_in_add->power.readOp.leakage +
                                            htree_in_data->power.readOp.leakage +
!                                           htree_out_data->power.readOp.leakage;
  
    power.readOp.dynamic += power_routing_to_bank.readOp.dynamic;
    power.readOp.leakage += power_routing_to_bank.readOp.leakage;
! 
    // calculate total write energy per access
    power.writeOp.dynamic = power.readOp.dynamic 
                          - bank.mat.power_bitline.readOp.dynamic * dp.num_act_mats_hor_dir
                          + bank.mat.power_bitline.writeOp.dynamic * dp.num_act_mats_hor_dir
!                         - bank.mat.power_row_decoders.readOp.dynamic * dp.num_act_mats_hor_dir  // Alireza: for 8T SRAM cell
!                         + bank.mat.power_row_decoders.writeOp.dynamic * dp.num_act_mats_hor_dir // Alireza: for 8T SRAM cell
                          - power_routing_to_bank.readOp.dynamic
                          + power_routing_to_bank.writeOp.dynamic
                          + bank.htree_in_data->power.readOp.dynamic
                          - bank.htree_out_data->power.readOp.dynamic;
  
    if (dp.is_dram == false)
    {
      power.writeOp.dynamic -= bank.mat.power_sa.readOp.dynamic * dp.num_act_mats_hor_dir;
--- 288,344 ----
  
    power_routing_to_bank.readOp.dynamic  = htree_in_add->power.readOp.dynamic + htree_out_data->power.readOp.dynamic;
    power_routing_to_bank.writeOp.dynamic = htree_in_add->power.readOp.dynamic + htree_in_data->power.readOp.dynamic;
+ 
+ //  cout << "uca:: power to bank readOp: " <<  power_routing_to_bank.readOp.dynamic <<
+ //		  " writeOp: " <<  power_routing_to_bank.writeOp.dynamic << endl;
+   if (dp.fully_assoc || dp.pure_cam)
+   {
+       power_routing_to_bank.searchOp.dynamic= htree_in_search->power.searchOp.dynamic + htree_out_search->power.searchOp.dynamic;
+   }
    power_routing_to_bank.readOp.leakage += htree_in_add->power.readOp.leakage +
                                            htree_in_data->power.readOp.leakage +
! 										  htree_out_data->power.readOp.leakage;
! /*
!   if( dp.is_tag)
! 	  cout << "tag" << " uca.cc leakage init: " << power.readOp.leakage << endl;
!   else
! 	  cout << "data" << " uca.cc leakage init: " << power.readOp.leakage << endl;
! */
!   if (dp.fully_assoc || dp.pure_cam)
! 	power_routing_to_bank.readOp.leakage += htree_in_search->power.readOp.leakage + htree_out_search->power.readOp.leakage;
  
+   power.searchOp.dynamic += power_routing_to_bank.searchOp.dynamic;
    power.readOp.dynamic += power_routing_to_bank.readOp.dynamic;
    power.readOp.leakage += power_routing_to_bank.readOp.leakage;
! /*
!   if( dp.is_tag)
!  	  cout << "tag" << " uca.cc leakage 1: " << power.readOp.leakage << endl;
!    else
!  	  cout << "data" << " uca.cc leakage 1: " << power.readOp.leakage << endl;
! */
    // calculate total write energy per access
    power.writeOp.dynamic = power.readOp.dynamic 
                          - bank.mat.power_bitline.readOp.dynamic * dp.num_act_mats_hor_dir
                          + bank.mat.power_bitline.writeOp.dynamic * dp.num_act_mats_hor_dir
!                       //  - bank.mat.power_row_decoders.readOp.dynamic * dp.num_act_mats_hor_dir  // Alireza: for 8T SRAM cell
!                       //  + bank.mat.power_row_decoders.writeOp.dynamic * dp.num_act_mats_hor_dir // Alireza: for 8T SRAM cell
                          - power_routing_to_bank.readOp.dynamic
                          + power_routing_to_bank.writeOp.dynamic
                          + bank.htree_in_data->power.readOp.dynamic
                          - bank.htree_out_data->power.readOp.dynamic;
  
+ /*  cout << "uca:: power.readOp.dynamic: " << power.readOp.dynamic
+ 		  << ", -bank.mat.power_bitline.readOp.dynamic: " << bank.mat.power_bitline.readOp.dynamic
+ 		  << ", +bank.mat.power_bitline.writeOp.dynamic: " << bank.mat.power_bitline.writeOp.dynamic
+ 		//  << ", bank.mat.power_row_decoders.readOp.dynamic: " << bank.mat.power_row_decoders.readOp.dynamic
+ 		//  << ", bank.mat.power_row_decoders.writeOp.dynamic: " << bank.mat.power_row_decoders.writeOp.dynamic
+ 		  << ", -power_routing_to_bank.readOp.dynamic: " << power_routing_to_bank.readOp.dynamic
+ 		  << ", +power_routing_to_bank.writeOp.dynamic: " << power_routing_to_bank.writeOp.dynamic
+ 		  << ", +bank.htree_in_data->power.readOp.dynamic: " << bank.htree_in_data->power.readOp.dynamic
+ 		  << ", -bank.htree_out_data->power.readOp.dynamic: " << bank.htree_out_data->power.readOp.dynamic
+ 		  << ", power.writeOp.dynamic: " << power.writeOp.dynamic
+ 		  << endl;
+ */
    if (dp.is_dram == false)
    {
      power.writeOp.dynamic -= bank.mat.power_sa.readOp.dynamic * dp.num_act_mats_hor_dir;
***************
*** 300,311 ****
--- 410,427 ----
       bank.mat.power_sa_mux_lev_1_decoders.readOp.leakage +
       bank.mat.power_sa_mux_lev_2_decoders.readOp.leakage +
       bank.mat.leak_power_sense_amps_open_page_state) * dp.num_act_mats_hor_dir;
+ 
    leak_power_request_and_reply_networks =
      power_routing_to_bank.readOp.leakage +
      bank.htree_in_add->power.readOp.leakage +
      bank.htree_in_data->power.readOp.leakage +
      bank.htree_out_data->power.readOp.leakage;
  
+   if (dp.fully_assoc || dp.pure_cam)
+   {
+ 	leak_power_request_and_reply_networks += htree_in_search->power.readOp.leakage + htree_out_search->power.readOp.leakage;
+   }
+ 
    if (dp.is_dram)
    { // if DRAM, add contribution of power spent in row predecoder drivers, blocks and decoders to refresh power
      refresh_power  = (bank.mat.r_predec->power.readOp.dynamic * dp.num_act_mats_hor_dir +
***************
*** 324,331 ****
        - dyn_read_energy_remaining_words_in_burst
        - bank.mat.power_bitline.readOp.dynamic * dp.num_act_mats_hor_dir
        + bank.mat.power_bitline.writeOp.dynamic * dp.num_act_mats_hor_dir
!       - bank.mat.power_row_decoders.readOp.dynamic * dp.num_act_mats_hor_dir  // Alireza: for 8T SRAM cell
!       + bank.mat.power_row_decoders.writeOp.dynamic * dp.num_act_mats_hor_dir // Alireza: for 8T SRAM cell
        + (power_routing_to_bank.writeOp.dynamic - 
           power_routing_to_bank.readOp.dynamic -
           bank.htree_out_data->power.readOp.dynamic +
--- 440,447 ----
        - dyn_read_energy_remaining_words_in_burst
        - bank.mat.power_bitline.readOp.dynamic * dp.num_act_mats_hor_dir
        + bank.mat.power_bitline.writeOp.dynamic * dp.num_act_mats_hor_dir
!     //  - bank.mat.power_row_decoders.readOp.dynamic * dp.num_act_mats_hor_dir  // Alireza: for 8T SRAM cell
!     //  + bank.mat.power_row_decoders.writeOp.dynamic * dp.num_act_mats_hor_dir // Alireza: for 8T SRAM cell
        + (power_routing_to_bank.writeOp.dynamic - 
           power_routing_to_bank.readOp.dynamic -
           bank.htree_out_data->power.readOp.dynamic +
diff -crB pcacti_xml/Ucache.cc FN-CACTI/Ucache.cc
*** pcacti_xml/Ucache.cc	2014-07-03 09:47:06.000000000 +0200
--- FN-CACTI/Ucache.cc	2023-04-05 13:30:12.259291000 +0200
***************
*** 112,117 ****
--- 112,118 ----
    list<mem_array *> & tag_arr    = calc_obj->tag_arr;
    bool is_tag                    = calc_obj->is_tag;
    bool pure_ram                  = calc_obj->pure_ram;
+   bool pure_cam					 = calc_obj->pure_cam;
    bool is_main_mem               = calc_obj->is_main_mem;
    double Nspd_min                = calc_obj->Nspd_min;
    min_values_t * data_res        = calc_obj->data_res;
***************
*** 130,136 ****
  
    bool is_valid_partition;
    int wt_min, wt_max;
! 
    if (g_ip->force_wiretype) {
      if (g_ip->wt == 0) {
        wt_min = Low_swing;
--- 131,137 ----
  
    bool is_valid_partition;
    int wt_min, wt_max;
! /*
    if (g_ip->force_wiretype) {
      if (g_ip->wt == 0) {
        wt_min = Low_swing;
***************
*** 145,150 ****
--- 146,166 ----
      wt_min = Global;
      wt_max = Low_swing;
    }
+ */
+ 
+   //Divya adding this
+   if (!g_ip->force_wiretype) {
+ 	  wt_min = Global;
+ 	  wt_max = Low_swing;
+   }
+   else  { //force_wiretype == true
+ 	  wt_min = g_ip->wt;
+ 	  wt_max = g_ip->wt;
+   }
+ 
+ //  if(g_ip->force_cache_config)
+ //  cout << "ucache.cc force config: " << g_ip->force_cache_config << ", ndbl: " << g_ip->ndbl << ", ndwl: " << g_ip->ndwl <<
+ //		  ", nspd: " << g_ip->nspd << ", ndcm: " << g_ip->nspd << ", sam1: " << g_ip->ndsam1 << ", sam2: " << g_ip->ndsam2 << endl;
  
    for (double Nspd = Nspd_min; Nspd <= MAXDATASPD; Nspd *= 2)
    {
***************
*** 161,184 ****
            for(unsigned int Ndsam_lev_2 = 1; Ndsam_lev_2 <= MAX_COL_MUX; Ndsam_lev_2 *= 2)
            {
              //for debuging
!             if (g_ip->force_cache_config && is_tag == false)
              {
!               wr   = g_ip->wt;
!               Ndwl = g_ip->ndwl;
!               Ndbl = g_ip->ndbl;
!               Ndcm = g_ip->ndcm;
!               if(g_ip->nspd != 0) {
!                 Nspd = g_ip->nspd;
!               }
!               if(g_ip->ndsam1 != 0) {
!                 Ndsam_lev_1 = g_ip->ndsam1;
!                 Ndsam_lev_2 = g_ip->ndsam2;
!               }
              }
  
              if (is_tag == true)
              {
!               is_valid_partition = calculate_time(is_tag, pure_ram, Nspd, Ndwl, 
                    Ndbl, Ndcm, Ndsam_lev_1, Ndsam_lev_2,
                    tag_arr.back(), 0, NULL, NULL,
                    is_main_mem);
--- 177,230 ----
            for(unsigned int Ndsam_lev_2 = 1; Ndsam_lev_2 <= MAX_COL_MUX; Ndsam_lev_2 *= 2)
            {
              //for debuging
!         	  //Divya changing this so that Tag array parameters also take same value as data array parameters in force_onfig is true
!             if (g_ip->force_cache_config)// && is_tag == false) //if (g_ip->force_cache_config && is_tag == false) //divya
              {
!        		  wr   = g_ip->wt;
!  //      		  cout << "wire: " << wr << endl;
!        		  if(is_tag == false) { //divya added this line
! 				  Ndwl = g_ip->ndwl;
! 				  Ndbl = g_ip->ndbl;
! 				  Ndcm = g_ip->ndcm;
! 				  if(g_ip->nspd != 0) {
! 					Nspd = g_ip->nspd;
! 				  }
! 				  if(g_ip->ndsam1 != 0) {
! 					Ndsam_lev_1 = g_ip->ndsam1;
! 					Ndsam_lev_2 = g_ip->ndsam2;
! 				  }
! //	              	cout << "data array:  Nspd : " << Nspd << " Ndbl : " <<  Ndbl
! //	             			<<  " Ndwl : " <<  Ndwl<< " Ndcm : " << Ndcm << " Ndsam1 : " << Ndsam_lev_1 << " Ndsam2 : " << Ndsam_lev_2 << endl;
! 
!        		  }
!        		  //Divya adding tag params
!        		  else { //is_tag == true
!        			 Ndwl = g_ip->ntwl;
! 				  Ndbl = g_ip->ntbl;
! 				  Ndcm = g_ip->ntcm;
! 				  if(g_ip->ntspd != 0) {
! 					Nspd = g_ip->ntspd;
! 				  }
! 				  if(g_ip->ntsam1 != 0) {
! 					Ndsam_lev_1 = g_ip->ntsam1;
! 					Ndsam_lev_2 = g_ip->ntsam2;
! 				  }
! //	              	cout << "tag array:  Nspd : " << Nspd << " Ndbl : " <<  Ndbl
! //	             			<<  " Ndwl : " <<  Ndwl<< " Ndcm : " << Ndcm << " Ndsam1 : " << Ndsam_lev_1 << " Ndsam2 : " << Ndsam_lev_2 << endl;
!        		  }//divya added end
!             }
!             // Divya adding to propagate wire signalling effect when force_cache_config is false
!             else {
!             	g_ip->wt = (enum Wire_type) wr;
              }
  
              if (is_tag == true)
              {
! //            	if(g_ip->force_cache_config)
! //               	cout << "tag partition : " << is_valid_partition << " Nspd : " << Nspd << " Ndbl : " <<  Ndbl
! //             			<<  " Ndwl : " <<  Ndwl<< " Ndcm : " << Ndcm << " Ndsam1 : " << Ndsam_lev_1 << " Ndsam2 : " << Ndsam_lev_2 << endl;
! 
!                	is_valid_partition = calculate_time(is_tag, pure_ram,pure_cam, Nspd, Ndwl,
                    Ndbl, Ndcm, Ndsam_lev_1, Ndsam_lev_2,
                    tag_arr.back(), 0, NULL, NULL,
                    is_main_mem);
***************
*** 187,215 ****
              // the tag array, so compute data array partition properties also here.
              if (is_tag == false || g_ip->fully_assoc)
              {
!               is_valid_partition = calculate_time(is_tag/*false*/, pure_ram, Nspd, Ndwl, 
                    Ndbl, Ndcm, Ndsam_lev_1, Ndsam_lev_2,
                    data_arr.back(), 0, NULL, NULL,
                    is_main_mem);
!             }
  
              if (is_valid_partition)
              {
                if (is_tag == true)
                {
                  tag_arr.back()->wt = (enum Wire_type) wr;
                  tag_res->update_min_values(tag_arr.back());
                  tag_arr.push_back(new mem_array);
                }
                if (is_tag == false || g_ip->fully_assoc)
                {
                  data_arr.back()->wt = (enum Wire_type) wr;
                  data_res->update_min_values(data_arr.back());
                  data_arr.push_back(new mem_array);
                }
              }
  
!             if (g_ip->force_cache_config && is_tag == false)
              {
                wr   = wt_max;
                iter = niter;
--- 233,274 ----
              // the tag array, so compute data array partition properties also here.
              if (is_tag == false || g_ip->fully_assoc)
              {
!  //           	if(g_ip->force_cache_config)
!  //            	cout << "data partition : " << is_valid_partition << " Nspd : " << Nspd << " Ndbl : " <<  Ndbl
!  //            			<<  " Ndwl : " <<  Ndwl<< " Ndcm : " << Ndcm << " Ndsam1 : " << Ndsam_lev_1 << " Ndsam2 : " << Ndsam_lev_2 << endl;
! 
!              	is_valid_partition = calculate_time(is_tag/*false*/, pure_ram,pure_cam, Nspd, Ndwl,
                    Ndbl, Ndcm, Ndsam_lev_1, Ndsam_lev_2,
                    data_arr.back(), 0, NULL, NULL,
                    is_main_mem);
!               }
  
              if (is_valid_partition)
              {
                if (is_tag == true)
                {
+            //   	cout << "tag partition valid \n";
+ //               	cout << "tag partition : " << is_valid_partition <<  " Ntwl : " <<  Ndwl  << " Ntbl : " <<  Ndbl
+ //            			<< " Ntspd : " << Nspd << " Ntcm : " << Ndcm << " Ntsam1 : " << Ndsam_lev_1 << " Ntsam2 : " << Ndsam_lev_2 << endl;
+ 
                  tag_arr.back()->wt = (enum Wire_type) wr;
                  tag_res->update_min_values(tag_arr.back());
                  tag_arr.push_back(new mem_array);
                }
                if (is_tag == false || g_ip->fully_assoc)
                {
+            //   	cout << "data partition valid \n";
+ //                 	cout << "data partition : " << is_valid_partition <<  " Ndwl : " <<  Ndwl  << " Ndbl : " <<  Ndbl
+ //               			<< " Nspd : " << Nspd << " Ndcm : " << Ndcm << " Ndsam1 : " << Ndsam_lev_1 << " Ndsam2 : " << Ndsam_lev_2 << endl;
+ 
                  data_arr.back()->wt = (enum Wire_type) wr;
                  data_res->update_min_values(data_arr.back());
                  data_arr.push_back(new mem_array);
                }
              }
  
!             //Divya changing this so that Tag array parameters also take same value as data array parameters in force_onfig is true
!             if (g_ip->force_cache_config) // && is_tag == false) //if (g_ip->force_cache_config && is_tag == false) //original.
              {
                wr   = wt_max;
                iter = niter;
***************
*** 240,245 ****
--- 299,305 ----
  bool calculate_time(
      bool is_tag,
      int pure_ram,
+     bool pure_cam,
      double Nspd,
      unsigned int Ndwl, 
      unsigned int Ndbl,
***************
*** 252,271 ****
      uca_org_t *ptr_fin_res,
      bool is_main_mem)
  {
!   DynamicParameter dyn_p(is_tag, pure_ram, Nspd, Ndwl, Ndbl, Ndcm, Ndsam_lev_1, Ndsam_lev_2, is_main_mem);
! 
    if (dyn_p.is_valid == false)
    {
      return false;
    }
  
    UCA * uca = new UCA(dyn_p);
  
    if (flag_results_populate)
    { //For the final solution, populate the ptr_results data structure  -- TODO: copy only necessary variables
    }
    else
    {
      ptr_array->Ndwl = Ndwl;
      ptr_array->Ndbl = Ndbl;
      ptr_array->Nspd = Nspd;
--- 312,334 ----
      uca_org_t *ptr_fin_res,
      bool is_main_mem)
  {
!   DynamicParameter dyn_p(is_tag, pure_ram, pure_cam, Nspd, Ndwl, Ndbl, Ndcm, Ndsam_lev_1, Ndsam_lev_2, is_main_mem);
    if (dyn_p.is_valid == false)
    {
+ //	  cout << "tag : " << is_tag << "dynp invalid \n";
      return false;
    }
  
    UCA * uca = new UCA(dyn_p);
+ //  cout << "exiting uca \n";
  
    if (flag_results_populate)
    { //For the final solution, populate the ptr_results data structure  -- TODO: copy only necessary variables
    }
    else
    {
+ 	  collect_uca_results(Nspd, Ndwl, Ndbl, Ndcm, Ndsam_lev_1, Ndsam_lev_2, uca, ptr_array, is_main_mem);
+ /*//Divya moving these values to collect_uca_results() function
      ptr_array->Ndwl = Ndwl;
      ptr_array->Ndbl = Ndbl;
      ptr_array->Nspd = Nspd;
***************
*** 350,405 ****
      ptr_array->subarray_num_cols = uca->bank.mat.subarray.num_cols;
      ptr_array->num_subarrays_per_mat = uca->bank.mat.num_subarrays_per_mat;
    // Alireza - End
    }
  
    delete uca;
    return true;
  }
  
  
! 
! bool check_uca_org(uca_org_t & u, min_values_t *minval) 
  {
!   if (((u.access_time - minval->min_delay)*100/minval->min_delay) > g_ip->delay_dev) {
      return false;
    }
!   if (((u.power.readOp.dynamic - minval->min_dyn)/minval->min_dyn)*100 > 
        g_ip->dynamic_power_dev) {
      return false;
    }
!   if (((u.power.readOp.leakage - minval->min_leakage)/minval->min_leakage)*100 > 
        g_ip->leakage_power_dev) {
      return false;
    }
!   if (((u.cycle_time - minval->min_cyc)/minval->min_cyc)*100 > 
        g_ip->cycle_time_dev) {
      return false;
    }
!   if (((u.area - minval->min_area)/minval->min_area)*100 > 
        g_ip->area_dev) {
      return false;
    }
    return true;
  }
  
! bool check_mem_org(mem_array & u, const min_values_t *minval) 
  {
!   if (((u.access_time - minval->min_delay)*100/minval->min_delay) > g_ip->delay_dev) {
      return false;
    }
!   if (((u.power.readOp.dynamic - minval->min_dyn)/minval->min_dyn)*100 > 
        g_ip->dynamic_power_dev) {
      return false;
    }
!   if (((u.power.readOp.leakage - minval->min_leakage)/minval->min_leakage)*100 > 
        g_ip->leakage_power_dev) {
      return false;
    }
!   if (((u.cycle_time - minval->min_cyc)/minval->min_cyc)*100 > 
        g_ip->cycle_time_dev) {
      return false;
    }
!   if (((u.area - minval->min_area)/minval->min_area)*100 > 
        g_ip->area_dev) {
      return false;
    }
--- 413,660 ----
      ptr_array->subarray_num_cols = uca->bank.mat.subarray.num_cols;
      ptr_array->num_subarrays_per_mat = uca->bank.mat.num_subarrays_per_mat;
    // Alireza - End
+ */
    }
  
    delete uca;
    return true;
  }
  
+ //Divya added 11-11-2020
+ void collect_uca_results(
+     double Nspd,
+     unsigned int Ndwl,
+     unsigned int Ndbl,
+     unsigned int Ndcm,
+     unsigned int Ndsam_lev_1,
+     unsigned int Ndsam_lev_2,
+     UCA const * const uca,
+     mem_array * const ptr_array,
+     bool is_main_mem)
+ {
+ 	int num_act_mats_hor_dir = uca->bank.dp.num_act_mats_hor_dir;
+ 	int num_mats = uca->bank.dp.num_mats;
+ 	  bool is_fa = uca->bank.dp.fully_assoc;
+ 	  bool pure_cam = uca->bank.dp.pure_cam;
+ 
+ 	   ptr_array->Ndwl = Ndwl;
+ 	    ptr_array->Ndbl = Ndbl;
+ 	    ptr_array->Nspd = Nspd;
+ 	    ptr_array->deg_bl_muxing = uca->bank.dp.deg_bl_muxing;
+ 	    ptr_array->Ndsam_lev_1 = Ndsam_lev_1;
+ 	    ptr_array->Ndsam_lev_2 = Ndsam_lev_2;
+ 	    ptr_array->access_time = uca->access_time;
+ 	    ptr_array->cycle_time = uca->cycle_time;
+ 	    ptr_array->multisubbank_interleave_cycle_time = uca->multisubbank_interleave_cycle_time;
+ 	    ptr_array->area_ram_cells = uca->area_all_dataramcells;
+ 	    ptr_array->area   = uca->area.get_area();
+ 	    ptr_array->height = uca->area.h;
+ 	    ptr_array->width  = uca->area.w;
+ 	    ptr_array->mat_height = uca->bank.mat.area.h;
+ 	    ptr_array->mat_length = uca->bank.mat.area.w;
+ 	    ptr_array->subarray_height = uca->bank.mat.subarray.area.h;
+ 	    ptr_array->subarray_length = uca->bank.mat.subarray.area.w;
+ 	    ptr_array->power  = uca->power;
+ 	    ptr_array->delay_senseamp_mux_decoder =
+ 	      MAX(uca->delay_array_to_sa_mux_lev_1_decoder,
+ 	          uca->delay_array_to_sa_mux_lev_2_decoder);
+ 	    ptr_array->delay_before_subarray_output_driver         = uca->delay_before_subarray_output_driver;
+ 	    ptr_array->delay_from_subarray_output_driver_to_output = uca->delay_from_subarray_out_drv_to_out;
+ 
+ 	    ptr_array->delay_route_to_bank          = uca->htree_in_add->delay;
+ 	    ptr_array->delay_input_htree            = uca->bank.htree_in_add->delay;
+ 	    ptr_array->delay_row_predecode_driver_and_block = uca->bank.mat.r_predec->delay;
+ 	    ptr_array->delay_row_decoder            = uca->bank.mat.row_dec->delay;
+ 	    ptr_array->delay_bitlines               = uca->bank.mat.delay_bitline;
+ 	    ptr_array->delay_matchlines               = uca->bank.mat.delay_matchchline;
+ 	    ptr_array->delay_sense_amp              = uca->bank.mat.delay_sa;
+ 	    ptr_array->delay_subarray_output_driver = uca->bank.mat.delay_subarray_out_drv_htree;
+ 	    ptr_array->delay_dout_htree             = uca->bank.htree_out_data->delay;
+ 	    ptr_array->delay_comparator             = uca->bank.mat.delay_comparator;
+ 
+ 	    ptr_array->all_banks_height = uca->area.h;
+ 	    ptr_array->all_banks_width  = uca->area.w;
+ 	    ptr_array->area_efficiency = uca->area_all_dataramcells * 100 / (uca->area.get_area());
+ 
+ 	    ptr_array->power_routing_to_bank = uca->power_routing_to_bank;
+ 	    ptr_array->power_addr_input_htree = uca->bank.htree_in_add->power;
+ 	    ptr_array->power_data_input_htree = uca->bank.htree_in_data->power;
+ 	    ptr_array->power_data_output_htree = uca->bank.htree_out_data->power;
+ 
+ 	    ptr_array->power_row_predecoder_drivers = uca->bank.mat.r_predec->driver_power;
+ 	    ptr_array->power_row_predecoder_drivers.readOp.dynamic *= num_act_mats_hor_dir;
+ 	    ptr_array->power_row_predecoder_drivers.writeOp.dynamic *= num_act_mats_hor_dir;
+ 	    ptr_array->power_row_predecoder_drivers.searchOp.dynamic *= num_act_mats_hor_dir;
+ 
+ 	    ptr_array->power_row_predecoder_blocks = uca->bank.mat.r_predec->block_power;
+ 	    ptr_array->power_row_predecoder_blocks.readOp.dynamic *= num_act_mats_hor_dir;
+ 	    ptr_array->power_row_predecoder_blocks.writeOp.dynamic *= num_act_mats_hor_dir;
+ 	    ptr_array->power_row_predecoder_blocks.searchOp.dynamic *= num_act_mats_hor_dir;
+ 
+ 	    ptr_array->power_row_decoders = uca->bank.mat.power_row_decoders;
+ 	    ptr_array->power_row_decoders.readOp.dynamic *= num_act_mats_hor_dir;
+ 	    ptr_array->power_row_decoders.writeOp.dynamic *= num_act_mats_hor_dir;
+ 	    ptr_array->power_row_decoders.searchOp.dynamic *= num_act_mats_hor_dir;
+ 
+ 	    ptr_array->power_bit_mux_predecoder_drivers = uca->bank.mat.b_mux_predec->driver_power;
+ 	    ptr_array->power_bit_mux_predecoder_drivers.readOp.dynamic *= num_act_mats_hor_dir;
+ 	    ptr_array->power_bit_mux_predecoder_drivers.writeOp.dynamic *= num_act_mats_hor_dir;
+ 	    ptr_array->power_bit_mux_predecoder_drivers.searchOp.dynamic *= num_act_mats_hor_dir;
+ 
+ 	    ptr_array->power_bit_mux_predecoder_blocks  = uca->bank.mat.b_mux_predec->block_power;
+ 	    ptr_array->power_bit_mux_predecoder_blocks.readOp.dynamic *= num_act_mats_hor_dir;
+ 	    ptr_array->power_bit_mux_predecoder_blocks.writeOp.dynamic *= num_act_mats_hor_dir;
+ 	    ptr_array->power_bit_mux_predecoder_blocks.searchOp.dynamic *= num_act_mats_hor_dir;
+ 
+ 	    ptr_array->power_bit_mux_decoders = uca->bank.mat.power_bit_mux_decoders;
+ 	    ptr_array->power_bit_mux_decoders.readOp.dynamic *= num_act_mats_hor_dir;
+ 	    ptr_array->power_bit_mux_decoders.writeOp.dynamic *= num_act_mats_hor_dir;
+ 	    ptr_array->power_bit_mux_decoders.searchOp.dynamic *= num_act_mats_hor_dir;
+ 
+ 	    ptr_array->power_senseamp_mux_lev_1_predecoder_drivers = uca->bank.mat.sa_mux_lev_1_predec->driver_power;
+ 	    ptr_array->power_senseamp_mux_lev_1_predecoder_drivers .readOp.dynamic *= num_act_mats_hor_dir;
+ 	    ptr_array->power_senseamp_mux_lev_1_predecoder_drivers .writeOp.dynamic *= num_act_mats_hor_dir;
+ 	    ptr_array->power_senseamp_mux_lev_1_predecoder_drivers .searchOp.dynamic *= num_act_mats_hor_dir;
+ 
+ 	    ptr_array->power_senseamp_mux_lev_1_predecoder_blocks = uca->bank.mat.sa_mux_lev_1_predec->block_power;
+ 	    ptr_array->power_senseamp_mux_lev_1_predecoder_blocks.readOp.dynamic *= num_act_mats_hor_dir;
+ 	    ptr_array->power_senseamp_mux_lev_1_predecoder_blocks.writeOp.dynamic *= num_act_mats_hor_dir;
+ 	    ptr_array->power_senseamp_mux_lev_1_predecoder_blocks.searchOp.dynamic *= num_act_mats_hor_dir;
+ 
+ 	    ptr_array->power_senseamp_mux_lev_1_decoders = uca->bank.mat.power_sa_mux_lev_1_decoders;
+ 	    ptr_array->power_senseamp_mux_lev_1_decoders.readOp.dynamic *= num_act_mats_hor_dir;
+ 	    ptr_array->power_senseamp_mux_lev_1_decoders.writeOp.dynamic *= num_act_mats_hor_dir;
+ 	    ptr_array->power_senseamp_mux_lev_1_decoders.searchOp.dynamic *= num_act_mats_hor_dir;
+ 
+ 	    ptr_array->power_senseamp_mux_lev_2_predecoder_drivers = uca->bank.mat.sa_mux_lev_2_predec->driver_power;
+ 	    ptr_array->power_senseamp_mux_lev_2_predecoder_drivers.readOp.dynamic *= num_act_mats_hor_dir;
+ 	    ptr_array->power_senseamp_mux_lev_2_predecoder_drivers.writeOp.dynamic *= num_act_mats_hor_dir;
+ 	    ptr_array->power_senseamp_mux_lev_2_predecoder_drivers.searchOp.dynamic *= num_act_mats_hor_dir;
+ 
+ 	    ptr_array->power_senseamp_mux_lev_2_predecoder_blocks = uca->bank.mat.sa_mux_lev_2_predec->block_power;
+ 	    ptr_array->power_senseamp_mux_lev_2_predecoder_blocks.readOp.dynamic *= num_act_mats_hor_dir;
+ 	    ptr_array->power_senseamp_mux_lev_2_predecoder_blocks.writeOp.dynamic *= num_act_mats_hor_dir;
+ 	    ptr_array->power_senseamp_mux_lev_2_predecoder_blocks.searchOp.dynamic *= num_act_mats_hor_dir;
+ 
+ 	    ptr_array->power_senseamp_mux_lev_2_decoders = uca->bank.mat.power_sa_mux_lev_2_decoders;
+ 	    ptr_array->power_senseamp_mux_lev_2_decoders .readOp.dynamic *= num_act_mats_hor_dir;
+ 	    ptr_array->power_senseamp_mux_lev_2_decoders .writeOp.dynamic *= num_act_mats_hor_dir;
+ 	    ptr_array->power_senseamp_mux_lev_2_decoders .searchOp.dynamic *= num_act_mats_hor_dir;
+ 
+ 	    ptr_array->power_bitlines = uca->bank.mat.power_bitline;
+ 	    ptr_array->power_bitlines.readOp.dynamic *= num_act_mats_hor_dir;
+ 	    ptr_array->power_bitlines.writeOp.dynamic *= num_act_mats_hor_dir;
+ 	    ptr_array->power_bitlines.searchOp.dynamic *= num_act_mats_hor_dir;
+ 
+ 	    ptr_array->power_sense_amps = uca->bank.mat.power_sa;
+ 	    ptr_array->power_sense_amps.readOp.dynamic *= num_act_mats_hor_dir;
+ 	    ptr_array->power_sense_amps.writeOp.dynamic *= num_act_mats_hor_dir;
+ 	    ptr_array->power_sense_amps.searchOp.dynamic *= num_act_mats_hor_dir;
+ 
+ 	    ptr_array->power_prechg_eq_drivers = uca->bank.mat.power_bl_precharge_eq_drv;
+ 	    ptr_array->power_prechg_eq_drivers.readOp.dynamic *= num_act_mats_hor_dir;
+ 	    ptr_array->power_prechg_eq_drivers.writeOp.dynamic *= num_act_mats_hor_dir;
+ 	    ptr_array->power_prechg_eq_drivers.searchOp.dynamic *= num_act_mats_hor_dir;
+ 
+ 	    ptr_array->power_output_drivers_at_subarray = uca->bank.mat.power_subarray_out_drv;
+ 	    ptr_array->power_output_drivers_at_subarray.readOp.dynamic *= num_act_mats_hor_dir;
+ 	    ptr_array->power_output_drivers_at_subarray.writeOp.dynamic *= num_act_mats_hor_dir;
+ 	    ptr_array->power_output_drivers_at_subarray.searchOp.dynamic *= num_act_mats_hor_dir;
+ 
+ 	    ptr_array->power_comparators = uca->bank.mat.power_comparator;
+ 	    ptr_array->power_comparators.readOp.dynamic *= num_act_mats_hor_dir;
+ 	    ptr_array->power_comparators.writeOp.dynamic *= num_act_mats_hor_dir;
+ 	    ptr_array->power_comparators.searchOp.dynamic *= num_act_mats_hor_dir;
+ 
+ 	    if (is_fa || pure_cam)
+ 	    {
+ 			ptr_array->power_htree_in_search = uca->bank.htree_in_search->power;
+ 		//    cout<<"power_htree_in_search"<<uca->bank.htree_in_search->power.readOp.leakage<<endl;
+ 			ptr_array->power_htree_out_search = uca->bank.htree_out_search->power;
+ 		//    cout<<"power_htree_out_search"<<uca->bank.htree_out_search->power.readOp.leakage<<endl;
+ 			ptr_array->power_searchline = uca->bank.mat.power_searchline;
+ 		//    cout<<"power_searchlineh"<<uca->bank.mat.power_searchline.readOp.leakage<<endl;
+ 			ptr_array->power_searchline.searchOp.dynamic *= num_mats;
+ 			ptr_array->power_searchline_precharge = uca->bank.mat.power_searchline_precharge;
+ 			ptr_array->power_searchline_precharge.searchOp.dynamic *= num_mats;
+ 			ptr_array->power_matchlines = uca->bank.mat.power_matchline;
+ 			ptr_array->power_matchlines.searchOp.dynamic *= num_mats;
+ 			ptr_array->power_matchline_precharge = uca->bank.mat.power_matchline_precharge;
+ 			ptr_array->power_matchline_precharge.searchOp.dynamic *= num_mats;
+ 			ptr_array->power_matchline_to_wordline_drv = uca->bank.mat.power_ml_to_ram_wl_drv;
+ 		//    cout<<"power_matchline.searchOp.leakage"<<uca->bank.mat.power_matchline.searchOp.leakage<<endl;
+ 	    }
+ 
+ 	    ptr_array->activate_energy = uca->activate_energy;
+ 	    ptr_array->read_energy = uca->read_energy;
+ 	    ptr_array->write_energy = uca->write_energy;
+ 	    ptr_array->precharge_energy = uca->precharge_energy;
+ 	    ptr_array->refresh_power = uca->refresh_power;
+ 	    ptr_array->leak_power_subbank_closed_page = uca->leak_power_subbank_closed_page;
+ 	    ptr_array->leak_power_subbank_open_page = uca->leak_power_subbank_open_page;
+ 	    ptr_array->leak_power_request_and_reply_networks = uca->leak_power_request_and_reply_networks;
+ 
+ 	    ptr_array->precharge_delay = uca->precharge_delay;
+ 
+ 		ptr_array->array_leakage= uca->bank.array_leakage;
+ 		ptr_array->wl_leakage= uca->bank.wl_leakage;
+ 		ptr_array->cl_leakage= uca->bank.cl_leakage;
+ 
+ 	  // Alireza - Begin
+ 	    ptr_array->leak_power_bank = uca->bank.power.readOp.leakage;
+ 	    ptr_array->leak_power_mat = uca->bank.mat.power.readOp.leakage;
+ 	    ptr_array->leak_power_sram_cell = uca->bank.mat.leak_power_sram_cell;
+ 	    ptr_array->leak_power_mem_array = uca->bank.mat.power_bitline.readOp.leakage;
+ 
+ 	    ptr_array->subarray_num_rows = uca->bank.mat.subarray.num_rows;
+ 	    ptr_array->subarray_num_cols = uca->bank.mat.subarray.num_cols;
+ 	    ptr_array->num_subarrays_per_mat = uca->bank.mat.num_subarrays_per_mat;
+ 	  // Alireza - End
+ }
+ //Divye end
  
! bool check_uca_org(uca_org_t & u, min_values_t & minval)
  {
!   if (((u.access_time - minval.min_delay)*100/minval.min_delay) > g_ip->delay_dev) {
      return false;
    }
!   if (((u.power.readOp.dynamic - minval.min_dyn)/minval.min_dyn)*100 >
        g_ip->dynamic_power_dev) {
      return false;
    }
!   if (((u.power.readOp.leakage - minval.min_leakage)/minval.min_leakage)*100 >
        g_ip->leakage_power_dev) {
      return false;
    }
!   if (((u.cycle_time - minval.min_cyc)/minval.min_cyc)*100 >
        g_ip->cycle_time_dev) {
      return false;
    }
!   if (((u.area - minval.min_area)/minval.min_area)*100 >
        g_ip->area_dev) {
      return false;
    }
    return true;
  }
  
! bool check_mem_org(mem_array & u, const min_values_t & minval)
  {
!   if (((u.access_time - minval.min_delay)*100/minval.min_delay) > g_ip->delay_dev) {
      return false;
    }
!   if (((u.power.readOp.dynamic - minval.min_dyn)/minval.min_dyn)*100 >
        g_ip->dynamic_power_dev) {
      return false;
    }
!   if (((u.power.readOp.leakage - minval.min_leakage)/minval.min_leakage)*100 >
        g_ip->leakage_power_dev) {
      return false;
    }
!   if (((u.cycle_time - minval.min_cyc)/minval.min_cyc)*100 >
        g_ip->cycle_time_dev) {
      return false;
    }
!   if (((u.area - minval.min_area)/minval.min_area)*100 >
        g_ip->area_dev) {
      return false;
    }
***************
*** 407,420 ****
  }
  
  
! 
! 
! void find_optimal_uca(uca_org_t *res, min_values_t * minval, list<uca_org_t> & ulist)
  {
    double cost = 0;
    double min_cost = BIGNUM;
    float d, a, dp, lp, c;
! 
    dp = g_ip->dynamic_power_wt;
    lp = g_ip->leakage_power_wt;
    a  = g_ip->area_wt;
--- 662,673 ----
  }
  
  
! void find_optimal_uca(uca_org_t *res, min_values_t & minval, list<uca_org_t> & ulist)
  {
    double cost = 0;
    double min_cost = BIGNUM;
    float d, a, dp, lp, c;
! //  int count = 0; 	//divya
    dp = g_ip->dynamic_power_wt;
    lp = g_ip->leakage_power_wt;
    a  = g_ip->area_wt;
***************
*** 431,448 ****
    { 
      if (g_ip->ed == 1)
      {
!       cost = ((niter)->access_time/minval->min_delay) * ((niter)->power.readOp.dynamic/minval->min_dyn);
        if (min_cost > cost)
        {
          min_cost = cost;
          *res = (*(niter));
        }
      }
      else if (g_ip->ed == 2)
      {
!       cost = ((niter)->access_time/minval->min_delay)*
!              ((niter)->access_time/minval->min_delay)*
!              ((niter)->power.readOp.dynamic/minval->min_dyn);
        if (min_cost > cost)
        {
          min_cost = cost;
--- 684,710 ----
    { 
      if (g_ip->ed == 1)
      {
!       cost = ((niter)->access_time/minval.min_delay) * ((niter)->power.readOp.dynamic/minval.min_dyn);
        if (min_cost > cost)
        {
          min_cost = cost;
          *res = (*(niter));
        }
+ /*
+       cout << "(niter)->access_time : " << (niter)->access_time <<
+     		  ", minval.min_delay : " << minval.min_delay <<
+ 			  ", (niter)->power.readOp.dynamic : " << (niter)->power.readOp.dynamic <<
+ 			  ", minval.min_dyn : " << minval.min_dyn <<
+ 			  ", (niter)->access_time/minval.min_delay) : " << ((niter)->access_time/minval.min_delay) <<
+ 				", ((niter)->power.readOp.dynamic/minval.min_dyn) : " << ((niter)->power.readOp.dynamic/minval.min_dyn)
+ 				<< ", cost : " << cost<< endl;
+ */
      }
      else if (g_ip->ed == 2)
      {
!       cost = ((niter)->access_time/minval.min_delay)*
!              ((niter)->access_time/minval.min_delay)*
!              ((niter)->power.readOp.dynamic/minval.min_dyn);
        if (min_cost > cost)
        {
          min_cost = cost;
***************
*** 456,470 ****
         * meets the input deviation constraints
         */
        bool v = check_uca_org(*niter, minval);
!       if (minval->min_leakage == 0) minval->min_leakage = 0.1; //FIXME remove this after leakage modeling
  
        if (v)
        {
!         cost = (d  * ((niter)->access_time/minval->min_delay) +
!                 c  * ((niter)->cycle_time/minval->min_cyc) +
!                 dp * ((niter)->power.readOp.dynamic/minval->min_dyn) +
!                 lp * ((niter)->power.readOp.leakage/minval->min_leakage) +
!                 a  * ((niter)->area/minval->min_area));
          //fprintf(stderr, "cost = %g\n", cost);
  
          if (min_cost > cost) {
--- 718,732 ----
         * meets the input deviation constraints
         */
        bool v = check_uca_org(*niter, minval);
!       if (minval.min_leakage == 0) minval.min_leakage = 0.1; //FIXME remove this after leakage modeling
  
        if (v)
        {
!         cost = (d  * ((niter)->access_time/minval.min_delay) +
!                 c  * ((niter)->cycle_time/minval.min_cyc) +
!                 dp * ((niter)->power.readOp.dynamic/minval.min_dyn) +
!                 lp * ((niter)->power.readOp.leakage/minval.min_leakage) +
!                 a  * ((niter)->area/minval.min_area));
          //fprintf(stderr, "cost = %g\n", cost);
  
          if (min_cost > cost) {
***************
*** 491,497 ****
  
  
  
! void filter_tag_arr(const min_values_t * min, list<mem_array *> & list)
  {
    double cost = BIGNUM;
    double cur_cost;
--- 753,759 ----
  
  
  
! void filter_tag_arr(const min_values_t & min, list<mem_array *> & list)
  {
    double cost = BIGNUM;
    double cur_cost;
***************
*** 500,506 ****
  
    if (list.empty() == true)
    {
!     cout << "ERROR: no valid tag organizations found" << endl;
      exit(1);
    }
  
--- 762,768 ----
  
    if (list.empty() == true)
    {
!     cout << "ERROR: no valid tag organizations found: empty list" << endl;
      exit(1);
    }
  
***************
*** 510,520 ****
      bool v = check_mem_org(*list.back(), min);
      if (v) 
      {
!       cur_cost = wt_delay   * (list.back()->access_time/min->min_delay) +
!         wt_dyn     * (list.back()->power.readOp.dynamic/min->min_dyn) +
!         wt_leakage * (list.back()->power.readOp.leakage/min->min_leakage) +
!         wt_area    * (list.back()->area/min->min_area) +
!         wt_cyc     * (list.back()->cycle_time/min->min_cyc);
      }
      else 
      {
--- 772,782 ----
      bool v = check_mem_org(*list.back(), min);
      if (v) 
      {
!       cur_cost = wt_delay   * (list.back()->access_time/min.min_delay) +
!         wt_dyn     * (list.back()->power.readOp.dynamic/min.min_dyn) +
!         wt_leakage * (list.back()->power.readOp.leakage/min.min_leakage) +
!         wt_area    * (list.back()->area/min.min_area) +
!         wt_cyc     * (list.back()->cycle_time/min.min_cyc);
      }
      else 
      {
***************
*** 537,543 ****
    }
    if(!res) 
    {
!     cout << "ERROR: no valid tag organizations found" << endl; 
      exit(0);
    }
  
--- 799,805 ----
    }
    if(!res) 
    {
!     cout << "ERROR: no valid tag organizations found: result NULL" << endl;
      exit(0);
    }
  
***************
*** 562,569 ****
  
      if (m == NULL) exit(1);
    
!     if(((m->access_time - m->arr_min->min_delay)/m->arr_min->min_delay > 0.5) &&
!        ((m->power.readOp.dynamic - m->arr_min->min_dyn)/m->arr_min->min_dyn > 0.5))
      {
        delete m;
        iter = curr_list.erase(iter);
--- 824,831 ----
  
      if (m == NULL) exit(1);
    
!     if(((m->access_time - m->arr_min.min_delay)/m->arr_min.min_delay > 0.5) &&
!        ((m->power.readOp.dynamic - m->arr_min.min_dyn)/m->arr_min.min_dyn > 0.5))
      {
        delete m;
        iter = curr_list.erase(iter);
***************
*** 589,599 ****
  void solve(uca_org_t *fin_res)
  {
    bool   is_dram  = false;
!   int    pure_ram = (!g_ip->is_cache || g_ip->is_main_mem);
! 
! 
!   init_tech_params(g_ip->F_sz_um, false);
  
  
    list<mem_array *> tag_arr (0);
    list<mem_array *> data_arr(0);
--- 851,861 ----
  void solve(uca_org_t *fin_res)
  {
    bool   is_dram  = false;
!   int    pure_ram = g_ip->pure_ram;
!   bool   pure_cam = g_ip->pure_cam;
  
+ //  init_tech_params(g_ip->F_sz_um, false);
+   init_tech_params(g_ip->F_sz_um, g_ip->wire_F_sz_um, false); //divya added wire technology
  
    list<mem_array *> tag_arr (0);
    list<mem_array *> data_arr(0);
***************
*** 608,613 ****
--- 870,876 ----
    fin_res->tag_array.Ndsam_lev_1 = 0;
    fin_res->tag_array.Ndsam_lev_2 = 0;
  
+ //  cout << "solve intialized\n";
  
    // distribute calculate_time() execution to multiple threads
    calc_time_mt_wrapper_struct * calc_array = new calc_time_mt_wrapper_struct[nthreads];
***************
*** 617,622 ****
--- 880,886 ----
    {
      calc_array[t].tid         = t;
      calc_array[t].pure_ram    = pure_ram;
+     calc_array[t].pure_cam    = pure_cam;
      calc_array[t].data_res    = new min_values_t();
      calc_array[t].tag_res     = new min_values_t();
    }
***************
*** 625,636 ****
    uint32_t ram_cell_tech_type;
  
    // If it's a cache, first calculate the area, delay and power for all tag array partitions.
!   if (!pure_ram)
    { //cache
      is_tag              = true;
      ram_cell_tech_type  = g_ip->tag_arr_ram_cell_tech_type;
      is_dram             = ((ram_cell_tech_type == lp_dram) || (ram_cell_tech_type == comm_dram));
!     init_tech_params(g_ip->F_sz_um, is_tag);
  
      for (uint32_t t = 0; t < nthreads; t++)
      {
--- 889,901 ----
    uint32_t ram_cell_tech_type;
  
    // If it's a cache, first calculate the area, delay and power for all tag array partitions.
!   if (!(pure_ram||pure_cam||g_ip->fully_assoc))
    { //cache
      is_tag              = true;
      ram_cell_tech_type  = g_ip->tag_arr_ram_cell_tech_type;
      is_dram             = ((ram_cell_tech_type == lp_dram) || (ram_cell_tech_type == comm_dram));
! //    init_tech_params(g_ip->F_sz_um, is_tag);
!     init_tech_params(g_ip->F_sz_um, g_ip->wire_F_sz_um, false); //divya added wire technology
  
      for (uint32_t t = 0; t < nthreads; t++)
      {
***************
*** 654,673 ****
      }
    }
  
- 
    // calculate the area, delay and power for all data array partitions (for cache or plain RAM).
!   if (!g_ip->fully_assoc)
!   {
      is_tag              = false;
      ram_cell_tech_type  = g_ip->data_arr_ram_cell_tech_type;
      is_dram             = ((ram_cell_tech_type == lp_dram) || (ram_cell_tech_type == comm_dram));
!     init_tech_params(g_ip->F_sz_um, is_tag);
  
      for (uint32_t t = 0; t < nthreads; t++)
      {
        calc_array[t].is_tag      = is_tag;
        calc_array[t].is_main_mem = g_ip->is_main_mem;
!       calc_array[t].Nspd_min    = (double)(g_ip->out_w)/(double)(g_ip->block_sz*8);
        pthread_create(&threads[t], NULL, calc_time_mt_wrapper, (void *)(&(calc_array[t])));
      }
  
--- 918,940 ----
      }
    }
  
    // calculate the area, delay and power for all data array partitions (for cache or plain RAM).
! //  if (!g_ip->fully_assoc)
! //  {
      is_tag              = false;
      ram_cell_tech_type  = g_ip->data_arr_ram_cell_tech_type;
      is_dram             = ((ram_cell_tech_type == lp_dram) || (ram_cell_tech_type == comm_dram));
! //    init_tech_params(g_ip->F_sz_um, is_tag);
!     init_tech_params(g_ip->F_sz_um, g_ip->wire_F_sz_um, false); //divya added wire technology
  
      for (uint32_t t = 0; t < nthreads; t++)
      {
        calc_array[t].is_tag      = is_tag;
        calc_array[t].is_main_mem = g_ip->is_main_mem;
!       if (!(pure_cam||g_ip->fully_assoc))
!     	  calc_array[t].Nspd_min    = (double)(g_ip->out_w)/(double)(g_ip->block_sz*8);
!       else
!     	  calc_array[t].Nspd_min    = 1;
        pthread_create(&threads[t], NULL, calc_time_mt_wrapper, (void *)(&(calc_array[t])));
      }
  
***************
*** 682,698 ****
        calc_array[t].data_arr.sort(mem_array::lt);
        data_arr.merge(calc_array[t].data_arr, mem_array::lt);
      }
!   }
! 
  
!   min_values_t * d_min = new min_values_t();
!   min_values_t * t_min = new min_values_t();
!   min_values_t * cache_min = new min_values_t();
  
    for (uint32_t t = 0; t < nthreads; t++) 
    {
!     d_min->update_min_values(calc_array[t].data_res);
!     t_min->update_min_values(calc_array[t].tag_res);
    }
  
    for (miter = data_arr.begin(); miter != data_arr.end(); miter++)
--- 949,964 ----
        calc_array[t].data_arr.sort(mem_array::lt);
        data_arr.merge(calc_array[t].data_arr, mem_array::lt);
      }
! //  }
  
!   min_values_t d_min =  min_values_t();
!   min_values_t t_min =  min_values_t();
!   min_values_t cache_min =  min_values_t();
  
    for (uint32_t t = 0; t < nthreads; t++) 
    {
!     d_min.update_min_values(calc_array[t].data_res);
!     t_min.update_min_values(calc_array[t].tag_res);
    }
  
    for (miter = data_arr.begin(); miter != data_arr.end(); miter++)
***************
*** 702,721 ****
  
    //cout << data_arr.size() << "\t" << tag_arr.size() <<" before\n";
    filter_data_arr(data_arr);
!   if(!pure_ram)
    {
      filter_tag_arr(t_min, tag_arr);
    }
    //cout << data_arr.size() << "\t" << tag_arr.size() <<" after\n";
  
  
!   if (pure_ram == true)
    {
      for (miter = data_arr.begin(); miter != data_arr.end(); miter++)
      {
        uca_org_t & curr_org  = sol_list.back();
!       curr_org.tag_array2  = NULL;
!       curr_org.data_array2 = (*miter);
  
        curr_org.find_delay();
        curr_org.find_energy();
--- 968,987 ----
  
    //cout << data_arr.size() << "\t" << tag_arr.size() <<" before\n";
    filter_data_arr(data_arr);
!   if(!(pure_ram||pure_cam||g_ip->fully_assoc))
    {
      filter_tag_arr(t_min, tag_arr);
    }
    //cout << data_arr.size() << "\t" << tag_arr.size() <<" after\n";
  
  
!   if (pure_ram||pure_cam||g_ip->fully_assoc)
    {
      for (miter = data_arr.begin(); miter != data_arr.end(); miter++)
      {
        uca_org_t & curr_org  = sol_list.back();
!      // curr_org.tag_array2  = NULL;
!       curr_org.data_array2 = *(*miter);
  
        curr_org.find_delay();
        curr_org.find_energy();
***************
*** 723,729 ****
        curr_org.find_cyc();
  
        //update min values for the entire cache
!       cache_min->update_min_values(curr_org);
  
        sol_list.push_back(uca_org_t());
      }
--- 989,995 ----
        curr_org.find_cyc();
  
        //update min values for the entire cache
!       cache_min.update_min_values(curr_org);
  
        sol_list.push_back(uca_org_t());
      }
***************
*** 739,746 ****
        for (miter = data_arr.begin(); miter != data_arr.end(); miter++)
        {
          uca_org_t & curr_org  = sol_list.back();
!         curr_org.tag_array2  = arr_temp;
!         curr_org.data_array2 = (*miter);
  
          curr_org.find_delay();
          curr_org.find_energy();
--- 1005,1012 ----
        for (miter = data_arr.begin(); miter != data_arr.end(); miter++)
        {
          uca_org_t & curr_org  = sol_list.back();
!         curr_org.tag_array2  = *arr_temp;
!         curr_org.data_array2 = *(*miter);
  
          curr_org.find_delay();
          curr_org.find_energy();
***************
*** 748,754 ****
          curr_org.find_cyc();
  
          //update min values for the entire cache
!         cache_min->update_min_values(curr_org);
  
          sol_list.push_back(uca_org_t());
        }
--- 1014,1020 ----
          curr_org.find_cyc();
  
          //update min values for the entire cache
!         cache_min.update_min_values(curr_org);
  
          sol_list.push_back(uca_org_t());
        }
***************
*** 760,766 ****
    find_optimal_uca(fin_res, cache_min, sol_list);
  
    sol_list.clear();
! 
    for (miter = data_arr.begin(); miter != data_arr.end(); ++miter)
    {
      if (*miter != fin_res->data_array2)
--- 1026,1032 ----
    find_optimal_uca(fin_res, cache_min, sol_list);
  
    sol_list.clear();
! /*
    for (miter = data_arr.begin(); miter != data_arr.end(); ++miter)
    {
      if (*miter != fin_res->data_array2)
***************
*** 768,773 ****
--- 1034,1040 ----
        delete *miter;
      }
    }
+ */
    data_arr.clear();
  
    for (uint32_t t = 0; t < nthreads; t++)
***************
*** 777,784 ****
    }
  
    delete [] calc_array;
!   delete cache_min;
!   delete d_min;
!   delete t_min;
  }
  
--- 1044,1116 ----
    }
  
    delete [] calc_array;
! //  delete cache_min;
! //  delete d_min;
! // delete t_min;
! }
! 
! void update_dvs(uca_org_t *fin_res)
! {
! //	double dvs_voltage = g_ip->dvs_start; //initial voltage
! //	double dvs_volt_step = 0.1; //Voltage should be raised in steps of 0.1V
! //	int num_dvs_voltages = (g_ip->dvs_end - g_ip->dvs_start)/dvs_volt_step + 1;
! 
! 	int pure_ram = (!g_ip->is_cache || g_ip->is_main_mem);
! //	if(fin_res->tag_array2 || fin_res->data_array2)
! 	if(1)
! 	{
! 		Wire winit;//init before changing dvs
! //		for (unsigned int i=0; i< num_dvs_voltages; i++) //For voltages from 0.2V-0.8V in steps of 0.1 . Total 7 voltages
! 		for (unsigned int i=0; i< g_ip->dvs_voltage.size(); i++)
! 		{
! 			fin_res->uca_q.push_back(new uca_org_t());
! 
! 			g_ip->vdd = g_ip->dvs_voltage[i];
! //			cout << "dvs : " << g_ip->dvs_voltage[i] << endl;
! 			init_tech_params(g_ip->F_sz_um, g_ip->wire_F_sz_um ,true);
! 			winit.wire_dvs_update();//Wire::wire_dvs_update();//Wire winit (1,1, false);
! 
! //			if(fin_res->tag_array2)
! 			if(1)
! 			{
! 				DynamicParameter tag_arr_dyn_p(true, g_ip->pure_ram, g_ip->pure_cam, fin_res->tag_array2.Nspd, fin_res->tag_array2.Ndwl, fin_res->tag_array2.Ndbl, fin_res->tag_array2.deg_bl_muxing, fin_res->tag_array2.Ndsam_lev_1, fin_res->tag_array2.Ndsam_lev_2, g_ip->is_main_mem);
! 				if(tag_arr_dyn_p.is_valid)
! 				{
! 					UCA * tag_arr = new UCA(tag_arr_dyn_p);
! 					//fin_res->uca_q[i]->tag_array2 = new mem_array();
! 
! 					collect_uca_results(fin_res->tag_array2.Nspd, fin_res->tag_array2.Ndwl, fin_res->tag_array2.Ndbl, fin_res->tag_array2.deg_bl_muxing, fin_res->tag_array2.Ndsam_lev_1, fin_res->tag_array2.Ndsam_lev_2, tag_arr, &fin_res->uca_q[i]->tag_array2, g_ip->is_main_mem);
! 					delete tag_arr;
! 				}
! 
! 			}
! 			DynamicParameter data_arr_dyn_p(false, g_ip->pure_ram, g_ip->pure_cam, fin_res->data_array2.Nspd, fin_res->data_array2.Ndwl, fin_res->data_array2.Ndbl, fin_res->data_array2.deg_bl_muxing, fin_res->data_array2.Ndsam_lev_1, fin_res->data_array2.Ndsam_lev_2, g_ip->is_main_mem);
! 			if(data_arr_dyn_p.is_valid)
! 			{
! 				UCA * data_arr = new UCA(data_arr_dyn_p);
! 				//fin_res->uca_q[i]->data_array2 = new mem_array();
! 				collect_uca_results(fin_res->data_array2.Nspd, fin_res->data_array2.Ndwl, fin_res->data_array2.Ndbl, fin_res->data_array2.deg_bl_muxing, fin_res->data_array2.Ndsam_lev_1, fin_res->data_array2.Ndsam_lev_2, data_arr, &fin_res->uca_q[i]->data_array2, g_ip->is_main_mem);
! 				delete data_arr;
! 			}
! 
! 			fin_res->uca_q[i]->find_delay();
! 			fin_res->uca_q[i]->find_energy();
! 			fin_res->uca_q[i]->find_area();
! 			fin_res->uca_q[i]->find_cyc();
! 
! //            output_UCA(fin_res->uca_q[i]);
! //            Wire::print_wire();
! 
! //			dvs_voltage = dvs_voltage + dvs_volt_step;
! 		}
! 		//reset input to original values in *.cfg file
! 
! 		init_tech_params(g_ip->F_sz_um, g_ip->wire_F_sz_um, true);
! 	}
! 	else
! 	{
! 		cout << "ERROR: Cannot retrieve array structure for tag and data array" << endl;
! 		exit(1);
! 	}
  }
  
diff -crB pcacti_xml/Ucache.h FN-CACTI/Ucache.h
*** pcacti_xml/Ucache.h	2014-07-03 09:48:30.000000000 +0200
--- FN-CACTI/Ucache.h	2023-04-05 13:29:26.999984000 +0200
***************
*** 46,71 ****
  #include "area.h"
  #include "router.h"
  #include "nuca.h"
! 
   
- class min_values_t
- {
-   public:
-     double min_delay;
-     double min_dyn;
-     double min_leakage;
-     double min_area;
-     double min_cyc;
-     
-     min_values_t() : min_delay(BIGNUM), min_dyn(BIGNUM), min_leakage(BIGNUM), min_area(BIGNUM), min_cyc(BIGNUM) { }
-     
-     void update_min_values(const min_values_t * val);
-     void update_min_values(const uca_org_t & res);
-     void update_min_values(const nuca_org_t * res);
-     void update_min_values(const mem_array * res);
- };
- 
- 
  
  struct solution
  {
--- 46,53 ----
  #include "area.h"
  #include "router.h"
  #include "nuca.h"
! #include "uca.h"
   
  
  struct solution
  {
***************
*** 80,90 ****
    powerDef total_power;
  };
  
- 
- 
  bool calculate_time(
      bool is_tag,
      int pure_ram,
      double Nspd,
      unsigned int Ndwl, 
      unsigned int Ndbl,
--- 62,71 ----
    powerDef total_power;
  };
  
  bool calculate_time(
      bool is_tag,
      int pure_ram,
+     bool pure_cam,
      double Nspd,
      unsigned int Ndwl, 
      unsigned int Ndbl,
***************
*** 97,105 ****
      uca_org_t *ptr_fin_res,
      bool is_main_mem);
  
  
  void solve(uca_org_t *fin_res);
! void init_tech_params(double tech, bool is_tag);
  
  
  struct calc_time_mt_wrapper_struct
--- 78,101 ----
      uca_org_t *ptr_fin_res,
      bool is_main_mem);
  
+ //Divya added 11-11-2020
+ void collect_uca_results(
+     double Nspd,
+     unsigned int Ndwl,
+     unsigned int Ndbl,
+     unsigned int Ndcm,
+     unsigned int Ndsam_lev_1,
+     unsigned int Ndsam_lev_2,
+     UCA const * const uca,
+     mem_array * const ptr_array,
+     bool is_main_mem);
+ 
+ void update_dvs(uca_org_t *fin_res);
+ //Divya end
  
  void solve(uca_org_t *fin_res);
! //void init_tech_params(double tech, bool is_tag);
! void init_tech_params(double tech, double wire_tech, bool is_tag); //divya added wire technology
  
  
  struct calc_time_mt_wrapper_struct
***************
*** 107,112 ****
--- 103,109 ----
    uint32_t tid;
    bool     is_tag;
    bool     pure_ram;
+   bool     pure_cam;
    bool     is_main_mem;
    double   Nspd_min;
  
diff -crB pcacti_xml/uca.h FN-CACTI/uca.h
*** pcacti_xml/uca.h	2014-07-03 09:48:06.000000000 +0200
--- FN-CACTI/uca.h	2023-04-05 13:29:35.367856000 +0200
***************
*** 63,68 ****
--- 63,70 ----
      Htree2   * htree_in_add;
      Htree2   * htree_in_data;
      Htree2   * htree_out_data;
+     Htree2   * htree_in_search;
+     Htree2   * htree_out_search;
  
      powerDef power_routing_to_bank;
  
***************
*** 71,77 ****
      int   num_addr_b_bank;
      int   num_di_b_bank;
      int   num_do_b_bank;
!     int   RWP, ERP, EWP;
      double area_all_dataramcells;
  
      double dyn_read_energy_from_closed_page;
--- 73,81 ----
      int   num_addr_b_bank;
      int   num_di_b_bank;
      int   num_do_b_bank;
!     int   num_si_b_bank;
!     int   num_so_b_bank;
!     int   RWP, ERP, EWP,SCHP;
      double area_all_dataramcells;
  
      double dyn_read_energy_from_closed_page;
diff -crB pcacti_xml/wire.cc FN-CACTI/wire.cc
*** pcacti_xml/wire.cc	2014-07-03 09:47:30.000000000 +0200
--- FN-CACTI/wire.cc	2023-04-05 13:30:04.555409000 +0200
***************
*** 58,63 ****
--- 58,70 ----
    min_w_pmos     = deviceType->n_to_p_eff_curr_drv_ratio*g_tp.min_w_nmos_;
    in_rise_time   = 0;
    out_rise_time  = 0;
+ 
+   //Divya added 11-11-2020. Reference McPAT for DVS support which maintains same repeaters spcae and size at varying voltages
+   if (initialized != 1) {
+     cout << "Wire not initialized. Initializing it with default values\n";
+     Wire winit;
+   }
+   //Divya end
    calculate_wire_stats();
    // change everything back to seconds, microns, and Joules
    repeater_spacing *= 1e6;
***************
*** 65,70 ****
--- 72,81 ----
    wire_width       *= 1e6;
    wire_spacing     *= 1e6;
  
+   if(wire_length < 0 || power.readOp.dynamic < 0 || power.readOp.leakage < 0)
+   cout << "wire1:: wire-length: " << wire_length << ", repeater_spacing: " << repeater_spacing << ", wire_width: "<< wire_width <<
+ 		  ", wire_spacing: " << wire_spacing << ", dyn: " << power.readOp.dynamic << ", leakage: " << power.readOp.leakage << endl;
+   assert(wire_length > 0);
    assert(power.readOp.dynamic > 0);
    assert(power.readOp.leakage > 0);
  }
***************
*** 83,88 ****
--- 94,105 ----
  double Wire::wire_width_init;
  double Wire::wire_spacing_init;
  
+ //Divya added 11-11-2020
+ int Wire::initialized;
+ double Wire::repeater_size_init; // value used in initialization should not be reused in final output
+ double Wire::repeater_spacing_init;
+ //Divya end
+ 
  Wire::Wire(double w_s, double s_s, enum Wire_placement wp, double resis, TechnologyParameter::DeviceType *dt)
  {
    w_scale        = w_s;
***************
*** 106,116 ****
--- 123,137 ----
    wire_width   *= (w_scale * 1e-6/2) /* (m) */;
    wire_spacing *= (s_scale * 1e-6/2) /* (m) */;
  
+   initialized = 1; //Divya added 11-11-2020
    init_wire();
  
    wire_width_init = wire_width;
    wire_spacing_init = wire_spacing;
  
+   if(power.readOp.dynamic < 0 || power.readOp.leakage < 0)
+   cout << "wire2:: wire-length: " << wire_length << ", repeater_spacing: " << repeater_spacing << ", wire_width: "<< wire_width <<
+ 		  ", wire_spacing: " << wire_spacing << ", dyn: " << power.readOp.dynamic << ", leakage: " << power.readOp.leakage << endl;
    assert(power.readOp.dynamic > 0);
    assert(power.readOp.leakage > 0);
  }
***************
*** 142,153 ****
    wire_width   *= (w_scale * 1e-6/2) /* (m) */;
    wire_spacing *= (s_scale * 1e-6/2) /* (m) */;
  
! 
    if (wt != Low_swing) { 
  
!     delay_optimal_wire();
! 
!     if (wt == Global_5) {
        delay = global_5.delay * wire_length;
        power.readOp.dynamic = global_5.power.readOp.dynamic * wire_length;
        power.readOp.leakage = global_5.power.readOp.leakage * wire_length;
--- 163,185 ----
    wire_width   *= (w_scale * 1e-6/2) /* (m) */;
    wire_spacing *= (s_scale * 1e-6/2) /* (m) */;
  
! //  cout << "calculate_wire_stats :: wt : " << wt << endl;
    if (wt != Low_swing) { 
  
! //    delay_optimal_wire(); //Divya removing after refering DVS support for McPAT 11-11-2020
! //Divya added 11-11-2020
! 	  if (wt == Global) {
! 		  delay = global.delay * wire_length;
! 		  power.readOp.dynamic = global.power.readOp.dynamic * wire_length;
! 		  power.readOp.leakage = global.power.readOp.leakage * wire_length;
! 		  repeater_spacing = global.area.w;
! 		  repeater_size = global.area.h;
! 		  area.set_area((wire_length/repeater_spacing) *
! 				  compute_gate_area(INV, 1, min_w_pmos * repeater_size,
! 						  g_tp.min_w_nmos_ * repeater_size, g_tp.cell_h_def));
! 	  }
! //Divya end
! 	  else if (wt == Global_5) {
        delay = global_5.delay * wire_length;
        power.readOp.dynamic = global_5.power.readOp.dynamic * wire_length;
        power.readOp.leakage = global_5.power.readOp.leakage * wire_length;
***************
*** 186,192 ****
        area.set_area((wire_length/repeater_spacing) *
            compute_gate_area(INV, 1, min_w_pmos * repeater_size,
                                            g_tp.min_w_nmos_ * repeater_size, g_tp.cell_h_def));
!     }
      out_rise_time = delay*repeater_spacing/deviceType->Vth;
    }    
    else if (wt == Low_swing) {
--- 218,227 ----
        area.set_area((wire_length/repeater_spacing) *
            compute_gate_area(INV, 1, min_w_pmos * repeater_size,
                                            g_tp.min_w_nmos_ * repeater_size, g_tp.cell_h_def));
! /*      cout << " global 30:: repeater size : " << repeater_size << ", repeater space(um) : " << repeater_spacing*1e6 << endl;
!       cout << "wrie delay << " << delay << endl;
!       cout << "g30 delay: " << global_30.delay << ", wl: " << wire_length << endl;
! */    }
      out_rise_time = delay*repeater_spacing/deviceType->Vth;
    }    
    else if (wt == Low_swing) {
***************
*** 282,297 ****
    //return (tot_cap * len); // (F)
  
    double Cw_per_um;
!   if (wire_placement == outside_mat) {
!     Cw_per_um = g_tp.wire_outside_mat.C_per_um;
!   } else if (wire_placement == inside_mat) {
!     Cw_per_um = g_tp.wire_inside_mat.C_per_um;
!   } else {
!     Cw_per_um = g_tp.wire_local.C_per_um;
!   }
    
!   return (Cw_per_um * len * 1e6); // (F)
    /****** Alireza2 - END ******/
  }
  
  
--- 317,390 ----
    //return (tot_cap * len); // (F)
  
    double Cw_per_um;
!   double sidewall, adj, tot_cap;
!    double wire_height;
!    double epsilon0 = 8.8542e-12;
!    double aspect_ratio, horiz_dielectric_constant, vert_dielectric_constant, miller_value,ild_thickness;
! 
!   if(g_ip->is_finfet) {
! 	  if (wire_placement == outside_mat) {
! 		Cw_per_um = g_tp.wire_outside_mat.C_per_um;
! 	  } else if (wire_placement == inside_mat) {
! 		Cw_per_um = g_tp.wire_inside_mat.C_per_um;
! 	  } else {
! 		Cw_per_um = g_tp.wire_local.C_per_um;
! 	  }
    
! 	  return (Cw_per_um * len * 1e6); // (F)
!   }
    /****** Alireza2 - END ******/
+   else {	//cmos
+ 	  switch (wire_placement)
+ 	  {
+ 	    case outside_mat:
+ 	    	{
+ 	    		aspect_ratio = g_tp.wire_outside_mat.aspect_ratio;
+ 	    		horiz_dielectric_constant = g_tp.wire_outside_mat.horiz_dielectric_constant;
+ 	    		vert_dielectric_constant = g_tp.wire_outside_mat.vert_dielectric_constant;
+ 	    		miller_value = g_tp.wire_outside_mat.miller_value;
+ 	    		ild_thickness = g_tp.wire_outside_mat.ild_thickness;
+ 	    		break;
+ 	    	}
+ 	    case inside_mat :
+ 	    	{
+ 	    		aspect_ratio = g_tp.wire_inside_mat.aspect_ratio;
+ 	    		horiz_dielectric_constant = g_tp.wire_inside_mat.horiz_dielectric_constant;
+ 	    		vert_dielectric_constant = g_tp.wire_inside_mat.vert_dielectric_constant;
+ 	    		miller_value = g_tp.wire_inside_mat.miller_value;
+ 	    		ild_thickness = g_tp.wire_inside_mat.ild_thickness;
+ 	    		break;
+ 	    	}
+ 	    default:
+ 	    	{
+ 	    		aspect_ratio = g_tp.wire_local.aspect_ratio;
+ 	    		horiz_dielectric_constant = g_tp.wire_local.horiz_dielectric_constant;
+ 	    		vert_dielectric_constant = g_tp.wire_local.vert_dielectric_constant;
+ 	    		miller_value = g_tp.wire_local.miller_value;
+ 	    		ild_thickness = g_tp.wire_local.ild_thickness;
+ 	    		break;
+ 	    	}
+ 	  }
+ 
+ //	  cout << "ar: " << aspect_ratio << ", hdc: " << horiz_dielectric_constant <<
+ //			  ", vdc: " << vert_dielectric_constant << ", mv: " << miller_value <<
+ //			  ", ild: " << ild_thickness << endl;
+ 
+ 	  wire_height = wire_width/w_scale*aspect_ratio;
+ 
+ //	  cout << "width: " << wire_width << ", wscale: " << w_scale <<
+ //			  ", ht: " <<wire_height << ", len: " << len << endl;
+ 
+ 	  sidewall = miller_value * horiz_dielectric_constant * (wire_height/wire_spacing)
+ 	    * epsilon0;
+ 
+ 	  adj = miller_value *vert_dielectric_constant *wire_width/(ild_thickness*1e-6) * epsilon0;
+ 	  //Change ild_thickness from micron to M
+ 
+ 	  tot_cap =  (sidewall + adj + (g_tp.fringe_cap * 1e6)); //F/m
+ //	  cout << "sidewll: " << sidewall << ", adj: " << adj << ", fringe: " << g_tp.fringe_cap << endl;
+ 	  return (tot_cap*len); // (F)
+   }
  }
  
  
***************
*** 303,318 ****
    //return (dish * resistivity * 1e-6 * len/(g_tp.aspect_ratio*(wire_width/w_scale)*wire_width));
    
    double Rw_per_um;
!   if (wire_placement == outside_mat) {
!     Rw_per_um = g_tp.wire_outside_mat.R_per_um;
!   } else if (wire_placement == inside_mat) {
!     Rw_per_um = g_tp.wire_inside_mat.R_per_um;
!   } else {
!     Rw_per_um = g_tp.wire_local.R_per_um;
    }
-   
-   return (Rw_per_um * len * 1e6);
    /****** Alireza2 - END ******/
  }
  
  /*
--- 396,439 ----
    //return (dish * resistivity * 1e-6 * len/(g_tp.aspect_ratio*(wire_width/w_scale)*wire_width));
    
    double Rw_per_um;
! 
!   if(g_ip->is_finfet) {
! 	  if (wire_placement == outside_mat) {
! 		Rw_per_um = g_tp.wire_outside_mat.R_per_um;
! 	  } else if (wire_placement == inside_mat) {
! 		Rw_per_um = g_tp.wire_inside_mat.R_per_um;
! 	  } else {
! 		Rw_per_um = g_tp.wire_local.R_per_um;
! 	  }
! 
! //	  cout << "wireplacement: " << wire_placement << ", Rw: " << Rw_per_um << endl;
! 	  return (Rw_per_um * len * 1e6);
    }
    /****** Alireza2 - END ******/
+   else {	//cmos
+ 	  double aspect_ratio,alpha_scatter =1.05, dishing_thickness=0, barrier_thickness=0;
+ 	  switch (wire_placement)
+ 	  {
+ 	  case outside_mat:
+ 	  {
+ 		  aspect_ratio = g_tp.wire_outside_mat.aspect_ratio;
+ 		  break;
+ 	  }
+ 	  case inside_mat :
+ 	  {
+ 		  aspect_ratio = g_tp.wire_inside_mat.aspect_ratio;
+ 		  break;
+ 	  }
+ 	  default:
+ 	  {
+ 		  aspect_ratio = g_tp.wire_local.aspect_ratio;
+ 		  break;
+ 	  }
+ 	  }
+ 	  return (alpha_scatter * resistivity * 1e-6 * len/((aspect_ratio*wire_width/w_scale-dishing_thickness - barrier_thickness)*
+ 			  (wire_width-2*barrier_thickness)));
+ 
+   }
  }
  
  /*
***************
*** 401,410 ****
  
    transmitter.delay = delay;
    transmitter.power.readOp.dynamic = temp_power*2; /* since it is a diff. model*/
!   transmitter.power.readOp.leakage = 0.5 * deviceType->Vdd *
!     (4 * cmos_Ileak(g_tp.min_w_nmos_, min_w_pmos, g_ip->temp) *
!      NAND2_LEAK_STACK_FACTOR +
!      4 * cmos_Ileak(g_tp.min_w_nmos_, g_tp.min_w_nmos_, g_ip->temp));
  
    inputrise = delay / deviceType->Vth;
  
--- 522,534 ----
  
    transmitter.delay = delay;
    transmitter.power.readOp.dynamic = temp_power*2; /* since it is a diff. model*/
! //  transmitter.power.readOp.leakage = 0.5 * deviceType->Vdd *
! //    (4 * cmos_Ileak(g_tp.min_w_nmos_, min_w_pmos, g_ip->temp) *
! //     NAND2_LEAK_STACK_FACTOR +
! //     4 * cmos_Ileak(g_tp.min_w_nmos_, g_tp.min_w_nmos_, g_ip->temp));
!   transmitter.power.readOp.leakage = deviceType->Vdd *
!     (4 * cmos_Isub_leakage(g_tp.min_w_nmos_, min_w_pmos, 2, nand) +
!      4 * cmos_Isub_leakage(g_tp.min_w_nmos_, min_w_pmos, 1, inv));
  
    inputrise = delay / deviceType->Vth;
  
***************
*** 435,442 ****
  
    l_wire.delay = delay - transmitter.delay;
    l_wire.power.readOp.dynamic = temp_power - transmitter.power.readOp.dynamic;
!   l_wire.power.readOp.leakage = 0.5 * deviceType->Vdd*
!     (4* simplified_nmos_leakage (nsize, g_ip->temp));
  
  
    //double rt = horowitz(inputrise, timeconst, deviceType->Vth/deviceType->Vdd,
--- 559,568 ----
  
    l_wire.delay = delay - transmitter.delay;
    l_wire.power.readOp.dynamic = temp_power - transmitter.power.readOp.dynamic;
! //  l_wire.power.readOp.leakage = 0.5 * deviceType->Vdd*
! //    (4* simplified_nmos_leakage (nsize, g_ip->temp));
!   l_wire.power.readOp.leakage = deviceType->Vdd*
!     (4* cmos_Isub_leakage(nsize, 0, 1, nmos));
  
  
    //double rt = horowitz(inputrise, timeconst, deviceType->Vth/deviceType->Vdd,
***************
*** 473,488 ****
    double switching = 0;  // switching energy
    double short_ckt = 0;  // short-circuit energy
    double tc        = 0;  // time constant
!   // input cap of min sized driver 
!   double input_cap = gate_C(g_tp.min_w_nmos_ + min_w_pmos, 0);
  
     // output parasitic capacitance of
     // the min. sized driver
    double out_cap = drain_C_(min_w_pmos, PCH, 1, 1, g_tp.cell_h_def) +
      drain_C_(g_tp.min_w_nmos_, NCH, 1, 1, g_tp.cell_h_def);
!   // drive resistance 
    double out_res = (tr_R_on(g_tp.min_w_nmos_, NCH, 1) +
        tr_R_on(min_w_pmos, PCH, 1))/2;
    double wr = wire_res(len); //ohm
  
    // wire cap /m 
--- 599,621 ----
    double switching = 0;  // switching energy
    double short_ckt = 0;  // short-circuit energy
    double tc        = 0;  // time constant
! 
!   double input_cap = gate_C(g_tp.min_w_nmos_ + min_w_pmos, 0); //original
  
     // output parasitic capacitance of
     // the min. sized driver
    double out_cap = drain_C_(min_w_pmos, PCH, 1, 1, g_tp.cell_h_def) +
      drain_C_(g_tp.min_w_nmos_, NCH, 1, 1, g_tp.cell_h_def);
! /*
!   cout << "min_pmos: " << min_w_pmos<< ", PCH: " << PCH << ", hdef: " << g_tp.cell_h_def <<
! 		  ", min_nmos: " << g_tp.min_w_nmos_ << ", NCH: " << NCH  << endl;
!   cout << "drain_C_(min_w_pmos, PCH, 1, 1, g_tp.cell_h_def): " << drain_C_(min_w_pmos, PCH, 1, 1, g_tp.cell_h_def) <<
! 		  ", drain_C_(g_tp.min_w_nmos_, NCH, 1, 1, g_tp.cell_h_def): " << drain_C_(g_tp.min_w_nmos_, NCH, 1, 1, g_tp.cell_h_def) << endl;
! */
! //Original
    double out_res = (tr_R_on(g_tp.min_w_nmos_, NCH, 1) +
        tr_R_on(min_w_pmos, PCH, 1))/2;
+ //  cout << "finfet: " << g_ip->is_finfet << ", ncfet: " << g_ip->is_ncfet << endl;
    double wr = wire_res(len); //ohm
  
    // wire cap /m 
***************
*** 491,524 ****
    // size the repeater such that the delay of the wire is minimum
    double repeater_scaling = sqrt(out_res*wc/(wr*input_cap)); // len will cancel
     
!    // calc the optimum spacing between the repeaters (m)
!    
!   repeater_spacing = sqrt(2 * out_res * (out_cap + input_cap)/
!       ((wr/len)*(wc/len)));
!   repeater_size = repeater_scaling;
! 
    switching = (repeater_scaling * (input_cap + out_cap) +
!       repeater_spacing * (wc/len)) * deviceType->Vdd * deviceType->Vdd;
! 
!   tc = out_res * (input_cap + out_cap) +
!     out_res * wc/len * repeater_spacing/repeater_scaling +
!     wr/len * repeater_spacing * input_cap * repeater_scaling +
!     0.5 * (wr/len) * (wc/len)* repeater_spacing * repeater_spacing;
! 
!   delay = 0.693 * tc * len/repeater_spacing;
  
! #define Ishort_ckt 65e-6 /* across all tech Ref:Banerjee et al. {IEEE TED} */
!   short_ckt = deviceType->Vdd * g_tp.min_w_nmos_ * Ishort_ckt * 1.0986 *
!     repeater_scaling * tc;
! 
!   area.set_area((len/repeater_spacing) *
!                 compute_gate_area(INV, 1, min_w_pmos * repeater_scaling,
!                                           g_tp.min_w_nmos_ * repeater_scaling, g_tp.cell_h_def));
!   power.readOp.dynamic = ((len/repeater_spacing)*(switching + short_ckt));
!   power.readOp.leakage = ((len/repeater_spacing)*
!       (1+beta)/2*deviceType->Vdd*
!       deviceType->I_off_n*
!       g_tp.min_w_nmos_*repeater_scaling);
  }
  
  
--- 624,668 ----
    // size the repeater such that the delay of the wire is minimum
    double repeater_scaling = sqrt(out_res*wc/(wr*input_cap)); // len will cancel
     
!   //Divya added 11-11-2020
!   repeater_spacing_init = sqrt(2 * out_res * (out_cap + input_cap)/
!   			  ((wr/len)*(wc/len)));
!   repeater_size_init = repeater_scaling;
! /*
!   cout << "delay_optimal_wire : wire_len : " << len << ", input_cap : " << input_cap <<", out_cap : " << out_cap << ", out_res : " << out_res <<
! 		  ", wr : " << wr << ", wc: " << wc << ", repeater_spacing : " << repeater_spacing << ", repeater_size : " << repeater_size << endl;
!   cout << " min_w_nmos_ : " << g_tp.min_w_nmos_ << ", min_w_pmos : " << min_w_pmos << ", cell_h_def : " << g_tp.cell_h_def << endl;
! */
    switching = (repeater_scaling * (input_cap + out_cap) +
!        repeater_spacing_init * (wc/len)) * deviceType->Vdd * deviceType->Vdd;
  
!    tc = out_res * (input_cap + out_cap) +
!      out_res * wc/len * repeater_spacing_init/repeater_scaling +
!      wr/len * repeater_spacing_init * input_cap * repeater_scaling +
!      0.5 * (wr/len) * (wc/len)* repeater_spacing_init * repeater_spacing_init;
! 
!    delay = 0.693 * tc * len/repeater_spacing_init;
!  //cout << "delay_optimal_wire delay : " << delay << endl;
!  #define Ishort_ckt 65e-6 // across all tech Ref:Banerjee et al. {IEEE TED}
!    short_ckt = deviceType->Vdd * g_tp.min_w_nmos_ * Ishort_ckt * 1.0986 *
!      repeater_scaling * tc;
! /*
!    cout << "len: " << len <<", repeater_spacing_init: " << repeater_spacing_init <<
! 		   ", min_w_pmos: " << min_w_pmos <<", repeater_scaling: " << repeater_scaling <<
! 		   ", min_w_nmos_: " << g_tp.min_w_nmos_ << ", cell_h_def: " << g_tp.cell_h_def << endl;
! */
!    area.set_area((len/repeater_spacing_init) *
!                  compute_gate_area(INV, 1, min_w_pmos * repeater_scaling,
!                                            g_tp.min_w_nmos_ * repeater_scaling, g_tp.cell_h_def));
!    power.readOp.dynamic = ((len/repeater_spacing_init)*(switching + short_ckt));
! /*   power.readOp.leakage = ((len/repeater_spacing_init)*
!        (1+beta)/2*deviceType->Vdd*
!        deviceType->I_off_n*
!        g_tp.min_w_nmos_*repeater_scaling);
! */
!    power.readOp.leakage = ((len/repeater_spacing_init )*
!  		  deviceType->Vdd*
!  		  cmos_Isub_leakage(g_tp.min_w_nmos_*repeater_scaling, beta*g_tp.min_w_nmos_*repeater_scaling, 1, inv));
  }
  
  
***************
*** 530,539 ****
--- 674,692 ----
    delay_optimal_wire();
      double sp, si;
    powerDef pow;
+ /*//Original
    si = repeater_size;
    sp = repeater_spacing;
+ */
+   //Divya added 11-11-2020
+   si = repeater_size_init ;
+   sp = repeater_spacing_init ;
+    //Divya end
    sp *= 1e6; // in microns
  
+ //  cout << "Initial :: Repeater size - "<< si <<
+ //     " Repeater spacing - " << sp << endl;
+ 
    double i, j, del;
    repeated_wire.push_back(Component());
    for (j=sp; j < 4*sp; j+=100) {
***************
*** 545,555 ****
          global.area.h = si;
          global.area.w = sp*1e-6; // m
        }
! //      cout << "Repeater size - "<< i <<
! //        " Repeater spacing - " << j <<
! //        " Delay - " << del << 
! //        " PowerD - " << pow.readOp.dynamic <<
! //        " PowerL - " << pow.readOp.leakage <<endl;
        repeated_wire.back().delay = del;
        repeated_wire.back().power.readOp = pow.readOp;
        repeated_wire.back().area.w = j*1e-6; //m
--- 698,709 ----
          global.area.h = si;
          global.area.w = sp*1e-6; // m
        }
! /*     cout << "Repeater size - "<< i <<
!         " Repeater spacing - " << j <<
!         " Delay - " << del <<
!         " PowerD - " << pow.readOp.dynamic <<
!         " PowerL - " << pow.readOp.leakage <<endl;
! */
        repeated_wire.back().delay = del;
        repeated_wire.back().power.readOp = pow.readOp;
        repeated_wire.back().area.w = j*1e-6; //m
***************
*** 599,604 ****
--- 753,761 ----
              global_30.delay = citer->delay;
              global_30.power = citer->power;
              global_30.area  = citer->area;
+ //            cout << "Final :: Repeater size - "<<  global_30.area.h <<
+ //               " Repeater spacing - " <<  global_30.area.w << endl;
+ 
            }
            else if (i==3) {
              global_20.delay = citer->delay;
***************
*** 620,625 ****
--- 777,787 ----
      }
      i--;
    }
+   //Divya added 11-11-2020
+   citer = repeated_wire.begin();
+     while (!repeated_wire.empty()) //TODO: code optimize
+         {citer=repeated_wire.erase(citer);}
+     //Divya end
  }
  
  
***************
*** 670,679 ****
      repeater_size * tc;
  
    ptemp.readOp.dynamic = ((len/repeater_spacing)*(switching + short_ckt));
!   ptemp.readOp.leakage = ((len/repeater_spacing)*
        (1+beta)/2*deviceType->Vdd*
        deviceType->I_off_n*
        g_tp.min_w_nmos_*repeater_size);
    return ptemp;
  }
  
--- 832,846 ----
      repeater_size * tc;
  
    ptemp.readOp.dynamic = ((len/repeater_spacing)*(switching + short_ckt));
! /*  ptemp.readOp.leakage = ((len/repeater_spacing)*
        (1+beta)/2*deviceType->Vdd*
        deviceType->I_off_n*
        g_tp.min_w_nmos_*repeater_size);
+ */
+   ptemp.readOp.leakage = ((len/repeater_spacing)*
+       deviceType->Vdd*
+       cmos_Isub_leakage(g_tp.min_w_nmos_*repeater_size, beta*g_tp.min_w_nmos_*repeater_size, 1, inv));
+ 
    return ptemp;
  }
  
***************
*** 682,736 ****
  {
  
    cout << "\nWire Properties:\n\n";
!   cout << "  Delay Optimal\n\tRepeater size - "<< global.area.h <<
!     " \n\tRepeater spacing - " << global.area.w*1e3 << " (mm)"
!     " \n\tDelay - " << global.delay*1e6 <<  " (ns/mm)" 
!     " \n\tPowerD - " << global.power.readOp.dynamic *1e6<< " (nJ/mm)"
!     " \n\tPowerL - " << global.power.readOp.leakage << " (mW/mm)\n";
!   cout << "\tWire width - " <<wire_width_init*1e6 << " microns\n";
!   cout << "\tWire spacing - " <<wire_spacing_init*1e6 << " microns\n";
    cout <<endl;
  
!   cout << "  5% Overhead\n\tRepeater size - "<< global_5.area.h <<
!     " \n\tRepeater spacing - " << global_5.area.w*1e3 << " (mm)"
!     " \n\tDelay - " << global_5.delay *1e6<<  " (ns/mm)" 
!     " \n\tPowerD - " << global_5.power.readOp.dynamic *1e6<< " (nJ/mm)"
!     " \n\tPowerL - " << global_5.power.readOp.leakage << " (mW/mm)\n"; 
!   cout << "\tWire width - " <<wire_width_init*1e6 << " microns\n";
!   cout << "\tWire spacing - " <<wire_spacing_init*1e6 << " microns\n";
    cout <<endl;
!   cout << "  10% Overhead\n\tRepeater size - "<< global_10.area.h <<
!     " \n\tRepeater spacing - " << global_10.area.w*1e3 << " (mm)"
!     " \n\tDelay - " << global_10.delay *1e6<<  " (ns/mm)" 
!     " \n\tPowerD - " << global_10.power.readOp.dynamic *1e6<< " (nJ/mm)"
!     " \n\tPowerL - " << global_10.power.readOp.leakage << " (mW/mm)\n"; 
!   cout << "\tWire width - " <<wire_width_init*1e6 << " microns\n";
!   cout << "\tWire spacing - " <<wire_spacing_init*1e6 << " microns\n";
    cout <<endl;
!   cout << "  20% Overhead\n\tRepeater size - "<< global_20.area.h <<
!     " \n\tRepeater spacing - " << global_20.area.w*1e3 << " (mm)"
!     " \n\tDelay - " << global_20.delay *1e6<<  " (ns/mm)" 
!     " \n\tPowerD - " << global_20.power.readOp.dynamic *1e6<< " (nJ/mm)"
!     " \n\tPowerL - " << global_20.power.readOp.leakage << " (mW/mm)\n"; 
!   cout << "\tWire width - " <<wire_width_init*1e6 << " microns\n";
!   cout << "\tWire spacing - " <<wire_spacing_init*1e6 << " microns\n";
    cout <<endl;
!   cout << "  30% Overhead\n\tRepeater size - "<< global_30.area.h <<
!     " \n\tRepeater spacing - " << global_30.area.w*1e3 << " (mm)"
!     " \n\tDelay - " << global_30.delay *1e6<<  " (ns/mm)" 
!     " \n\tPowerD - " << global_30.power.readOp.dynamic *1e6<< " (nJ/mm)"
!     " \n\tPowerL - " << global_30.power.readOp.leakage << " (mW/mm)\n"; 
!   cout << "\tWire width - " <<wire_width_init*1e6 << " microns\n";
!   cout << "\tWire spacing - " <<wire_spacing_init*1e6 << " microns\n";
    cout <<endl;
    cout << "  Low-swing wire (1 mm) - Note: Unlike repeated wires, \n\tdelay and power "
            "values of low-swing wires do not\n\thave a linear relationship with length." <<
!     " \n\tdelay - " << low_swing.delay *1e9<<  " (ns)" 
!     " \n\tpowerD - " << low_swing.power.readOp.dynamic *1e9<< " (nJ)"
!     " \n\tPowerL - " << low_swing.power.readOp.leakage << " (mW)\n"; 
!   cout << "\tWire width - " <<wire_width_init * 2 /* differential */<< " microns\n";
!   cout << "\tWire spacing - " <<wire_spacing_init * 2 /* differential */<< " microns\n";
    cout <<endl;
    cout <<endl;
  }
  
--- 849,931 ----
  {
  
    cout << "\nWire Properties:\n\n";
!   cout << "  Delay Optimal\n\tRepeater size : "<< global.area.h <<
!     " \n\tRepeater spacing : " << global.area.w*1e3 << " (mm)"
!     " \n\tDelay : " << global.delay*1e6 <<  " (ns/mm)"
!     " \n\tPowerD : " << global.power.readOp.dynamic *1e6<< " (nJ/mm)"
!     " \n\tPowerL : " << global.power.readOp.leakage << " (mW/mm)\n";
!   cout << "\tWire width : " <<wire_width_init*1e6 << " microns\n";
!   cout << "\tWire spacing : " <<wire_spacing_init*1e6 << " microns\n";
    cout <<endl;
  
!   cout << "  5% Overhead\n\tRepeater size : "<< global_5.area.h <<
!     " \n\tRepeater spacing : " << global_5.area.w*1e3 << " (mm)"
!     " \n\tDelay : " << global_5.delay *1e6<<  " (ns/mm)"
!     " \n\tPowerD : " << global_5.power.readOp.dynamic *1e6<< " (nJ/mm)"
!     " \n\tPowerL : " << global_5.power.readOp.leakage << " (mW/mm)\n";
!   cout << "\tWire width : " <<wire_width_init*1e6 << " microns\n";
!   cout << "\tWire spacing : " <<wire_spacing_init*1e6 << " microns\n";
    cout <<endl;
!   cout << "  10% Overhead\n\tRepeater size : "<< global_10.area.h <<
!     " \n\tRepeater spacing : " << global_10.area.w*1e3 << " (mm)"
!     " \n\tDelay : " << global_10.delay *1e6<<  " (ns/mm)"
!     " \n\tPowerD : " << global_10.power.readOp.dynamic *1e6<< " (nJ/mm)"
!     " \n\tPowerL : " << global_10.power.readOp.leakage << " (mW/mm)\n";
!   cout << "\tWire width : " <<wire_width_init*1e6 << " microns\n";
!   cout << "\tWire spacing : " <<wire_spacing_init*1e6 << " microns\n";
    cout <<endl;
!   cout << "  20% Overhead\n\tRepeater size : "<< global_20.area.h <<
!     " \n\tRepeater spacing : " << global_20.area.w*1e3 << " (mm)"
!     " \n\tDelay : " << global_20.delay *1e6<<  " (ns/mm)"
!     " \n\tPowerD : " << global_20.power.readOp.dynamic *1e6<< " (nJ/mm)"
!     " \n\tPowerL : " << global_20.power.readOp.leakage << " (mW/mm)\n";
!   cout << "\tWire width : " <<wire_width_init*1e6 << " microns\n";
!   cout << "\tWire spacing : " <<wire_spacing_init*1e6 << " microns\n";
    cout <<endl;
!   cout << "  30% Overhead\n\tRepeater size : "<< global_30.area.h <<
!     " \n\tRepeater spacing : " << global_30.area.w*1e3 << " (mm)"
!     " \n\tDelay : " << global_30.delay *1e6<<  " (ns/mm)"
!     " \n\tPowerD : " << global_30.power.readOp.dynamic *1e6<< " (nJ/mm)"
!     " \n\tPowerL : " << global_30.power.readOp.leakage << " (mW/mm)\n";
!   cout << "\tWire width : " <<wire_width_init*1e6 << " microns\n";
!   cout << "\tWire spacing : " <<wire_spacing_init*1e6 << " microns\n";
    cout <<endl;
    cout << "  Low-swing wire (1 mm) - Note: Unlike repeated wires, \n\tdelay and power "
            "values of low-swing wires do not\n\thave a linear relationship with length." <<
!     " \n\tdelay : " << low_swing.delay *1e9<<  " (ns)"
!     " \n\tpowerD : " << low_swing.power.readOp.dynamic *1e9<< " (nJ)"
!     " \n\tPowerL : " << low_swing.power.readOp.leakage << " (mW)\n";
!   cout << "\tWire width : " <<wire_width_init * 2 /* differential */<< " microns\n";
!   cout << "\tWire spacing : " <<wire_spacing_init * 2 /* differential */<< " microns\n";
    cout <<endl;
    cout <<endl;
  }
  
+ void
+ Wire::wire_dvs_update()
+ {
+ 
+ 	double i, j, del;
+ 	powerDef pow;
+ 	pow = wire_model(global.area.w, global.area.h, &del);
+ 	global.delay = del;
+ 	global.power = pow;
+ 	pow = wire_model(global_5.area.w, global_5.area.h, &del);
+ 	global_5.delay = del;
+ 	global_5.power = pow;
+ 	pow = wire_model(global_10.area.w, global_10.area.h, &del);
+ 	global_10.delay = del;
+ 	global_10.power = pow;
+ 	pow = wire_model(global_20.area.w, global_20.area.h, &del);
+ 	global_20.delay = del;
+ 	global_20.power = pow;
+ 	pow = wire_model(global_30.area.w, global_30.area.h, &del);
+ 	global_30.delay = del;
+ 	global_30.power = pow;
+ 
+ 	Wire *l_wire = new Wire(Low_swing, 0.001/* 1 mm*/, 1);
+ 	low_swing.delay = l_wire->delay;
+ 	low_swing.power = l_wire->power;
+ 	delete l_wire;
+ 
+ }
diff -crB pcacti_xml/wire.h FN-CACTI/wire.h
*** pcacti_xml/wire.h	2014-07-03 09:50:26.000000000 +0200
--- FN-CACTI/wire.h	2023-04-05 13:37:59.292139000 +0200
***************
*** 85,90 ****
--- 85,94 ----
      enum Wire_placement wire_placement;
      double repeater_size;
      double repeater_spacing;
+ //Divya added 11-11-2020
+     static double repeater_size_init; // value used in initialization should not be reused in final output
+      static double repeater_spacing_init;
+ //Divya end
      double wire_length;
      double in_rise_time, out_rise_time;
  
***************
*** 101,106 ****
--- 105,111 ----
      static double wire_width_init;
      static double wire_spacing_init;
      void print_wire();
+     void wire_dvs_update(); //Divya added 11-11-2020
  
    private:
  
***************
*** 115,120 ****
--- 120,126 ----
      list <Component> repeated_wire;
      void update_fullswing();
  
+     static int initialized; //Divya added 11-11-2020
  
      //low-swing
      Component transmitter;
Only in pcacti_xml: xmlParser.cc
Only in pcacti_xml: xmlParser.h
Only in pcacti_xml: xmls
