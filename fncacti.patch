diff -crB pcacti_xml/basic_circuit.cc fncacti/basic_circuit.cc
*** pcacti_xml/basic_circuit.cc	2014-07-03 13:17:22.000000000 +0530
--- fncacti/basic_circuit.cc	2021-08-27 16:37:16.097041761 +0530
***************
*** 132,143 ****
  
    /***** Alireza - BEGIN *****/
    double Cg;
!   if ( g_ip->is_finfet ) {
!     double W_min = 2 * dt->H_fin;
      int N_fin = (int) (ceil(width / W_min));
!     Cg = (dt->C_g_ideal + dt->C_overlap + 3*dt->C_fringe)*W_min*N_fin + dt->l_phy*Cpolywire;
    } else {
!     Cg = (dt->C_g_ideal + dt->C_overlap + 3*dt->C_fringe)*width + dt->l_phy*Cpolywire;
    }
    return Cg;
    /****** Alireza - END ******/
--- 132,145 ----
  
    /***** Alireza - BEGIN *****/
    double Cg;
! 
!   if ( g_ip->is_finfet) {
!     double W_min = 2 * dt->H_fin + dt->W_fin; //2 * dt->H_fin;(original) //Divya changed
      int N_fin = (int) (ceil(width / W_min));
! //    Cg = (dt->C_g_ideal + dt->C_overlap + 3*dt->C_fringe)*W_min*N_fin + dt->l_phy*Cpolywire;
!     Cg = (dt->C_g_ideal)*W_min*N_fin; //Divya changed
    } else {
!   Cg = (dt->C_g_ideal + dt->C_overlap + 3*dt->C_fringe)*width + dt->l_phy*Cpolywire;
    }
    return Cg;
    /****** Alireza - END ******/
***************
*** 176,186 ****
    /***** Alireza - BEGIN *****/
    double Cg;
    if ( g_ip->is_finfet ) {
!     double W_min = 2 * dt->H_fin;
      int N_fin = (int) (ceil(width / W_min));
!     Cg = (dt->C_g_ideal + dt->C_overlap + 3*dt->C_fringe)*W_min*N_fin + dt->l_phy*Cpolywire;
    } else {
!     Cg = (dt->C_g_ideal + dt->C_overlap + 3*dt->C_fringe)*width + dt->l_phy*Cpolywire;
    }
    return Cg;
    /****** Alireza - END ******/
--- 178,188 ----
    /***** Alireza - BEGIN *****/
    double Cg;
    if ( g_ip->is_finfet ) {
!     double W_min = 2 * dt->H_fin + dt->W_fin; //2 * dt->H_fin;(original) //Divya changed
      int N_fin = (int) (ceil(width / W_min));
!     Cg = (dt->C_g_ideal)*W_min*N_fin; //Divya changed
    } else {
!   Cg = (dt->C_g_ideal + dt->C_overlap + 3*dt->C_fringe)*width + dt->l_phy*Cpolywire;
    }
    return Cg;
    /****** Alireza - END ******/
***************
*** 248,256 ****
    int N_fin = 1;
    int N_fin_in_each_fold = 1;
    int num_folded_tr;
!   if ( g_ip->is_finfet ) {
!     double W_min = 2 * dt->H_fin;
      N_fin = (int) (ceil(width / W_min));
      int N_fin_max = (int) (floor(w_folded_tr / dt->P_fin)); // + 1;
  	 if ( N_fin_max == 0 ) { cout << "ERROR: divide by zero in drain_C_ function!\n"; exit(0); }
  	 num_folded_tr = (int) (ceil((double)N_fin / N_fin_max));
--- 250,259 ----
    int N_fin = 1;
    int N_fin_in_each_fold = 1;
    int num_folded_tr;
!    if ( g_ip->is_finfet ) {
!     double W_min = 2 * dt->H_fin + dt->W_fin; //2 * dt->H_fin;(original) //Divya changed
      N_fin = (int) (ceil(width / W_min));
+ 
      int N_fin_max = (int) (floor(w_folded_tr / dt->P_fin)); // + 1;
  	 if ( N_fin_max == 0 ) { cout << "ERROR: divide by zero in drain_C_ function!\n"; exit(0); }
  	 num_folded_tr = (int) (ceil((double)N_fin / N_fin_max));
***************
*** 256,262 ****
  	 num_folded_tr = (int) (ceil((double)N_fin / N_fin_max));
  	 N_fin_in_each_fold = (int) (ceil((double)N_fin / num_folded_tr));
    } else {
!     num_folded_tr = (int) (ceil(width / w_folded_tr));
      ///if (num_folded_tr < 2) { w_folded_tr = width; } // originally in cacti
      w_folded_tr = width / (double)num_folded_tr;
    }
--- 259,265 ----
  	 num_folded_tr = (int) (ceil((double)N_fin / N_fin_max));
  	 N_fin_in_each_fold = (int) (ceil((double)N_fin / num_folded_tr));
    } else {
!   num_folded_tr = (int) (ceil(width / w_folded_tr));
      ///if (num_folded_tr < 2) { w_folded_tr = width; } // originally in cacti
      w_folded_tr = width / (double)num_folded_tr;
    }
***************
*** 268,277 ****
  								 
    /***** Alireza - BEGIN *****/
    double drain_h_for_sidewall;
!   if ( g_ip->is_finfet ) {
      drain_h_for_sidewall = dt->T_si;
    } else {
!     drain_h_for_sidewall = w_folded_tr;
    }
    /****** Alireza - END ******/
    
--- 271,280 ----
  								 
    /***** Alireza - BEGIN *****/
    double drain_h_for_sidewall;
!    if ( g_ip->is_finfet ) {
      drain_h_for_sidewall = dt->T_si;
    } else {
!   drain_h_for_sidewall = w_folded_tr;
    }
    /****** Alireza - END ******/
    
***************
*** 294,307 ****
    double drain_C_area;
    double drain_C_sidewall;
    double drain_C_wrt_gate;
!   if ( g_ip->is_finfet ) {
      drain_C_area     = c_junc_area * total_drain_w * dt->T_si * N_fin_in_each_fold;
      drain_C_sidewall = c_junc_sidewall * (drain_h_for_sidewall + 2 * total_drain_w) * N_fin_in_each_fold;
      drain_C_wrt_gate = 0;//(c_fringe + c_overlap) * N_fin * 2 * dt->H_fin; // According to BSIM-CMG, this capacitance is zero for FinFETs.
    } else {
      drain_C_area     = c_junc_area * total_drain_w * w_folded_tr;
      drain_C_sidewall = c_junc_sidewall * (drain_h_for_sidewall + 2 * total_drain_w);
!     drain_C_wrt_gate = (c_fringe + c_overlap) * total_drain_height_for_cap_wrt_gate;
    }
    /****** Alireza - END ******/
    
--- 297,311 ----
    double drain_C_area;
    double drain_C_sidewall;
    double drain_C_wrt_gate;
!    if ( g_ip->is_finfet ) {
      drain_C_area     = c_junc_area * total_drain_w * dt->T_si * N_fin_in_each_fold;
      drain_C_sidewall = c_junc_sidewall * (drain_h_for_sidewall + 2 * total_drain_w) * N_fin_in_each_fold;
      drain_C_wrt_gate = 0;//(c_fringe + c_overlap) * N_fin * 2 * dt->H_fin; // According to BSIM-CMG, this capacitance is zero for FinFETs.
    } else {
      drain_C_area     = c_junc_area * total_drain_w * w_folded_tr;
      drain_C_sidewall = c_junc_sidewall * (drain_h_for_sidewall + 2 * total_drain_w);
!     //// According to BSIM-CMG, drain_C_wrt_gate capacitance is zero for FinFETs..
!     drain_C_wrt_gate = 0; //(c_fringe + c_overlap) * total_drain_height_for_cap_wrt_gate;
    }
    /****** Alireza - END ******/
    
***************
*** 339,351 ****
    double restrans = (nchannel) ? dt->R_nch_on : dt->R_pch_on;
    
    /***** Alireza - BEGIN *****/
!   if ( g_ip->is_finfet ) {
      // Alireza: "width = ceil(width/w_min) * w_min" for finfets in order to capture oversized width
!     double W_min = 2 * dt->H_fin;
      double width_eff = ceil(width / W_min) * W_min; // effective width = Nfin * Wmin
      return (stack * restrans / width_eff);
    } else {
!     return (stack * restrans / width);
    }
    /****** Alireza - END ******/
  }
--- 343,355 ----
    double restrans = (nchannel) ? dt->R_nch_on : dt->R_pch_on;
    
    /***** Alireza - BEGIN *****/
!     if ( g_ip->is_finfet ) {
      // Alireza: "width = ceil(width/w_min) * w_min" for finfets in order to capture oversized width
!     double W_min = 2 * dt->H_fin + dt->W_fin; //2 * dt->H_fin;(original) //Divya changed
      double width_eff = ceil(width / W_min) * W_min; // effective width = Nfin * Wmin
      return (stack * restrans / width_eff);
    } else {
!   return (stack * restrans / width);
    }
    /****** Alireza - END ******/
  }
***************
*** 459,470 ****
    if ( g_ip->is_finfet ) {
      // Alireza: "nwidth = ceil(nwidth/w_min) * w_min" for finfets in order to capture oversized width
      // Alireza: "pwidth = ceil(pwidth/w_min) * w_min" for finfets in order to capture oversized width
!     double W_min = 2 * dt->H_fin;
      double nWidth_eff = ceil(nWidth / W_min) * W_min; // effective nwidth = Nfin * Wmin
      double pWidth_eff = ceil(pWidth / W_min) * W_min; // effective pwidth = Nfin * Wmin
      return nWidth_eff*dt->I_off_n + pWidth_eff*dt->I_off_p;
    } else {
!     return nWidth*dt->I_off_n + pWidth*dt->I_off_p;
    }
    /****** Alireza - END ******/
  }
--- 463,474 ----
    if ( g_ip->is_finfet ) {
      // Alireza: "nwidth = ceil(nwidth/w_min) * w_min" for finfets in order to capture oversized width
      // Alireza: "pwidth = ceil(pwidth/w_min) * w_min" for finfets in order to capture oversized width
!     double W_min = 2 * dt->H_fin + dt->W_fin; //2 * dt->H_fin;(original) //Divya changed
      double nWidth_eff = ceil(nWidth / W_min) * W_min; // effective nwidth = Nfin * Wmin
      double pWidth_eff = ceil(pWidth / W_min) * W_min; // effective pwidth = Nfin * Wmin
      return nWidth_eff*dt->I_off_n + pWidth_eff*dt->I_off_p;
    } else {
!    return nWidth*dt->I_off_n + pWidth*dt->I_off_p;
    }
    /****** Alireza - END ******/
  }
***************
*** 492,504 ****
    }
    
    /***** Alireza - BEGIN *****/
    if ( g_ip->is_finfet ) {
      // Alireza: "nwidth = ceil(nwidth/w_min) * w_min" for finfets in order to capture oversized width
!     double W_min = 2 * dt->H_fin;
!     double nwidth_eff = ceil(nwidth / W_min) * W_min; // effective nwidth = Nfin * Wmin
      return nwidth_eff * dt->I_off_n;
    } else {
!     return nwidth * dt->I_off_n;
    }
    /****** Alireza - END ******/
  }
--- 496,510 ----
    }
    
    /***** Alireza - BEGIN *****/
+   // Divya Changing begin
+   // As W_fin != 2*H_fin and calculation of N_fin also not valid for given data.  We have width given, no need to derive from H_fin.
    if ( g_ip->is_finfet ) {
      // Alireza: "nwidth = ceil(nwidth/w_min) * w_min" for finfets in order to capture oversized width
!     double W_min = 2 * dt->H_fin + dt->W_fin; //2 * dt->H_fin;(original) //Divya chnaged
!     double nwidth_eff = ceil(nwidth/W_min) * W_min; // effective nwidth = Nfin * Wmin
      return nwidth_eff * dt->I_off_n;
    } else {
!   return nwidth * dt->I_off_n;
    }
    /****** Alireza - END ******/
  }
***************
*** 528,538 ****
    /***** Alireza - BEGIN *****/
    if ( g_ip->is_finfet ) {
    // Alireza: "pwidth = ceil(pwidth/w_min) * w_min" for finfets in order to capture oversized width
!     double W_min = 2 * dt->H_fin;
      double pwidth_eff = ceil(pwidth / W_min) * W_min; // effective pwidth = Nfin * Wmin
      return pwidth_eff * dt->I_off_p;
    } else {
!     return pwidth * dt->I_off_p;
    }
    /****** Alireza - END ******/
  }
--- 534,544 ----
    /***** Alireza - BEGIN *****/
    if ( g_ip->is_finfet ) {
    // Alireza: "pwidth = ceil(pwidth/w_min) * w_min" for finfets in order to capture oversized width
!     double W_min = 2 * dt->H_fin + dt->W_fin; //2 * dt->H_fin;(original) //Divya changed
      double pwidth_eff = ceil(pwidth / W_min) * W_min; // effective pwidth = Nfin * Wmin
      return pwidth_eff * dt->I_off_p;
    } else {
!   return pwidth * dt->I_off_p;
    }
    /****** Alireza - END ******/
  }
diff -crB pcacti_xml/cacti_interface.cc fncacti/cacti_interface.cc
*** pcacti_xml/cacti_interface.cc	2014-07-03 13:17:54.000000000 +0530
--- fncacti/cacti_interface.cc	2021-08-27 17:10:59.883493331 +0530
***************
*** 77,82 ****
--- 77,83 ----
    pdn.Ioff = Ioffs[2];
    iso.Ioff = Ioffs[3];
    rac.Ioff = Ioffs[4];
+  // cout << "accoff  : " << acc.Ioff << ", pupOff : " << pup.Ioff << ", pdnoff : " << pdn.Ioff << endl;
  }
  
  void SRAMCellParameters::getNfins(int (&n)[5]) {
***************
*** 147,171 ****
    return width;
  }
  
! double SRAMCellParameters::getPleakAccTx(double vdd, double hfin) {
    if ( PleakAT_given ) {
      return Pleak_acctx;
    } else {
      if (g_ip->is_finfet) {
!       return ((acc.Nfin*acc.Ioff) * 2 * hfin * vdd);
!     } else {
        double Iport = cmos_Ileak(g_tp.sram.cell_a_w, 0,  false, true); 
        return (Iport * vdd);
      }
    }
  }
  
! double SRAMCellParameters::getPleakCCInv(double vdd, double hfin) {
    if ( PleakCC_given ) {
      return Pleak_ccinv;
    } else {
      if (g_ip->is_finfet) {
!       return (((pup.Nfin*pup.Ioff)+(pdn.Nfin*pdn.Ioff)) * 2 * hfin * vdd);
      } else {
        double Icell = cmos_Ileak(g_tp.sram.cell_nmos_w, g_tp.sram.cell_pmos_w, false, true);
        return (Icell * vdd);
--- 148,176 ----
    return width;
  }
  
! // double SRAMCellParameters::getPleakAccTx(double vdd, double hfin)
! double SRAMCellParameters::getPleakAccTx(double vdd, double hfin, double wfin) {
    if ( PleakAT_given ) {
      return Pleak_acctx;
    } else {
      if (g_ip->is_finfet) {
!  //     return ((acc.Nfin*acc.Ioff) * 2 * hfin * vdd);
!  		return ((acc.Nfin*acc.Ioff) * (2 * hfin + wfin) * vdd);
!      } else {
        double Iport = cmos_Ileak(g_tp.sram.cell_a_w, 0,  false, true); 
        return (Iport * vdd);
      }
    }
  }
  
! // double SRAMCellParameters::getPleakCCInv(double vdd, double hfin)
! double SRAMCellParameters::getPleakCCInv(double vdd, double hfin, double wfin) {
    if ( PleakCC_given ) {
      return Pleak_ccinv;
    } else {
      if (g_ip->is_finfet) {
!  //     return (((pup.Nfin*pup.Ioff)+(pdn.Nfin*pdn.Ioff)) * 2 * hfin * vdd);
!  		return (((pup.Nfin*pup.Ioff)+(pdn.Nfin*pdn.Ioff)) * (2 * hfin + wfin) * vdd);
      } else {
        double Icell = cmos_Ileak(g_tp.sram.cell_nmos_w, g_tp.sram.cell_pmos_w, false, true);
        return (Icell * vdd);
***************
*** 283,286 ****
--- 288,329 ----
    }
  }
  
+ //Divya added
+ uca_org_t :: uca_org_t()
+ :tag_array2(0),
+  data_array2(0)
+ {
+ 	uca_q = vector<uca_org_t * >(0);
+ }
+ 
+ void uca_org_t :: cleanup()
+ {
+ 	//	uca_org_t * it_uca_org;
+ 	if (data_array2!=0){
+ 		delete data_array2;
+ 		data_array2 =0;
+ 	}
+ 
+ 	if (tag_array2!=0){
+ 		delete tag_array2;
+ 		tag_array2 =0;
+ 	}
  
+ 	std::vector<uca_org_t * >::size_type sz = uca_q.size();
+ 	for (int i=sz-1; i>=0; i--)
+ 	{
+ 		if (uca_q[i]->data_array2!=0)
+ 		{
+ 			delete uca_q[i]->data_array2;
+ 			uca_q[i]->data_array2 =0;
+ 		}
+ 		if (uca_q[i]->tag_array2!=0){
+ 			delete uca_q[i]->tag_array2;
+ 			uca_q[i]->tag_array2 =0;
+ 		}
+ 		delete uca_q[i];
+ 		uca_q[i] =0;
+ 		uca_q.pop_back();
+ 	}
+ }
+ //Divya end
diff -crB pcacti_xml/cacti_interface.h fncacti/cacti_interface.h
*** pcacti_xml/cacti_interface.h	2014-07-03 13:20:22.000000000 +0530
--- fncacti/cacti_interface.h	2021-08-27 16:40:30.472996664 +0530
***************
*** 143,151 ****
      void setDGcontrol(bool b) { dg_control = b; }
      bool getDGcontrol() { return dg_control; }
      void setPleakAccTx(double d) { Pleak_acctx = d; PleakAT_given = true; }
!     double getPleakAccTx(double vdd, double hfin);
      void setPleakCCInv(double d) { Pleak_ccinv = d; PleakCC_given = true; }
!     double getPleakCCInv(double vdd, double hfin);
  	 void setTransistorParams(int Nfins[5], double gate_lengths[5], double I_offs[5]);
      void getNfins(int (&n)[5]);
      double calc_height(double lambda_um);
--- 143,155 ----
      void setDGcontrol(bool b) { dg_control = b; }
      bool getDGcontrol() { return dg_control; }
      void setPleakAccTx(double d) { Pleak_acctx = d; PleakAT_given = true; }
!     
!  //   double getPleakAccTx(double vdd, double hfin);
!  	double getPleakAccTx(double vdd, double hfin, double wfin);
      void setPleakCCInv(double d) { Pleak_ccinv = d; PleakCC_given = true; }
!  //   double getPleakCCInv(double vdd, double hfin);
! 	 double getPleakCCInv(double vdd, double hfin, double wfin);
! 	 
  	 void setTransistorParams(int Nfins[5], double gate_lengths[5], double I_offs[5]);
      void getNfins(int (&n)[5]);
      double calc_height(double lambda_um);
***************
*** 162,170 ****
      bool error_checking();  // return false if the input parameters are problematic
      void display_ip();
  
!     bool is_finfet;  // Alireza: False -> CMOS transistors, True -> FinFET transistors.
!     bool is_near_threshold;  // Alireza: False -> Super-threshold Vdd, True -> Near-threshold Vdd.
      bool is_itrs2012;  // Alireza2: source data for interconnects: False -> Ron Ho's PhD Thesis 2003, True -> ITRS 2012 Data
      SRAMCellParameters sram_cell_design; // Alireza2
  
      unsigned int cache_sz;  // in bytes
--- 166,181 ----
      bool error_checking();  // return false if the input parameters are problematic
      void display_ip();
  
!     bool is_finfet;  // Alireza: False -> CMOS transistors, True -> FinFET & NCFET transistors.
!     double vdd;	//Divya added
      bool is_itrs2012;  // Alireza2: source data for interconnects: False -> Ron Ho's PhD Thesis 2003, True -> ITRS 2012 Data
+     bool is_asap7; //Divya added data for interconnects from ASAP7 PDK
+     bool is_dvs; //Divya added
+ 
+     int Nfins[5]; //Divya added
+    	double Lphys[5]; //Divya added
+ 
+     double dvs_start, dvs_end; //Divya added
      SRAMCellParameters sram_cell_design; // Alireza2
  
      unsigned int cache_sz;  // in bytes
***************
*** 181,187 ****
--- 192,200 ----
      unsigned int obj_func_cycle_t;
      
      double   F_sz_nm;          // feature size in nm
+     double	 wire_F_sz_nm;		// wire feature size in nm //Divya added
      double   F_sz_um;          // feature size in um
+     double	 wire_F_sz_um;		// wire feature size in um //Divya added
      unsigned int num_rw_ports;
      unsigned int num_rd_ports;
      unsigned int num_wr_ports;
***************
*** 212,217 ****
--- 225,232 ----
      bool print_input_args;
      unsigned int nuca_cache_sz; // TODO
      int ndbl, ndwl, nspd, ndsam1, ndsam2, ndcm;
+     int ntbl, ntwl, ntspd, ntsam1, ntsam2, ntcm; //Divya adding tag array params
+ 
      bool force_cache_config;
  
      int cache_level; 
***************
*** 365,371 ****
      bool valid;
      results_mem_array tag_array;
      results_mem_array data_array;
! 
      void find_delay();
      void find_energy();
      void find_area();
--- 380,390 ----
      bool valid;
      results_mem_array tag_array;
      results_mem_array data_array;
! //Divya added
!     std::vector<uca_org_t * > uca_q;//for results share the same settings (g_ip and dyn_p) but with different tech settings such as DVFS
!     uca_org_t();
!     void cleanup();
! //Divya end
      void find_delay();
      void find_energy();
      void find_area();
diff -crB pcacti_xml/cacti.mk fncacti/cacti.mk
*** pcacti_xml/cacti.mk	2014-07-03 13:20:28.000000000 +0530
--- fncacti/cacti.mk	2020-01-13 20:39:14.000000000 +0530
***************
*** 4,10 ****
  .SUFFIXES: .cc .o
  
  ifndef NTHREADS
!   NTHREADS = 16
  endif
  
  
--- 4,10 ----
  .SUFFIXES: .cc .o
  
  ifndef NTHREADS
!   NTHREADS = 1
  endif
  
  
diff -crB pcacti_xml/component.cc fncacti/component.cc
*** pcacti_xml/component.cc	2014-07-03 13:18:48.000000000 +0530
--- fncacti/component.cc	2021-08-27 16:42:20.039948778 +0530
***************
*** 117,125 ****
    assert(w_folded_pmos > 0);
  
    /***** Alireza - BEGIN *****/
!   if ( g_ip->is_finfet ) {
      const TechnologyParameter::DeviceType * dt = &g_tp.peri_global;
!     double W_min = 2 * dt->H_fin;
      int N_fin_pmos = (int) (ceil(w_pmos / W_min));
      int N_fin_max_pmos = (int) (floor(w_folded_pmos / dt->P_fin)); // + 1;
      if ( N_fin_max_pmos == 0 ) { cout << "ERROR: divide by zero in compute_gate_area function!\n"; exit(0); }
--- 117,125 ----
    assert(w_folded_pmos > 0);
  
    /***** Alireza - BEGIN *****/
!    if ( g_ip->is_finfet ) {
      const TechnologyParameter::DeviceType * dt = &g_tp.peri_global;
!     double W_min = 2 * dt->H_fin + dt->W_fin; //2 * dt->H_fin;(original) //Divya changed
      int N_fin_pmos = (int) (ceil(w_pmos / W_min));
      int N_fin_max_pmos = (int) (floor(w_folded_pmos / dt->P_fin)); // + 1;
      if ( N_fin_max_pmos == 0 ) { cout << "ERROR: divide by zero in compute_gate_area function!\n"; exit(0); }
***************
*** 161,173 ****
    double w_nmos_phys, w_pmos_phys;
    if ( g_ip->is_finfet ) {
      const TechnologyParameter::DeviceType * dt = &g_tp.peri_global;
!     double W_min = 2 * dt->H_fin;
      int N_fin_pmos = (int) (ceil(w_pmos / W_min));
      int N_fin_nmos = (int) (ceil(w_nmos / W_min));
      w_pmos_phys = N_fin_pmos * W_min;
      w_nmos_phys = N_fin_nmos * W_min;
    } else {
!     w_pmos_phys = w_pmos;
      w_nmos_phys = w_nmos;
    }
    /****** Alireza - END ******/
--- 163,175 ----
    double w_nmos_phys, w_pmos_phys;
    if ( g_ip->is_finfet ) {
      const TechnologyParameter::DeviceType * dt = &g_tp.peri_global;
!     double W_min = 2 * dt->H_fin + dt->W_fin; //2 * dt->H_fin;(original) //Divya changed
      int N_fin_pmos = (int) (ceil(w_pmos / W_min));
      int N_fin_nmos = (int) (ceil(w_nmos / W_min));
      w_pmos_phys = N_fin_pmos * W_min;
      w_nmos_phys = N_fin_nmos * W_min;
    } else {
!      w_pmos_phys = w_pmos;
      w_nmos_phys = w_nmos;
    }
    /****** Alireza - END ******/
***************
*** 176,182 ****
    {
      //means that the height of the gate can 
      //be made smaller than the input height specified, so calculate the height of the gate.
!     gate.h = w_nmos + w_pmos + g_tp.MIN_GAP_BET_P_AND_N_DIFFS + 2 * g_tp.HPOWERRAIL;
    }
    else
    {
--- 178,185 ----
    {
      //means that the height of the gate can 
      //be made smaller than the input height specified, so calculate the height of the gate.
! //    gate.h = w_nmos + w_pmos + g_tp.MIN_GAP_BET_P_AND_N_DIFFS + 2 * g_tp.HPOWERRAIL;
! 	  gate.h = w_nmos_phys + w_pmos_phys + g_tp.MIN_GAP_BET_P_AND_N_DIFFS + 2 * g_tp.HPOWERRAIL; //divya changing this to match finfet width
    }
    else
    {
***************
*** 200,212 ****
    int num_folded_tr;
    if ( g_ip->is_finfet ) {
      const TechnologyParameter::DeviceType * dt = &g_tp.peri_global; // for sense amplifier!
!     double W_min = 2 * dt->H_fin;
      int N_fin = (int) (ceil(input_width / W_min));
      int N_fin_max = (int) (floor(threshold_folding_width / dt->P_fin)); // + 1;
  	 if ( N_fin_max == 0 ) { cout << "ERROR: divide by zero in compute_tr_width_after_folding function!\n"; exit(0); }
! 	 num_folded_tr = (int) (ceil((double)N_fin / N_fin_max));
    } else {
!     num_folded_tr = (int) (ceil(input_width / threshold_folding_width));
    }
    /****** Alireza - END ******/
    
--- 203,217 ----
    int num_folded_tr;
    if ( g_ip->is_finfet ) {
      const TechnologyParameter::DeviceType * dt = &g_tp.peri_global; // for sense amplifier!
!     double W_min = 2 * dt->H_fin + dt->W_fin; // 2 * dt->H_fin;(original) //Divya changed
      int N_fin = (int) (ceil(input_width / W_min));
      int N_fin_max = (int) (floor(threshold_folding_width / dt->P_fin)); // + 1;
  	 if ( N_fin_max == 0 ) { cout << "ERROR: divide by zero in compute_tr_width_after_folding function!\n"; exit(0); }
! 
!     num_folded_tr = (int) (ceil((double)N_fin / N_fin_max));
! 
    } else {
!   num_folded_tr = (int) (ceil(input_width / threshold_folding_width));
    }
    /****** Alireza - END ******/
    
Only in fncacti: .cproject
diff -crB pcacti_xml/decoder.cc fncacti/decoder.cc
*** pcacti_xml/decoder.cc	2014-07-03 13:17:48.000000000 +0530
--- fncacti/decoder.cc	2021-02-10 00:49:23.543609000 +0530
***************
*** 1402,1408 ****
    int    i;
    double rd, c_load, c_intrinsic, tf;
    double this_delay = 0;
! 
    for (i = 0; i < number_gates - 1; ++i)
    {
      rd = tr_R_on(width_n[i], NCH, 1, is_dram_);
--- 1401,1407 ----
    int    i;
    double rd, c_load, c_intrinsic, tf;
    double this_delay = 0;
! //  cout << "number gates in bitline precharge driver : " << number_gates << endl;
    for (i = 0; i < number_gates - 1; ++i)
    {
      rd = tr_R_on(width_n[i], NCH, 1, is_dram_);
diff -crB pcacti_xml/htree2.cc fncacti/htree2.cc
*** pcacti_xml/htree2.cc	2014-07-03 13:17:00.000000000 +0530
--- fncacti/htree2.cc	2021-08-27 16:45:05.235368811 +0530
***************
*** 54,60 ****
    uca_tree(uca_tree_), wt(wire_model), deviceType(dt)
  {
    assert(bl >= 2 && wl >= 2);
!   
  //  if (bl == 1 && wl == 1)
  //  {
  //    delay = 0;
--- 54,60 ----
    uca_tree(uca_tree_), wt(wire_model), deviceType(dt)
  {
    assert(bl >= 2 && wl >= 2);
! 
  //  if (bl == 1 && wl == 1)
  //  {
  //    delay = 0;
***************
*** 220,228 ****
    int v = (int) _log2(ndbl/2); // vertical nodes
    double len_temp;
    double ht_temp;
    if (uca_tree)
    {
!     ht_temp = (mat_height*ndbl/2 +/* since uca_tree models interbank tree, mat_height => bank height */  
          ((add_bits + data_in_bits + data_out_bits) * g_tp.wire_outside_mat.pitch *
           2 * (1-pow(0.5,h))))/2;
      len_temp = (mat_width*ndwl/2 +
--- 222,231 ----
    int v = (int) _log2(ndbl/2); // vertical nodes
    double len_temp;
    double ht_temp;
+ 
    if (uca_tree)
    {
!     ht_temp = (mat_height*ndbl/2 + /* since uca_tree models interbank tree, mat_height => bank height */
          ((add_bits + data_in_bits + data_out_bits) * g_tp.wire_outside_mat.pitch *
           2 * (1-pow(0.5,h))))/2;
      len_temp = (mat_width*ndwl/2 +
diff -crB pcacti_xml/io.cc fncacti/io.cc
*** pcacti_xml/io.cc	2014-07-17 19:49:49.000000000 +0530
--- fncacti/io.cc	2021-08-27 16:50:23.980793424 +0530
***************
*** 107,133 ****
  		sscanf(temp_var, "%lf", &(F_sz_um));
  		F_sz_nm = F_sz_um*1000;
  	}
! 	
  	if ( xMainNode.getChildNode("operating_voltage").isEmpty() ) {
  		cerr << "XML ERROR: <operating_voltage> in the '" << in_file <<"' file is missing.\n";
  		exit(0);
  	} else if ( xMainNode.getChildNode("operating_voltage").nText() == 0 ) {
  		cerr << "XML ERROR: <operating_voltage> in the '" << in_file <<"' file does not have a value.\n";
! 		cerr << "Please specify either 'super-threshold' or 'near-threshold' as the operating voltage." << endl;
  		exit(0);
  	} else {
  		strcpy(temp_var,xMainNode.getChildNode("operating_voltage").getText(0));
! 		for (int i = 0; temp_var[i]; i++) { temp_var[i] = tolower(temp_var[i]); }
! 		if (!strncmp("near-threshold", temp_var, strlen("near-threshold"))) {
! 			is_near_threshold = 1;
! 		} else if (!strncmp("super-threshold", temp_var, strlen("super-threshold"))) {
! 			is_near_threshold = 0;
  		} else {
! 			cerr << "ERROR: Invalid operating voltage!\nSupported operating voltages: 'super-threshold', 'near-threshold'.\n";
  			exit(0);
  		}
  	}
! 	
  	if ( xMainNode.getChildNode("temperature").isEmpty() ) {
  		cerr << "XML ERROR: <temperature> in the '" << in_file <<"' file is missing.\n";
  		exit(0);
--- 105,181 ----
  		sscanf(temp_var, "%lf", &(F_sz_um));
  		F_sz_nm = F_sz_um*1000;
  	}
! 	//Divya added begin
! 	if ( xMainNode.getChildNode("wire_technology_node").isEmpty() ) {
! 			cerr << "XML ERROR: <wire_technology_node> in the '" << in_file <<"' file is missing.\n";
! 			exit(0);
! 		} else if ( xMainNode.getChildNode("wire_technology_node").nText() == 0 ) {
! 			cerr << "XML ERROR: <wire_technology_node> in the '" << in_file <<"' file does not have a value.\n";
! 			exit(0);
! 		} else {
! 		strcpy(temp_var,xMainNode.getChildNode("wire_technology_node").getText(0));
! 		sscanf(temp_var, "%lf", &(wire_F_sz_um));
! 		wire_F_sz_nm = wire_F_sz_um*1000;
! 	}
! 	//Divya end
! 
  	if ( xMainNode.getChildNode("operating_voltage").isEmpty() ) {
  		cerr << "XML ERROR: <operating_voltage> in the '" << in_file <<"' file is missing.\n";
  		exit(0);
  	} else if ( xMainNode.getChildNode("operating_voltage").nText() == 0 ) {
  		cerr << "XML ERROR: <operating_voltage> in the '" << in_file <<"' file does not have a value.\n";
! 		cerr << "Please specify the operating voltage." << endl;
  		exit(0);
  	} else {
  		strcpy(temp_var,xMainNode.getChildNode("operating_voltage").getText(0));
! 		sscanf(temp_var, "%lf", &(vdd));
! 	}
! 
! 	if ( xMainNode.getChildNode("DVS").isEmpty() ) {
! 			cerr << "XML ERROR: <DVS> in the '" << in_file <<"' file is missing.\n";
! 			exit(0);
! 		} else if ( xMainNode.getChildNode("DVS").nText() == 0 ) {
! 			cerr << "XML ERROR: <DVS> in the '" << in_file <<"' file does not have a value.\n";
! 			cerr << "Please specify the operating voltage." << endl;
! 			exit(0);
  		} else {
! 			strcpy(temp_var,xMainNode.getChildNode("DVS").getText(0));
! 			if (!strncmp("true", temp_var, strlen("true"))) {
! 				is_dvs = true;
! 			} else {
! 				is_dvs = false;
! 			}
! 		}
! 	if(is_dvs) {
! 		if ( xMainNode.getChildNode("DVS_start").isEmpty() ) {
! 			cerr << "XML ERROR: <DVS_start> in the '" << in_file <<"' file is missing.\n";
! 			exit(0);
! 		} else if ( xMainNode.getChildNode("DVS_start").nText() == 0 ) {
! 			cerr << "XML ERROR: <DVS_start> in the '" << in_file <<"' file does not have a value.\n";
! 			cerr << "Please specify the operating voltage." << endl;
! 			exit(0);
! 		} else {
! 			strcpy(temp_var,xMainNode.getChildNode("DVS_start").getText(0));
! 			sscanf(temp_var, "%lf", &(dvs_start));
! 		}
! 		if ( xMainNode.getChildNode("DVS_end").isEmpty() ) {
! 			cerr << "XML ERROR: <DVS_end> in the '" << in_file <<"' file is missing.\n";
! 			exit(0);
! 		} else if ( xMainNode.getChildNode("DVS_end").nText() == 0 ) {
! 			cerr << "XML ERROR: <DVS_end> in the '" << in_file <<"' file does not have a value.\n";
! 			cerr << "Please specify the operating voltage." << endl;
  			exit(0);
+ 		} else {
+ 			strcpy(temp_var,xMainNode.getChildNode("DVS_end").getText(0));
+ 			sscanf(temp_var, "%lf", &(dvs_end));
  		}
  	}
! 	else {
! 		dvs_start = 0;
! 		dvs_end = 0;
! 	}
! 	// Divya end
! 
  	if ( xMainNode.getChildNode("temperature").isEmpty() ) {
  		cerr << "XML ERROR: <temperature> in the '" << in_file <<"' file is missing.\n";
  		exit(0);
***************
*** 210,217 ****
  		}
  	}
  	
! 	int Nfins[5];
! 	double Lphys[5], Ioffs[5];
  	XMLNode SRAM_transistor_parameters = SRAM_cell_conf_node.getChildNode("transistor_parameters");
  	if ( is_finfet ) {
  		strcpy(temp_var,SRAM_transistor_parameters.getChildNode("acc").getChildNode("num_of_fins").getText(0));
--- 258,264 ----
  		}
  	}
  	
! 	double Ioffs[5];
  	XMLNode SRAM_transistor_parameters = SRAM_cell_conf_node.getChildNode("transistor_parameters");
  	if ( is_finfet ) {
  		strcpy(temp_var,SRAM_transistor_parameters.getChildNode("acc").getChildNode("num_of_fins").getText(0));
***************
*** 233,284 ****
  	XMLNode SRAM_transistor_definition = XMLNode::openFileHelper(SRAM_transistor_parameters.getChildNode("acc").getChildNode("device_type").getText(0),"device_definition");
  	strcpy(temp_var,SRAM_transistor_definition.getChildNode("geometries").getChildNode("Lphy").getText(0));
  	sscanf(temp_var,"%lf",&(Lphys[0]));
- 	char temperature[10];
- 	sprintf(temperature,"%d",g_ip->temp);
- 	if (is_near_threshold)
- 		strcpy(temp_var,SRAM_transistor_definition.getChildNode("currents").getChildNode("OFF_current").getChildNode("NMOS").getChildNode("near_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
- 	else
- 		strcpy(temp_var,SRAM_transistor_definition.getChildNode("currents").getChildNode("OFF_current").getChildNode("NMOS").getChildNode("super_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
- 	sscanf(temp_var,"%lf",&(Ioffs[0]));
  
  	SRAM_transistor_definition = XMLNode::openFileHelper(SRAM_transistor_parameters.getChildNode("pup").getChildNode("device_type").getText(0),"device_definition");
! 	strcpy(temp_var,SRAM_transistor_definition.getChildNode("geometries").getChildNode("Lphy").getText(0));
  	sscanf(temp_var,"%lf",&(Lphys[1]));
! 	if(is_near_threshold)
! 		strcpy(temp_var,SRAM_transistor_definition.getChildNode("currents").getChildNode("OFF_current").getChildNode("PMOS").getChildNode("near_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 	else
! 		strcpy(temp_var,SRAM_transistor_definition.getChildNode("currents").getChildNode("OFF_current").getChildNode("PMOS").getChildNode("super_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 	sscanf(temp_var,"%lf",&(Ioffs[1]));
! 	
  	SRAM_transistor_definition = XMLNode::openFileHelper(SRAM_transistor_parameters.getChildNode("pdn").getChildNode("device_type").getText(0),"device_definition");
  	strcpy(temp_var,SRAM_transistor_definition.getChildNode("geometries").getChildNode("Lphy").getText(0));
  	sscanf(temp_var,"%lf",&(Lphys[2]));
! 	if(is_near_threshold)
! 		strcpy(temp_var,SRAM_transistor_definition.getChildNode("currents").getChildNode("OFF_current").getChildNode("NMOS").getChildNode("near_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 	else
! 		strcpy(temp_var,SRAM_transistor_definition.getChildNode("currents").getChildNode("OFF_current").getChildNode("NMOS").getChildNode("super_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 	sscanf(temp_var,"%lf",&(Ioffs[2]));
! 	
  	if (sram_cell_design.getType() == std_8T) {
  		SRAM_transistor_definition = XMLNode::openFileHelper(SRAM_transistor_parameters.getChildNode("iso").getChildNode("device_type").getText(0),"device_definition");
  		strcpy(temp_var,SRAM_transistor_definition.getChildNode("geometries").getChildNode("Lphy").getText(0));
  		sscanf(temp_var,"%lf",&(Lphys[3]));
! 		if (is_near_threshold)
! 			strcpy(temp_var,SRAM_transistor_definition.getChildNode("currents").getChildNode("OFF_current").getChildNode("NMOS").getChildNode("near_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 		else
! 			strcpy(temp_var,SRAM_transistor_definition.getChildNode("currents").getChildNode("OFF_current").getChildNode("NMOS").getChildNode("super_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
  		sscanf(temp_var,"%lf",&(Ioffs[3]));
  
  		SRAM_transistor_definition = XMLNode::openFileHelper(SRAM_transistor_parameters.getChildNode("rac").getChildNode("device_type").getText(0),"device_definition");
  		strcpy(temp_var,SRAM_transistor_definition.getChildNode("geometries").getChildNode("Lphy").getText(0));
  		sscanf(temp_var,"%lf",&(Lphys[4]));
! 		if (is_near_threshold)
! 			strcpy(temp_var,SRAM_transistor_definition.getChildNode("currents").getChildNode("OFF_current").getChildNode("NMOS").getChildNode("near_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 		else
! 			strcpy(temp_var,SRAM_transistor_definition.getChildNode("currents").getChildNode("OFF_current").getChildNode("NMOS").getChildNode("super_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
  		sscanf(temp_var,"%lf",&(Ioffs[4]));
  	}
! 	
  	sram_cell_design.setTransistorParams(Nfins, Lphys, Ioffs);
  
  	XMLNode ports_node = xMainNode.getChildNode("ports");
--- 280,324 ----
  	XMLNode SRAM_transistor_definition = XMLNode::openFileHelper(SRAM_transistor_parameters.getChildNode("acc").getChildNode("device_type").getText(0),"device_definition");
  	strcpy(temp_var,SRAM_transistor_definition.getChildNode("geometries").getChildNode("Lphy").getText(0));
  	sscanf(temp_var,"%lf",&(Lphys[0]));
  
+ 	//Divya adding begin
+ 
+ 	char volt[10];
+ 	sprintf(volt,"%.1f",vdd);
+ 
+ 	strcpy(temp_var,SRAM_transistor_definition.getChildNode("currents").getChildNode("OFF_current").getChildNode("NMOS").getChildNodeWithAttribute("volt","val",volt).getText(0));
+ 	sscanf(temp_var, "%lf", &(Ioffs[0]));
  	SRAM_transistor_definition = XMLNode::openFileHelper(SRAM_transistor_parameters.getChildNode("pup").getChildNode("device_type").getText(0),"device_definition");
! 		strcpy(temp_var,SRAM_transistor_definition.getChildNode("geometries").getChildNode("Lphy").getText(0));
  	sscanf(temp_var,"%lf",&(Lphys[1]));
! 
! 	strcpy(temp_var,SRAM_transistor_definition.getChildNode("currents").getChildNode("OFF_current").getChildNode("PMOS").getChildNodeWithAttribute("volt","val",volt).getText(0));
! 	sscanf(temp_var, "%lf", &(Ioffs[1]));
  	SRAM_transistor_definition = XMLNode::openFileHelper(SRAM_transistor_parameters.getChildNode("pdn").getChildNode("device_type").getText(0),"device_definition");
+ 
  	strcpy(temp_var,SRAM_transistor_definition.getChildNode("geometries").getChildNode("Lphy").getText(0));
  	sscanf(temp_var,"%lf",&(Lphys[2]));
! 
! 	strcpy(temp_var,SRAM_transistor_definition.getChildNode("currents").getChildNode("OFF_current").getChildNode("NMOS").getChildNodeWithAttribute("volt","val",volt).getText(0));
! 	sscanf(temp_var, "%lf", &(Ioffs[2]));
! 
  	if (sram_cell_design.getType() == std_8T) {
  		SRAM_transistor_definition = XMLNode::openFileHelper(SRAM_transistor_parameters.getChildNode("iso").getChildNode("device_type").getText(0),"device_definition");
  		strcpy(temp_var,SRAM_transistor_definition.getChildNode("geometries").getChildNode("Lphy").getText(0));
  		sscanf(temp_var,"%lf",&(Lphys[3]));
! 
! 		strcpy(temp_var,SRAM_transistor_definition.getChildNode("currents").getChildNode("OFF_current").getChildNode("NMOS").getChildNodeWithAttribute("volt","val",volt).getText(0));
  		sscanf(temp_var,"%lf",&(Ioffs[3]));
  
  		SRAM_transistor_definition = XMLNode::openFileHelper(SRAM_transistor_parameters.getChildNode("rac").getChildNode("device_type").getText(0),"device_definition");
  		strcpy(temp_var,SRAM_transistor_definition.getChildNode("geometries").getChildNode("Lphy").getText(0));
  		sscanf(temp_var,"%lf",&(Lphys[4]));
! 		strcpy(temp_var,SRAM_transistor_definition.getChildNode("currents").getChildNode("OFF_current").getChildNode("NMOS").getChildNodeWithAttribute("volt","val",volt).getText(0));
  		sscanf(temp_var,"%lf",&(Ioffs[4]));
  	}
! 
! 	// Divya end
! 
  	sram_cell_design.setTransistorParams(Nfins, Lphys, Ioffs);
  
  	XMLNode ports_node = xMainNode.getChildNode("ports");
***************
*** 402,410 ****
  	strcpy(temp_var,interconnectsInfoNode.getChildNode("source").getText(0));
  	if (!strncmp("ITRS2012", temp_var, strlen("ITRS2012"))) {
  		is_itrs2012 = true;
  	} else if (!strncmp("RonHo2003", temp_var, strlen("RonHo2003"))) {
  		is_itrs2012 = false;
! 	} else {
  		cout << "ERROR: Invalid interconnect source!\n";
  		exit(0);
  	}
--- 442,455 ----
  	strcpy(temp_var,interconnectsInfoNode.getChildNode("source").getText(0));
  	if (!strncmp("ITRS2012", temp_var, strlen("ITRS2012"))) {
  		is_itrs2012 = true;
+ 		is_asap7 = false;
  	} else if (!strncmp("RonHo2003", temp_var, strlen("RonHo2003"))) {
  		is_itrs2012 = false;
! 		is_asap7 = false;
! 	} else if (!strncmp("ASAP7", temp_var, strlen("ASAP7"))) {
! 		is_asap7 = true;
! 		is_itrs2012 = false;
! 	}else {
  		cout << "ERROR: Invalid interconnect source!\n";
  		exit(0);
  	}
***************
*** 511,516 ****
--- 556,582 ----
  	strcpy(temp_var,xMainNode.getChildNode("Ndcm").getText(0));
  	sscanf(temp_var, "%d", &(ndcm));
  	
+ //Divya adding tag array params begin
+ 	strcpy(temp_var,xMainNode.getChildNode("Ntbl").getText(0));
+ 	sscanf(temp_var, "%d", &(ntbl));
+ 
+ 	strcpy(temp_var,xMainNode.getChildNode("Ntwl").getText(0));
+ 	sscanf(temp_var, "%d", &(ntwl));
+ 
+ 	strcpy(temp_var,xMainNode.getChildNode("Ntspd").getText(0));
+ 	sscanf(temp_var, "%d", &(ntspd));
+ 
+ 	strcpy(temp_var,xMainNode.getChildNode("Ntsam1").getText(0));
+ 	sscanf(temp_var, "%d", &(ntsam1));
+ 
+ 	strcpy(temp_var,xMainNode.getChildNode("Ntsam2").getText(0));
+ 	sscanf(temp_var, "%d", &(ntsam2));
+ 
+ 	strcpy(temp_var,xMainNode.getChildNode("Ntcm").getText(0));
+ 	sscanf(temp_var, "%d", &(ntcm));
+ //Divya adding tag array params end
+ 
+ 
  	strcpy(temp_var,xMainNode.getChildNode("page_size").getText(0));
  	sscanf(temp_var, "%u", &(page_sz_bits));
  	
***************
*** 549,556 ****
    cout << "Cache banks (UCA)             : " << nbanks << endl;
    cout << "Technology                    : " << F_sz_nm << "nm" << endl; // changed to nm. -Alireza
    cout << "Transistor type               : " << (is_finfet ? "FinFET" : "CMOS" ) << endl; // Alireza
!   cout << "Operating voltage             : " << (is_near_threshold ? "Near-threshold" : "Super-threshold" ) << endl; // Alireza
!   if (g_ip->sram_cell_design.getType()==std_6T) { // Alireza
      cout << "SRAM cell type                : " << "Standard 6T" << endl;
    } else if (g_ip->sram_cell_design.getType()==std_8T) {
      cout << "SRAM cell type                : " << "Standard 8T" << endl;
--- 615,623 ----
    cout << "Cache banks (UCA)             : " << nbanks << endl;
    cout << "Technology                    : " << F_sz_nm << "nm" << endl; // changed to nm. -Alireza
    cout << "Transistor type               : " << (is_finfet ? "FinFET" : "CMOS" ) << endl; // Alireza
! //  cout << "Operating voltage             : " << (is_near_threshold ? "Near-threshold" : "Super-threshold" ) << endl; // Alireza
!     cout << "Operating voltage             : " << vdd << endl; // Alireza
!  	if (g_ip->sram_cell_design.getType()==std_6T) { // Alireza
      cout << "SRAM cell type                : " << "Standard 6T" << endl;
    } else if (g_ip->sram_cell_design.getType()==std_8T) {
      cout << "SRAM cell type                : " << "Standard 8T" << endl;
***************
*** 587,593 ****
    cout << "Wire inside mat               : " << wire_is_mat_type << endl;
    cout << "Wire outside mat              : " << wire_os_mat_type << endl;
    cout << "Interconnect projection       : " << ic_proj_type << endl;
!   cout << "Wire signalling               : " << force_wiretype << endl;
    cout << "Cores                         : " << cores << endl;
    cout << "Print details                 : " << (print_detail ? "Yes" : "No" ) << endl; // Alireza
    cout << "ECC overhead                  : " << (add_ecc_b_ ? "Yes" : "No" ) << endl; // Alireza
--- 654,661 ----
    cout << "Wire inside mat               : " << wire_is_mat_type << endl;
    cout << "Wire outside mat              : " << wire_os_mat_type << endl;
    cout << "Interconnect projection       : " << ic_proj_type << endl;
!   cout << "Wire signalling               : " << wt << endl;
!   cout << "Force Wire type				 : " << force_wiretype << endl;
    cout << "Cores                         : " << cores << endl;
    cout << "Print details                 : " << (print_detail ? "Yes" : "No" ) << endl; // Alireza
    cout << "ECC overhead                  : " << (add_ecc_b_ ? "Yes" : "No" ) << endl; // Alireza
***************
*** 643,649 ****
    if (g_ip->error_checking() == false) { cout << "ERROR: Invalid input parameters!\n", exit(0); }
    if (g_ip->print_input_args) g_ip->display_ip();
  
!   init_tech_params(g_ip->F_sz_um, false);
    if (g_ip->print_input_args) g_tp.display(); // Alireza
    
    Wire winit; // Do not delete this line. It initializes wires.
--- 711,719 ----
    if (g_ip->error_checking() == false) { cout << "ERROR: Invalid input parameters!\n", exit(0); }
    if (g_ip->print_input_args) g_ip->display_ip();
  
! //  init_tech_params(g_ip->F_sz_um, false);
!   init_tech_params(g_ip->F_sz_um, g_ip->wire_F_sz_um, false); //Divya added wire_technology
! 
    if (g_ip->print_input_args) g_tp.display(); // Alireza
    
    Wire winit; // Do not delete this line. It initializes wires.
***************
*** 659,669 ****
--- 729,751 ----
    }
  //  g_ip->display_ip();
    solve(&fin_res);
+   Wire wprint;//reset wires to original configuration as in *.cfg file (dvs level 0)
+ 
+   //Divya begin
+   if (g_ip->is_dvs)
+    {
+  	  update_dvs(&fin_res);
+    }
+   //Divya end
  
    output_UCA(&fin_res);
    //output_summary_of_results(&fin_res);
    output_summary_of_results_file(&fin_res);
  
+ //  Wire wprint;//reset wires to original configuration as in *.cfg file (dvs level 0)
+   //Wire::print_wire();
+   wprint.print_wire();
+ 
    delete (g_ip);
    return fin_res;
  }
***************
*** 845,851 ****
    if (g_ip->error_checking() == false) exit(0);
    if (g_ip->print_input_args) 
      g_ip->display_ip();
!   init_tech_params(g_ip->F_sz_um, false);
    Wire winit; // Do not delete this line. It initializes wires.
  
    if (g_ip->nuca == 1)
--- 927,935 ----
    if (g_ip->error_checking() == false) exit(0);
    if (g_ip->print_input_args) 
      g_ip->display_ip();
! //  init_tech_params(g_ip->F_sz_um, false);
!   init_tech_params(g_ip->F_sz_um, g_ip->wire_F_sz_um, false); //divya added wire technology
! 
    Wire winit; // Do not delete this line. It initializes wires.
  
    if (g_ip->nuca == 1)
***************
*** 1186,1192 ****
  }
  
  
! 
  void output_UCA(uca_org_t *fr)
  {
    //    if (NUCA) 
--- 1270,1276 ----
  }
  
  
! /*
  void output_UCA(uca_org_t *fr)
  {
    //    if (NUCA) 
***************
*** 1338,1345 ****
    {
      if(g_ip->fully_assoc) return;
  
!     /* Delay stats */
!     /* data array stats */ 
      cout << endl << "Time Components:" << endl << endl;
  
      cout << "  Data side (with Output driver) (ns): " <<
--- 1422,1429 ----
    {
      if(g_ip->fully_assoc) return;
  
!     // Delay stats
!     // data array stats
      cout << endl << "Time Components:" << endl << endl;
  
      cout << "  Data side (with Output driver) (ns): " <<
***************
*** 1366,1372 ****
  
      if (g_ip->is_cache && !g_ip->is_main_mem)
      {
!       /* tag array stats */
        cout << endl << "  Tag side (with Output driver) (ns): " <<
          fr->tag_array2->access_time/1e-9 << endl;
  
--- 1450,1456 ----
  
      if (g_ip->is_cache && !g_ip->is_main_mem)
      {
!       // tag array stats
        cout << endl << "  Tag side (with Output driver) (ns): " <<
          fr->tag_array2->access_time/1e-9 << endl;
  
***************
*** 1392,1410 ****
          fr->tag_array2->delay_dout_htree * 1e9 << endl;
      }
  
!     /* Energy/Power stats */
      cout << endl << endl << "Power Components:" << endl << endl;
!     cout << "  Data array: Total dynamic read energy/access  (nJ): " <<
        fr->data_array2->power.readOp.dynamic * 1e9 << endl;
      cout << "\tTotal leakage read/write power of a bank (mW): " <<
          fr->data_array2->power.readOp.leakage * 1e3 << endl;
!     cout << "\tTotal energy in H-tree (that includes both "
        "address and data transfer) (nJ): " << 
!         (fr->data_array2->power_addr_input_htree.readOp.dynamic +
!          fr->data_array2->power_data_output_htree.readOp.dynamic +
           fr->data_array2->power_routing_to_bank.readOp.dynamic) * 1e9 << endl;
  
!     cout << "\tOutput Htree Energy (nJ): " <<
        fr->data_array2->power_data_output_htree.readOp.dynamic * 1e9 << endl;
      cout <<  "\tDecoder (nJ): " <<
        fr->data_array2->power_row_predecoder_drivers.readOp.dynamic * 1e9 +
--- 1476,1497 ----
          fr->tag_array2->delay_dout_htree * 1e9 << endl;
      }
  
!     // Energy/Power stats
      cout << endl << endl << "Power Components:" << endl << endl;
!     cout << "  Data array: \n Total dynamic read energy/access  (nJ): " <<
        fr->data_array2->power.readOp.dynamic * 1e9 << endl;
      cout << "\tTotal leakage read/write power of a bank (mW): " <<
          fr->data_array2->power.readOp.leakage * 1e3 << endl;
!     cout << "\tTotal energy in H-tree outside banks (that includes both "
        "address and data transfer) (nJ): " << 
!         (//fr->data_array2->power_addr_input_htree.readOp.dynamic +
!         // fr->data_array2->power_data_output_htree.readOp.dynamic +
           fr->data_array2->power_routing_to_bank.readOp.dynamic) * 1e9 << endl;
  
!     cout << "\tInput H-tree inside bank Energy (nJ): " <<
!     (fr->data_array2->power_addr_input_htree.readOp.dynamic) * 1e9 << endl;
! 
!     cout << "\tOutput Htree Energy inside bank Energy (nJ): " <<
        fr->data_array2->power_data_output_htree.readOp.dynamic * 1e9 << endl;
      cout <<  "\tDecoder (nJ): " <<
        fr->data_array2->power_row_predecoder_drivers.readOp.dynamic * 1e9 +
***************
*** 1431,1446 ****
  
      if (g_ip->is_cache && !g_ip->is_main_mem)
      {
!       cout << endl << "  Tag array:  Total dynamic read energy/access (nJ): " <<
          fr->tag_array2->power.readOp.dynamic * 1e9 << endl;
        cout << "\tTotal leakage read/write power of a bank (mW): " <<
            fr->tag_array2->power.readOp.leakage * 1e3 << endl;
!       cout << "\tTotal energy in H-tree (that includes both "
          "address and data transfer) (nJ): " << 
!           (fr->tag_array2->power_addr_input_htree.readOp.dynamic +
!            fr->tag_array2->power_data_output_htree.readOp.dynamic +
             fr->tag_array2->power_routing_to_bank.readOp.dynamic) * 1e9 << endl;
  
        cout << "\tOutput Htree Energy (nJ): " <<
          fr->tag_array2->power_data_output_htree.readOp.dynamic * 1e9 << endl;
        cout <<  "\tDecoder (nJ): " <<
--- 1518,1536 ----
  
      if (g_ip->is_cache && !g_ip->is_main_mem)
      {
!       cout << endl << "  Tag array: \n Total dynamic read energy/access (nJ): " <<
          fr->tag_array2->power.readOp.dynamic * 1e9 << endl;
        cout << "\tTotal leakage read/write power of a bank (mW): " <<
            fr->tag_array2->power.readOp.leakage * 1e3 << endl;
!       cout << "\tTotal energy in H-tree outside banks (that includes both "
          "address and data transfer) (nJ): " << 
!           (//fr->tag_array2->power_addr_input_htree.readOp.dynamic +
!            fr->tag_array2->power_data_output_htree.readOp.dynamic +//
             fr->tag_array2->power_routing_to_bank.readOp.dynamic) * 1e9 << endl;
  
+       cout << "\tInput H-tree inside banks Energy (nJ): " <<
+        (fr->tag_array2->power_addr_input_htree.readOp.dynamic) * 1e9 << endl;
+ 
        cout << "\tOutput Htree Energy (nJ): " <<
          fr->tag_array2->power_data_output_htree.readOp.dynamic * 1e9 << endl;
        cout <<  "\tDecoder (nJ): " <<
***************
*** 1468,1481 ****
      }
  
      cout << endl << endl <<  "Area Components:" << endl << endl;
!     /* Data array area stats */
!     cout <<  "  Data array: Area (mm2): " << fr->data_array2->area * 1e-6 << endl;
      cout <<  "\tHeight (mm): " <<
        fr->data_array2->all_banks_height*1e-3 << endl;
      cout <<  "\tWidth (mm): " <<
        fr->data_array2->all_banks_width*1e-3 << endl;
      if (g_ip->print_detail) {
!       cout <<  "\tArea efficiency (Memory cell area/Total area) - " <<
          fr->data_array2->area_efficiency << " %" << endl;
        cout << "\t\tMAT Height (mm): " <<
          fr->data_array2->mat_height*1e-3 << endl;
--- 1558,1571 ----
      }
  
      cout << endl << endl <<  "Area Components:" << endl << endl;
!     // Data array area stats
!     cout <<  "  Data array: \n Area (mm2): " << fr->data_array2->area * 1e-6 << endl;
      cout <<  "\tHeight (mm): " <<
        fr->data_array2->all_banks_height*1e-3 << endl;
      cout <<  "\tWidth (mm): " <<
        fr->data_array2->all_banks_width*1e-3 << endl;
      if (g_ip->print_detail) {
!       cout <<  "\tArea efficiency (Memory cell area/Total area) : " <<
          fr->data_array2->area_efficiency << " %" << endl;
        cout << "\t\tMAT Height (mm): " <<
          fr->data_array2->mat_height*1e-3 << endl;
***************
*** 1487,1503 ****
          fr->data_array2->subarray_length*1e-3 << endl;
      }
  
!     /* Tag array area stats */
      if (g_ip->is_cache && !g_ip->is_main_mem)
      {
!       cout << endl << "  Tag array: Area (mm2): " << fr->tag_array2->area * 1e-6 << endl;
        cout <<  "\tHeight (mm): " <<
          fr->tag_array2->all_banks_height*1e-3 << endl;
        cout <<  "\tWidth (mm): " <<
          fr->tag_array2->all_banks_width*1e-3 << endl;
        if (g_ip->print_detail)
        {
!         cout <<  "\tArea efficiency (Memory cell area/Total area) - " <<
            fr->tag_array2->area_efficiency << " %" << endl;
          cout << "\t\tMAT Height (mm): " <<
            fr->tag_array2->mat_height*1e-3 << endl;
--- 1577,1593 ----
          fr->data_array2->subarray_length*1e-3 << endl;
      }
  
!     // Tag array area stats
      if (g_ip->is_cache && !g_ip->is_main_mem)
      {
!       cout << endl << "  Tag array: \nArea (mm2): " << fr->tag_array2->area * 1e-6 << endl;
        cout <<  "\tHeight (mm): " <<
          fr->tag_array2->all_banks_height*1e-3 << endl;
        cout <<  "\tWidth (mm): " <<
          fr->tag_array2->all_banks_width*1e-3 << endl;
        if (g_ip->print_detail)
        {
!         cout <<  "\tArea efficiency (Memory cell area/Total area) : " <<
            fr->tag_array2->area_efficiency << " %" << endl;
          cout << "\t\tMAT Height (mm): " <<
            fr->tag_array2->mat_height*1e-3 << endl;
***************
*** 1517,1522 ****
--- 1607,2476 ----
      //cout << "FO4 = " << g_tp.FO4 << endl;
    }
  }
+ */
+ 
+ //Divya begin
+ void output_UCA(uca_org_t *fr)
+ {
+   //    if (NUCA)
+ 	bool dvs = g_ip->is_dvs;
+ 	double dvs_volt_step = 0.1;
+ 	int dvs_levels = (g_ip->dvs_end - g_ip->dvs_start)/dvs_volt_step + 1;
+ 	int i;
+ 
+   if (0) {
+     cout << "\n\n Detailed Bank Stats:\n";
+     cout << "    Bank Size (bytes): %d\n" <<
+                                      (int) (g_ip->cache_sz);
+   }
+   else {
+     if (g_ip->data_arr_ram_cell_tech_type == 3) {
+       cout << "\n---------- P-CACTI, Uniform Cache Access " <<
+         "Logic Process Based DRAM Model ----------\n";
+     }
+     else if (g_ip->data_arr_ram_cell_tech_type == 4) {
+       cout << "\n---------- P-CACTI, Uniform" <<
+         "Cache Access Commodity DRAM Model ----------\n";
+     }
+     else {
+       cout << "\n---------- P-CACTI, Uniform Cache Access "
+         "SRAM Model ----------\n";
+     }
+     cout << "\nCache Parameters:\n";
+     cout << "    Total cache size (bytes): " <<
+       (int) (g_ip->cache_sz) << endl;
+   }
+ 
+   cout << "    Number of banks: " << (int) g_ip->nbanks << endl;
+     if (g_ip->fully_assoc)
+       cout << "    Associativity: fully associative\n";
+     else {
+       if (g_ip->tag_assoc == 1)
+         cout << "    Associativity: direct mapped\n";
+       else
+         cout << "    Associativity: " <<
+           g_ip->tag_assoc << endl;
+     }
+ 
+ 
+     cout << "    Block size (bytes): " << g_ip->line_sz << endl;
+     cout << "    Read/write Ports: " <<
+       g_ip->num_rw_ports << endl;
+     cout << "    Read ports: " <<
+       g_ip->num_rd_ports << endl;
+     cout << "    Write ports: " <<
+       g_ip->num_wr_ports << endl;;
+     cout << "    Technology size (nm): " <<
+       g_ip->F_sz_nm << endl << endl;
+ 
+ 
+   if (dvs)
+   {
+ 	 cout << "    Access time (ns): ";
+ 	 for (i = 0; i<dvs_levels; i++)
+ 		  cout<<fr->uca_q[i]->access_time*1e9 <<";";
+ 	 cout << endl;
+   }
+   else
+ 	  cout << "    Access time (ns): " << fr->access_time*1e9 << endl;
+ 
+ 
+   if (dvs)
+   {
+ 	  cout << "    Cycle time (ns):  " ;
+ 	 for (i = 0; i<dvs_levels; i++)
+ 		  cout<<fr->uca_q[i]->cycle_time*1e9 <<"; ";
+ 	 cout<< endl;
+   }
+   else
+   cout << "    Cycle time (ns):  " << fr->cycle_time*1e9 << endl;
+ 
+ 
+   if (g_ip->data_arr_ram_cell_tech_type >= 4) {
+     cout << "    Precharge Delay (ns): " << fr->data_array2->precharge_delay*1e9 << endl;
+     cout << "    Activate Energy (nJ): " << fr->data_array2->activate_energy*1e9 << endl;
+     cout << "    Read Energy (nJ): " << fr->data_array2->read_energy*1e9 << endl;
+     cout << "    Write Energy (nJ): " << fr->data_array2->write_energy*1e9 << endl;
+     cout << "    Precharge Energy (nJ): " << fr->data_array2->precharge_energy*1e9 << endl;
+     cout << "    Leakage Power Closed Page (mW): " << fr->data_array2->leak_power_subbank_closed_page*1e3 << endl;
+     cout << "    Leakage Power Open Page (mW): " << fr->data_array2->leak_power_subbank_open_page*1e3 << endl;
+     cout << "    Leakage Power I/O (mW): " << fr->data_array2->leak_power_request_and_reply_networks*1e3 << endl;
+     cout << "    Refresh power (mW): " <<
+       fr->data_array2->refresh_power*1e3 << endl;
+   }
+   else {
+ 	  if (dvs)
+ 	  {
+ 		  cout << "    Total dynamic read energy per access (nJ): ";
+ 		  for (i = 0; i<dvs_levels; i++)
+ 			  cout<<fr->uca_q[i]->power.readOp.dynamic*1e9 <<"; ";
+ 		  cout<< endl;
+ 		  cout << "    Total dynamic write energy per access (nJ): ";
+ 		  for (i = 0; i<dvs_levels; i++)
+ 		 			  cout<<fr->uca_q[i]->power.writeOp.dynamic*1e9 <<"; ";
+ 		  cout<< endl;
+ 		  cout << "    Total leakage power of a bank (mW): ";
+ 		  for (i = 0; i<dvs_levels; i++)
+ 			  cout<< fr->uca_q[i]->power.readOp.leakage*1e3 <<"; ";
+ 		  cout<< endl;
+  	  }
+ 	  else {
+ 		cout << "    Total dynamic read energy per access (nJ): " <<
+ 		  fr->power.readOp.dynamic*1e9 << endl;
+ 		cout << "    Total dynamic write energy per access (nJ): " << // Alireza
+ 		  fr->power.writeOp.dynamic*1e9 << endl;                      // Alireza
+ 		cout << "    Total leakage power of a bank"
+ 		  " (mW): " << fr->power.readOp.leakage*1e3 << endl;
+ 	  }
+   }
+ 
+   if (g_ip->data_arr_ram_cell_tech_type ==3 || g_ip->data_arr_ram_cell_tech_type ==4)
+   {
+   }
+   if (dvs) {
+ 	  cout <<  "    Cache height x width (mm): ";
+ 	  for (i = 0; i<dvs_levels; i++)
+ 		  cout << fr->uca_q[i]->cache_ht*1e-3 << " x " << fr->cache_len*1e-3 << "; ";
+ 	  cout<< endl;
+ 	  cout <<  "    Cache area (mm2): ";
+ 	  for (i = 0; i<dvs_levels; i++)
+ 		  cout <<	fr->uca_q[i]->area*1e-3*1e-3 << "; ";
+ 	  cout<< endl << endl;
+   } else {
+ 	 cout <<  "    Cache height x width (mm): " <<
+ 		fr->cache_ht*1e-3 << " x " << fr->cache_len*1e-3 << endl;
+ 	  cout <<  "    Cache area (mm2): " <<
+ 		fr->area*1e-3*1e-3 << endl << endl;
+   	  }
+   if (dvs) {
+ 	  cout << "    Best Ndwl : ";
+ 	  for (i = 0; i<dvs_levels; i++)
+ 		  cout << fr->uca_q[i]->data_array2->Ndwl << "; ";
+ 	  cout<< endl;
+ 
+ 	  cout << "    Best Ndbl : ";
+ 	  for (i = 0; i<dvs_levels; i++)
+ 		  cout << fr->uca_q[i]->data_array2->Ndbl << "; ";
+ 	  cout<< endl;
+ 
+ 	  cout << "    Best Nspd : ";
+ 	  for (i = 0; i<dvs_levels; i++)
+ 		  cout << fr->uca_q[i]->data_array2->Nspd << "; ";
+ 	  cout<< endl;
+ 
+ 	  cout << "    Best Ndcm : ";
+ 	  for (i = 0; i<dvs_levels; i++)
+ 		  cout << fr->uca_q[i]->data_array2->deg_bl_muxing << "; ";
+ 	  cout<< endl;
+ 
+ 	  cout << "    Best Ndsam L1 : ";
+ 	  for (i = 0; i<dvs_levels; i++)
+ 		  cout << fr->uca_q[i]->data_array2->Ndsam_lev_1 << "; ";
+ 	  cout<< endl;
+ 
+ 
+ 	  cout << "    Best Ndsam L2 : ";
+ 	  for (i = 0; i<dvs_levels; i++)
+ 		  cout << fr->uca_q[i]->data_array2->Ndsam_lev_2 << "; ";
+ 	  cout<< endl << endl;
+ 
+   } else {
+   cout << "    Best Ndwl : " << fr->data_array2->Ndwl << endl;
+   cout << "    Best Ndbl : " << fr->data_array2->Ndbl << endl;
+   cout << "    Best Nspd : " << fr->data_array2->Nspd << endl;
+   cout << "    Best Ndcm : " << fr->data_array2->deg_bl_muxing << endl;
+   cout << "    Best Ndsam L1 : " << fr->data_array2->Ndsam_lev_1 << endl;
+   cout << "    Best Ndsam L2 : " << fr->data_array2->Ndsam_lev_2 << endl << endl;
+ 
+   }
+ 
+   if (g_ip->is_cache && !g_ip->is_main_mem)
+   {
+ 	  if(dvs) {
+ 		  cout << "    Best Ntwl : ";
+ 		  for (i = 0; i<dvs_levels; i++)
+ 			  cout << fr->uca_q[i]->tag_array2->Ndwl << ";";
+ 		  cout<< endl;
+ 
+ 		  cout << "    Best Ntbl : ";
+ 		  for (i = 0; i<dvs_levels; i++)
+ 			cout << fr->uca_q[i]->tag_array2->Ndbl << ";";
+  		  cout<< endl;
+ 
+  		  cout << "    Best Ntspd : ";
+ 		  for (i = 0; i<dvs_levels; i++)
+ 			cout << fr->uca_q[i]->tag_array2->Nspd << ";";
+ 		  cout<< endl;
+ 
+ 		  cout << "    Best Ntcm : ";
+ 		  for (i = 0; i<dvs_levels; i++)
+ 			cout << fr->uca_q[i]->tag_array2->deg_bl_muxing << ";";
+   		  cout<< endl;
+ 
+ 		  cout << "    Best Ntsam L1 : ";
+ 		  for (i = 0; i<dvs_levels; i++)
+ 			cout << fr->uca_q[i]->tag_array2->Ndsam_lev_1 << ";";
+ 		  cout<< endl;
+ 
+ 		  cout << "    Best Ntsam L2 : ";
+ 		  for (i = 0; i<dvs_levels; i++)
+ 			cout << fr->uca_q[i]->tag_array2->Ndsam_lev_2 << ";";
+ 		  cout<< endl;
+ 
+ 	  } else {
+ 		cout << "    Best Ntwl : " << fr->tag_array2->Ndwl << endl;
+ 		cout << "    Best Ntbl : " << fr->tag_array2->Ndbl << endl;
+ 		cout << "    Best Ntspd : " << fr->tag_array2->Nspd << endl;
+ 		cout << "    Best Ntcm : " << fr->tag_array2->deg_bl_muxing << endl;
+ 		cout << "    Best Ntsam L1 : " << fr->tag_array2->Ndsam_lev_1 << endl;
+ 		cout << "    Best Ntsam L2 : " << fr->tag_array2->Ndsam_lev_2 << endl;
+ 	  }
+   }
+ 
+   switch (fr->data_array2->wt) {
+     case (0):
+       cout <<  "    Data array, H-tree wire type: Delay optimized global wires\n";
+       break;
+     case (1):
+       cout <<  "    Data array, H-tree wire type: Global wires with 5\% delay penalty\n";
+       break;
+     case (2):
+       cout <<  "    Data array, H-tree wire type: Global wires with 10\% delay penalty\n";
+       break;
+     case (3):
+       cout <<  "    Data array, H-tree wire type: Global wires with 20\% delay penalty\n";
+       break;
+     case (4):
+       cout <<  "    Data array, H-tree wire type: Global wires with 30\% delay penalty\n";
+       break;
+     case (5):
+       cout <<  "    Data array, wire type: Low swing wires\n";
+       break;
+     default:
+       cout << "ERROR - Unknown wire type " << (int) fr->data_array2->wt <<endl;
+       exit(0);
+   }
+ 
+   if (g_ip->is_cache) {
+     switch (fr->tag_array2->wt) {
+       case (0):
+         cout <<  "    Tag array, H-tree wire type: Delay optimized global wires\n";
+         break;
+       case (1):
+         cout <<  "    Tag array, H-tree wire type: Global wires with 5\% delay penalty\n";
+         break;
+       case (2):
+         cout <<  "    Tag array, H-tree wire type: Global wires with 10\% delay penalty\n";
+         break;
+       case (3):
+         cout <<  "    Tag array, H-tree wire type: Global wires with 20\% delay penalty\n";
+         break;
+       case (4):
+         cout <<  "    Tag array, H-tree wire type: Global wires with 30\% delay penalty\n";
+         break;
+       case (5):
+         cout <<  "    Tag array, wire type: Low swing wires\n";
+         break;
+       default:
+         cout << "ERROR - Unknown wire type " << (int) fr->tag_array2->wt <<endl;
+         exit(-1);
+     }
+   }
+ 
+   if (g_ip->print_detail)
+   {
+     if(g_ip->fully_assoc) return;
+ 
+     /* Delay stats */
+     /* data array stats */
+     cout << endl << "Time Components:" << endl << endl;
+ 
+     if (dvs)
+      {
+      	cout<< "Data side (with Output driver) (ns): ";
+      	for (i = 0; i<dvs_levels; i++)
+      		cout<<fr->uca_q[i]->data_array2->access_time/1e-9 <<"; ";
+      	cout << endl;
+      } else {
+     cout << "  Data side (with Output driver) (ns): " <<
+       fr->data_array2->access_time/1e-9 << endl;
+      }
+ 
+     if (dvs)
+    {
+ 	 cout <<  "\tH-tree delay outside banks (ns) : " ;
+ 	for (i = 0; i<dvs_levels; i++)
+ 		cout<<fr->uca_q[i]->data_array2->delay_route_to_bank * 1e9 <<"; ";
+ 	cout << endl;
+    } else {
+ 	   cout <<  "\tH-tree delay outside banks (ns) : " <<
+ 			 fr->data_array2->delay_route_to_bank * 1e9 << endl;
+    }
+ 
+ 	if (dvs)
+ 	{
+ 		cout<<"\tH-tree input delay (inside a bank) (ns) :  ";
+ 		for (i = 0; i<dvs_levels; i++)
+ 			cout<<fr->uca_q[i]->data_array2->delay_input_htree * 1e9 <<"; ";
+ 	}
+ 	else {
+ 		 cout <<  "\tH-tree input delay (inside a bank) (ns) : " <<
+ 					  fr->data_array2->delay_input_htree * 1e9 ;
+ 	}
+ 	cout<< endl;
+ 
+ 
+     cout <<  "\tDecoder + wordline delay (ns): ";
+     if (dvs)
+ 	{
+     	for (i = 0; i<dvs_levels; i++)
+     		cout<<fr->uca_q[i]->data_array2->delay_row_predecode_driver_and_block * 1e9 +
+ 				fr->uca_q[i]->data_array2->delay_row_decoder * 1e9 <<"; ";
+     	cout << endl;
+ 	} else {
+ 	  cout << fr->data_array2->delay_row_predecode_driver_and_block * 1e9 +
+ 	  fr->data_array2->delay_row_decoder * 1e9 << endl;
+ 	}
+ 
+     cout <<  "\tBitline delay (ns): ";
+     if(dvs) {
+     	for (i = 0; i<dvs_levels; i++)
+     	    cout<<fr->uca_q[i]->data_array2->delay_bitlines/1e-9  <<"; ";
+     	cout << endl;
+     }
+     else {
+      cout << fr->data_array2->delay_bitlines/1e-9 << endl;
+     }
+ 
+     cout <<  "\tSense Amplifier delay (ns): ";
+     if(dvs) {
+     	for (i = 0; i<dvs_levels; i++)
+     		cout<<fr->uca_q[i]->data_array2->delay_sense_amp*1e9  <<"; ";
+     	cout << endl;
+     } else {
+      cout << fr->data_array2->delay_sense_amp * 1e9 << endl;
+     }
+ 
+     cout <<  "\tH-tree output delay (inside a bank) (ns): ";
+     if(dvs) {
+     	for (i = 0; i<dvs_levels; i++)
+     		cout<<fr->uca_q[i]->data_array2->delay_subarray_output_driver * 1e9 +
+     	      		fr->uca_q[i]->data_array2->delay_dout_htree * 1e9  <<"; ";
+     	cout << endl;
+     } else {
+      cout << fr->data_array2->delay_subarray_output_driver * 1e9 +
+       fr->data_array2->delay_dout_htree * 1e9 << endl;
+     }
+ 
+     if (g_ip->is_cache && !g_ip->is_main_mem)
+     {
+       /* tag array stats */
+       cout << endl << "  Tag side (with Output driver) (ns): " ;
+ 
+       if(dvs) {
+     	  for (i = 0; i<dvs_levels; i++)
+     	    cout<<fr->uca_q[i]->tag_array2->access_time/1e-9  <<"; ";
+     	  cout << endl;
+       }
+       else {
+     	  cout << fr->tag_array2->access_time/1e-9 << endl;
+       }
+ 
+       if(dvs) {
+     	  cout <<  "\tH-tree input delay (ns): " ;
+           for (i = 0; i<dvs_levels; i++)
+         	  cout<<fr->uca_q[i]->tag_array2->delay_route_to_bank * 1e9  <<"; ";
+           cout << endl;
+ 
+       } else {
+     	  cout <<  "\tH-tree delay outside banks (ns) : " <<
+     	          fr->tag_array2->delay_route_to_bank * 1e9;
+       }
+ 
+       cout <<  "\tH-tree input delay (inside a bank) (ns) : ";
+ 	  if (dvs)
+ 	  {
+ 		for (i = 0; i<dvs_levels; i++)
+ 			cout<<fr->uca_q[i]->tag_array2->delay_input_htree * 1e9  <<"; ";
+ 	  }
+ 	  else {
+ 		cout <<  fr->tag_array2->delay_input_htree * 1e9;
+ 	  }
+ 	  cout << endl;
+ 
+ 	  if(dvs)
+ 	  {
+ 		  cout <<  "\tDecoder + wordline delay (ns): ";
+ 		  for (i = 0; i<dvs_levels; i++)
+ 		  cout << fr->uca_q[i]->tag_array2->delay_row_predecode_driver_and_block * 1e9 +
+ 		          fr->uca_q[i]->tag_array2->delay_row_decoder * 1e9 << ";";
+ 		  cout << endl;
+ 	  } else {
+ 		  cout <<  "\tDecoder + wordline delay (ns): " <<
+ 			fr->tag_array2->delay_row_predecode_driver_and_block * 1e9 +
+ 			fr->tag_array2->delay_row_decoder * 1e9 << endl;
+ 	  }
+ 
+       cout <<  "\tBitline delay (ns): ";
+       if(dvs) {
+ 		for (i = 0; i<dvs_levels; i++)
+ 			cout<<fr->uca_q[i]->tag_array2->delay_bitlines * 1e9  <<"; ";
+ 		cout << endl;
+       } else {
+        cout << fr->tag_array2->delay_bitlines/1e-9 << endl;
+       }
+ 
+       cout <<  "\tSense Amplifier delay (ns): ";
+       if(dvs) {
+        	for (i = 0; i<dvs_levels; i++)
+         	cout<<fr->uca_q[i]->tag_array2->delay_sense_amp * 1e9  <<"; ";
+     	 cout  << endl;
+       } else
+          cout << fr->tag_array2->delay_sense_amp * 1e9 << endl;
+ 
+       cout <<  "\tComparator delay (ns): ";
+       if(dvs) {
+ 		for (i = 0; i<dvs_levels; i++)
+ 			cout<<fr->uca_q[i]->tag_array2->delay_comparator * 1e9  <<"; ";
+ 		cout << endl;
+       } else {
+        cout << fr->tag_array2->delay_comparator * 1e9 << endl;
+       }
+ 
+       cout <<  "\tH-tree output delay (inside a bank) (ns): ";
+       if(dvs) {
+         	for (i = 0; i<dvs_levels; i++)
+         		cout<<fr->uca_q[i]->tag_array2->delay_subarray_output_driver * 1e9 +
+ 					fr->uca_q[i]->tag_array2->delay_dout_htree * 1e9  <<"; ";
+     	 cout << endl;
+       } else {
+         cout << fr->tag_array2->delay_subarray_output_driver * 1e9 +
+         fr->tag_array2->delay_dout_htree * 1e9 << endl;
+       }
+     }
+ 
+     /* Energy/Power stats */
+     cout << endl << endl << "Power Components:" << endl << endl;
+ 
+     if(dvs) {
+     	 cout << "  Data array: \n Total dynamic read energy/access  (nJ): " ;
+     	for (i = 0; i<dvs_levels; i++)
+     		cout <<  fr->uca_q[i]->data_array2->power.readOp.dynamic * 1e9 << "; ";
+     	cout << endl;
+     } else
+ 		cout << "  Data array: \n Total dynamic read energy/access  (nJ): " <<
+ 		  fr->data_array2->power.readOp.dynamic * 1e9 << endl;
+ 
+     if(dvs) {
+    		cout << "\tTotal leakage read/write power of a bank (mW): ";
+        	for (i = 0; i<dvs_levels; i++)
+        	cout <<fr->uca_q[i]->data_array2->power.readOp.leakage * 1e3 << "; ";
+        		 cout << endl;
+        } else
+     	   cout << "\tTotal leakage read/write power of a bank (mW): " <<
+         fr->data_array2->power.readOp.leakage * 1e3 << endl;
+ 
+     if(dvs) {
+     	cout << "\tTotal energy in H-tree outside banks (that includes both "
+     	      "address and data transfer) (nJ): ";
+        	for (i = 0; i<dvs_levels; i++)
+        		cout << (fr->uca_q[i]->data_array2->power_routing_to_bank.readOp.dynamic)*1e9 << "; ";
+        	cout << endl;
+        } else
+ 		cout << "\tTotal energy in H-tree outside banks (that includes both "
+ 		  "address and data transfer) (nJ): " <<
+ 			(/*fr->data_array2->power_addr_input_htree.readOp.dynamic +
+ 			 fr->data_array2->power_data_output_htree.readOp.dynamic +*/
+ 			 fr->data_array2->power_routing_to_bank.readOp.dynamic) * 1e9 << endl;
+ 
+     if(dvs) {
+     	cout << "\tInput H-tree inside bank Energy (nJ): " ;
+        	for (i = 0; i<dvs_levels; i++)
+        		cout <<  (fr->uca_q[i]->data_array2->power_addr_input_htree.readOp.dynamic) * 1e9 << "; ";
+        	cout << endl;
+        } else
+ 		cout << "\tInput H-tree inside bank Energy (nJ): " <<
+ 		(fr->data_array2->power_addr_input_htree.readOp.dynamic) * 1e9 << endl;
+ 
+     if(dvs) {
+     	 cout << "\tOutput Htree Energy inside bank Energy (nJ): " ;
+        	for (i = 0; i<dvs_levels; i++)
+        		cout <<  fr->uca_q[i]->data_array2->power_data_output_htree.readOp.dynamic * 1e9 << "; ";
+        	cout << endl;
+        } else
+ 		cout << "\tOutput Htree Energy inside bank Energy (nJ): " <<
+ 		  fr->data_array2->power_data_output_htree.readOp.dynamic * 1e9 << endl;
+ 
+     if(dvs) {
+     	 cout <<  "\tDecoder (nJ): " ;
+        	for (i = 0; i<dvs_levels; i++)
+        		cout <<  fr->uca_q[i]->data_array2->power_row_predecoder_drivers.readOp.dynamic * 1e9 +
+ 		      fr->uca_q[i]->data_array2->power_row_predecoder_blocks.readOp.dynamic * 1e9 << "; ";
+        	cout << endl;
+        } else
+ 		cout <<  "\tDecoder (nJ): " <<
+ 		  fr->data_array2->power_row_predecoder_drivers.readOp.dynamic * 1e9 +
+ 		  fr->data_array2->power_row_predecoder_blocks.readOp.dynamic * 1e9 << endl;
+ 
+     if(dvs) {
+     	cout <<  "\tWordline (nJ): ";
+        	for (i = 0; i<dvs_levels; i++)
+        		cout <<  fr->uca_q[i]->data_array2->power_row_decoders.readOp.dynamic * 1e9 <<  "; ";
+        	cout << endl;
+        } else
+ 		cout <<  "\tWordline (nJ): " <<
+ 		  fr->data_array2->power_row_decoders.readOp.dynamic * 1e9 << endl;
+ 
+     if(dvs) {
+     	cout <<  "\tBitline mux & associated drivers (nJ): ";
+        	for (i = 0; i<dvs_levels; i++)
+        		cout <<  fr->uca_q[i]->data_array2->power_bit_mux_predecoder_drivers.readOp.dynamic * 1e9 +
+ 		      fr->uca_q[i]->data_array2->power_bit_mux_predecoder_blocks.readOp.dynamic * 1e9 +
+ 		      fr->uca_q[i]->data_array2->power_bit_mux_decoders.readOp.dynamic * 1e9 << "; ";
+        	cout << endl;
+        } else
+ 		cout <<  "\tBitline mux & associated drivers (nJ): " <<
+ 		  fr->data_array2->power_bit_mux_predecoder_drivers.readOp.dynamic * 1e9 +
+ 		  fr->data_array2->power_bit_mux_predecoder_blocks.readOp.dynamic * 1e9 +
+ 		  fr->data_array2->power_bit_mux_decoders.readOp.dynamic * 1e9 << endl;
+ 
+     if(dvs) {
+     	cout <<  "\tSense amp mux & associated drivers (nJ): ";
+        	for (i = 0; i<dvs_levels; i++)
+        		cout <<  fr->uca_q[i]->data_array2->power_senseamp_mux_lev_1_predecoder_drivers.readOp.dynamic * 1e9 +
+ 		      fr->uca_q[i]->data_array2->power_senseamp_mux_lev_1_predecoder_blocks.readOp.dynamic * 1e9 +
+ 		      fr->uca_q[i]->data_array2->power_senseamp_mux_lev_1_decoders.readOp.dynamic * 1e9  +
+ 		      fr->uca_q[i]->data_array2->power_senseamp_mux_lev_2_predecoder_drivers.readOp.dynamic * 1e9 +
+ 		      fr->uca_q[i]->data_array2->power_senseamp_mux_lev_2_predecoder_blocks.readOp.dynamic * 1e9 +
+ 		      fr->uca_q[i]->data_array2->power_senseamp_mux_lev_2_decoders.readOp.dynamic * 1e9 << "; ";
+     	cout << endl;
+        } else
+ 		cout <<  "\tSense amp mux & associated drivers (nJ): " <<
+ 		  fr->data_array2->power_senseamp_mux_lev_1_predecoder_drivers.readOp.dynamic * 1e9 +
+ 		  fr->data_array2->power_senseamp_mux_lev_1_predecoder_blocks.readOp.dynamic * 1e9 +
+ 		  fr->data_array2->power_senseamp_mux_lev_1_decoders.readOp.dynamic * 1e9  +
+ 		  fr->data_array2->power_senseamp_mux_lev_2_predecoder_drivers.readOp.dynamic * 1e9 +
+ 		  fr->data_array2->power_senseamp_mux_lev_2_predecoder_blocks.readOp.dynamic * 1e9 +
+ 		  fr->data_array2->power_senseamp_mux_lev_2_decoders.readOp.dynamic * 1e9 << endl;
+ 
+     if(dvs) {
+     	cout <<  "\tBitlines (nJ): " ;
+        	for (i = 0; i<dvs_levels; i++)
+        		cout << fr->uca_q[i]->data_array2->power_bitlines.readOp.dynamic * 1e9 << "; ";
+        	cout << endl;
+        } else
+ 		cout <<  "\tBitlines (nJ): " <<
+ 		  fr->data_array2->power_bitlines.readOp.dynamic * 1e9 << endl;
+ 
+     if(dvs) {
+     	cout <<  "\tSense amplifier energy (nJ): " ;
+        	for (i = 0; i<dvs_levels; i++)
+        		cout <<   fr->uca_q[i]->data_array2->power_sense_amps.readOp.dynamic * 1e9 << "; ";
+        	cout << endl;
+        } else
+ 		cout <<  "\tSense amplifier energy (nJ): " <<
+ 		  fr->data_array2->power_sense_amps.readOp.dynamic * 1e9 << endl;
+ 
+     if(dvs) {
+     	 cout <<  "\tSub-array output driver (nJ): ";
+        	for (i = 0; i<dvs_levels; i++)
+        		cout <<  fr->uca_q[i]->data_array2->power_output_drivers_at_subarray.readOp.dynamic * 1e9 << "; ";
+        	cout << endl;
+        } else
+ 			cout <<  "\tSub-array output driver (nJ): " <<
+ 			  fr->data_array2->power_output_drivers_at_subarray.readOp.dynamic * 1e9 << endl;
+ 
+ 
+     if (g_ip->is_cache && !g_ip->is_main_mem)
+     {
+     	 if(dvs) {
+     		 cout << endl << "  Tag array: \n Total dynamic read energy/access (nJ): ";
+     	    	for (i = 0; i<dvs_levels; i++)
+     	    		cout <<  fr->uca_q[i]->tag_array2->power.readOp.dynamic * 1e9 << "; ";
+     	    	cout << endl;
+     	    } else
+ 				cout << endl << "  Tag array: \n Total dynamic read energy/access (nJ): " <<
+ 				fr->tag_array2->power.readOp.dynamic * 1e9 << endl;
+ 
+     	 if(dvs) {
+     		 cout << "\tTotal leakage read/write power of a bank (mW): " ;
+     	    	for (i = 0; i<dvs_levels; i++)
+     	    		cout <<  fr->uca_q[i]->tag_array2->power.readOp.leakage * 1e3 << "; ";
+     	    	cout << endl;
+     	    } else
+ 			  cout << "\tTotal leakage read/write power of a bank (mW): " <<
+ 				  fr->tag_array2->power.readOp.leakage * 1e3 << endl;
+ 
+     	 if(dvs) {
+     		 cout << "\tTotal energy in H-tree outside banks (that includes both "
+     		         "address and data transfer) (nJ): ";
+     	    	for (i = 0; i<dvs_levels; i++)
+     	    		cout <<  (fr->uca_q[i]->tag_array2->power_routing_to_bank.readOp.dynamic) * 1e9 << "; ";
+     	    	cout << endl;
+     	    } else
+ 			  cout << "\tTotal energy in H-tree outside banks (that includes both "
+ 				"address and data transfer) (nJ): " <<
+ 				  (/*fr->tag_array2->power_addr_input_htree.readOp.dynamic +
+ 				   fr->tag_array2->power_data_output_htree.readOp.dynamic +*/
+ 				   fr->tag_array2->power_routing_to_bank.readOp.dynamic) * 1e9 << endl;
+ 
+     	 if(dvs) {
+     		 cout << "\tInput H-tree inside banks Energy (nJ): " ;
+     	    	for (i = 0; i<dvs_levels; i++)
+     	    		cout <<  (fr->uca_q[i]->tag_array2->power_addr_input_htree.readOp.dynamic) * 1e9 << "; ";
+     	    	cout << endl;
+     	    } else
+ 			  cout << "\tInput H-tree inside banks Energy (nJ): " <<
+ 			   (fr->tag_array2->power_addr_input_htree.readOp.dynamic) * 1e9 << endl;
+ 
+     	 if(dvs) {
+     		 cout << "\tOutput Htree Energy (nJ): ";
+     	    	for (i = 0; i<dvs_levels; i++)
+     	    		cout <<   fr->uca_q[i]->tag_array2->power_data_output_htree.readOp.dynamic * 1e9 << "; ";
+     	    	cout << endl;
+     	    } else
+ 			  cout << "\tOutput Htree Energy (nJ): " <<
+ 				fr->tag_array2->power_data_output_htree.readOp.dynamic * 1e9 << endl;
+ 
+     	 if(dvs) {
+     		 cout <<  "\tDecoder (nJ): " ;
+     	    	for (i = 0; i<dvs_levels; i++)
+     	    		cout << fr->uca_q[i]->tag_array2->power_row_predecoder_drivers.readOp.dynamic * 1e9 +
+     	    		        fr->uca_q[i]->tag_array2->power_row_predecoder_blocks.readOp.dynamic * 1e9 << "; ";
+     	    	cout << endl;
+     	    } else
+ 			  cout <<  "\tDecoder (nJ): " <<
+ 				fr->tag_array2->power_row_predecoder_drivers.readOp.dynamic * 1e9 +
+ 				fr->tag_array2->power_row_predecoder_blocks.readOp.dynamic * 1e9 << endl;
+ 
+     	 if(dvs) {
+     		 cout <<  "\tWordline (nJ): " ;
+     	    	for (i = 0; i<dvs_levels; i++)
+     	    		cout << fr->uca_q[i]->tag_array2->power_row_decoders.readOp.dynamic * 1e9 << "; ";
+     	    	cout << endl;
+     	    } else
+ 			  cout <<  "\tWordline (nJ): " <<
+ 				fr->tag_array2->power_row_decoders.readOp.dynamic * 1e9 << endl;
+ 
+     	 if(dvs) {
+     		 cout <<  "\tBitline mux & associated drivers (nJ): " ;
+     	    	for (i = 0; i<dvs_levels; i++)
+ 					cout <<  fr->uca_q[i]->tag_array2->power_bit_mux_predecoder_drivers.readOp.dynamic * 1e9 +
+ 					fr->uca_q[i]->tag_array2->power_bit_mux_predecoder_blocks.readOp.dynamic * 1e9 +
+ 					fr->uca_q[i]->tag_array2->power_bit_mux_decoders.readOp.dynamic * 1e9 << "; ";
+     	    		 cout << endl;
+     	    } else
+ 			  cout <<  "\tBitline mux & associated drivers (nJ): " <<
+ 				fr->tag_array2->power_bit_mux_predecoder_drivers.readOp.dynamic * 1e9 +
+ 				fr->tag_array2->power_bit_mux_predecoder_blocks.readOp.dynamic * 1e9 +
+ 				fr->tag_array2->power_bit_mux_decoders.readOp.dynamic * 1e9 << endl;
+ 
+     	 if(dvs) {
+     		 cout <<  "\tSense amp mux & associated drivers (nJ): ";
+     	    	for (i = 0; i<dvs_levels; i++)
+     	    		cout << fr->uca_q[i]->tag_array2->power_senseamp_mux_lev_1_predecoder_drivers.readOp.dynamic * 1e9 +
+ 			        fr->uca_q[i]->tag_array2->power_senseamp_mux_lev_1_predecoder_blocks.readOp.dynamic * 1e9 +
+ 			        fr->uca_q[i]->tag_array2->power_senseamp_mux_lev_1_decoders.readOp.dynamic * 1e9  +
+ 			        fr->uca_q[i]->tag_array2->power_senseamp_mux_lev_2_predecoder_drivers.readOp.dynamic * 1e9 +
+ 			        fr->uca_q[i]->tag_array2->power_senseamp_mux_lev_2_predecoder_blocks.readOp.dynamic * 1e9 +
+ 			        fr->uca_q[i]->tag_array2->power_senseamp_mux_lev_2_decoders.readOp.dynamic * 1e9 << "; ";
+     	    	cout << endl;
+     	    } else
+ 			  cout <<  "\tSense amp mux & associated drivers (nJ): " <<
+ 				fr->tag_array2->power_senseamp_mux_lev_1_predecoder_drivers.readOp.dynamic * 1e9 +
+ 				fr->tag_array2->power_senseamp_mux_lev_1_predecoder_blocks.readOp.dynamic * 1e9 +
+ 				fr->tag_array2->power_senseamp_mux_lev_1_decoders.readOp.dynamic * 1e9  +
+ 				fr->tag_array2->power_senseamp_mux_lev_2_predecoder_drivers.readOp.dynamic * 1e9 +
+ 				fr->tag_array2->power_senseamp_mux_lev_2_predecoder_blocks.readOp.dynamic * 1e9 +
+ 				fr->tag_array2->power_senseamp_mux_lev_2_decoders.readOp.dynamic * 1e9 << endl;
+ 
+     	 if(dvs) {
+     		 cout <<  "\tBitlines (nJ): " ;
+     	    	for (i = 0; i<dvs_levels; i++)
+     	    		cout <<  fr->uca_q[i]->tag_array2->power_bitlines.readOp.dynamic * 1e9 << "; ";
+     	    	cout << endl;
+     	    } else
+ 			  cout <<  "\tBitlines (nJ): " <<
+ 				fr->tag_array2->power_bitlines.readOp.dynamic * 1e9 << endl;
+ 
+     	 if(dvs) {
+     		 cout <<  "\tSense amplifier energy (nJ): " ;
+     	    	for (i = 0; i<dvs_levels; i++)
+     	    		cout << fr->uca_q[i]->tag_array2->power_sense_amps.readOp.dynamic * 1e9 << "; ";
+     	    	cout << endl;
+     	    } else
+ 			  cout <<  "\tSense amplifier energy (nJ): " <<
+ 				fr->tag_array2->power_sense_amps.readOp.dynamic * 1e9 << endl;
+ 
+     	 if(dvs) {
+     		 cout <<  "\tSub-array output driver (nJ): " ;
+     	    	for (i = 0; i<dvs_levels; i++)
+     	    		cout <<   fr->uca_q[i]->tag_array2->power_output_drivers_at_subarray.readOp.dynamic * 1e9 << "; ";
+     	    	cout << endl;
+     	    } else
+ 			  cout <<  "\tSub-array output driver (nJ): " <<
+ 				fr->tag_array2->power_output_drivers_at_subarray.readOp.dynamic * 1e9 << endl;
+     }
+ 
+     cout << endl << endl <<  "Area Components:" << endl << endl;
+     /* Data array area stats */
+     if(dvs) {
+     	cout <<  "  Data array: \n Area (mm2): ";
+        	for (i = 0; i<dvs_levels; i++)
+        		cout << fr->uca_q[i]->data_array2->area * 1e-6 << "; ";
+        	cout << endl;
+        } else
+     	   cout <<  "  Data array: \n Area (mm2): " << fr->data_array2->area * 1e-6 << endl;
+ 
+     if(dvs) {
+     	 cout <<  "\tHeight (mm): ";
+        	for (i = 0; i<dvs_levels; i++)
+        		cout <<   fr->uca_q[i]->data_array2->all_banks_height*1e-3 << "; ";
+        	cout << endl;
+        } else
+ 		cout <<  "\tHeight (mm): " <<
+ 		  fr->data_array2->all_banks_height*1e-3 << endl;
+ 
+     if(dvs) {
+     	cout <<  "\tWidth (mm): ";
+        	for (i = 0; i<dvs_levels; i++)
+        		cout <<  fr->uca_q[i]->data_array2->all_banks_width*1e-3 << "; ";
+        	cout << endl;
+        } else
+ 		cout <<  "\tWidth (mm): " <<
+ 		  fr->data_array2->all_banks_width*1e-3 << endl;
+ 
+     if (g_ip->print_detail) {
+     	 if(dvs) {
+     		 cout <<  "\tArea efficiency (Memory cell area/Total area) : ";
+     	    	for (i = 0; i<dvs_levels; i++)
+     	    		cout << fr->uca_q[i]->data_array2->area_efficiency << " %" << "; ";
+     	    	cout << endl;
+     	    } else
+ 			  cout <<  "\tArea efficiency (Memory cell area/Total area) : " <<
+ 				fr->data_array2->area_efficiency << " %" << endl;
+ 
+     	 if(dvs) {
+     		 cout << "\t\tMAT Height (mm): " ;
+     	    	for (i = 0; i<dvs_levels; i++)
+     	    		cout << fr->uca_q[i]->data_array2->mat_height*1e-3 << "; ";
+     	    	cout << endl;
+     	    } else
+ 			  cout << "\t\tMAT Height (mm): " <<
+ 				fr->data_array2->mat_height*1e-3 << endl;
+ 
+     	 if(dvs) {
+     		 cout << "\t\tMAT Length (mm): ";
+     	    	for (i = 0; i<dvs_levels; i++)
+     	    		cout << fr->uca_q[i]->data_array2->mat_length*1e-3 << "; ";
+     	    	cout << endl;
+     	    } else
+ 			  cout << "\t\tMAT Length (mm): " <<
+ 				fr->data_array2->mat_length*1e-3 << endl;
+ 
+     	 if(dvs) {
+     		 cout << "\t\tSubarray Height (mm): ";
+     	    	for (i = 0; i<dvs_levels; i++)
+     	    		cout <<  fr->uca_q[i]->data_array2->subarray_height*1e-3 << "; ";
+     	    	cout << endl;
+     	    } else
+ 			  cout << "\t\tSubarray Height (mm): " <<
+ 				fr->data_array2->subarray_height*1e-3 << endl;
+ 
+     	 if(dvs) {
+     		 cout << "\t\tSubarray Length (mm): ";
+     	    	for (i = 0; i<dvs_levels; i++)
+     	    		cout << fr->uca_q[i]->data_array2->subarray_length*1e-3 << "; ";
+     	    	cout << endl;
+     	    } else
+ 			  cout << "\t\tSubarray Length (mm): " <<
+ 				fr->data_array2->subarray_length*1e-3 << endl;
+     }
+ 
+     /* Tag array area stats */
+     if (g_ip->is_cache && !g_ip->is_main_mem)
+     {
+     	 if(dvs) {
+     		 cout << endl << "  Tag array: \nArea (mm2): ";
+     	    	for (i = 0; i<dvs_levels; i++)
+     	    		cout << fr->uca_q[i]->tag_array2->area * 1e-6 << "; ";
+    	    		 cout << endl;
+     	    } else
+     	    	cout << endl << "  Tag array: \nArea (mm2): " << fr->tag_array2->area * 1e-6 << endl;
+ 
+     	 if(dvs) {
+     		 cout <<  "\tHeight (mm): " ;
+ 			for (i = 0; i<dvs_levels; i++)
+ 				cout << fr->uca_q[i]->tag_array2->all_banks_height*1e-3 << "; ";
+ 			cout << endl;
+     	    } else
+ 			  cout <<  "\tHeight (mm): " <<
+ 				fr->tag_array2->all_banks_height*1e-3 << endl;
+ 
+     	 if(dvs) {
+     		 cout <<  "\tWidth (mm): ";
+     	    	for (i = 0; i<dvs_levels; i++)
+     	    		cout << fr->uca_q[i]->tag_array2->all_banks_width*1e-3 << "; ";
+     	    	cout << endl;
+     	    } else
+ 			  cout <<  "\tWidth (mm): " <<
+ 				fr->tag_array2->all_banks_width*1e-3 << endl;
+ 
+       if (g_ip->print_detail)
+       {
+     	  if(dvs) {
+     		  cout <<  "\tArea efficiency (Memory cell area/Total area) : ";
+     	     	for (i = 0; i<dvs_levels; i++)
+     	     		cout <<  fr->uca_q[i]->tag_array2->area_efficiency << " %" << "; ";
+     	     	cout << endl;
+     	     } else
+ 				cout <<  "\tArea efficiency (Memory cell area/Total area) : " <<
+ 				  fr->tag_array2->area_efficiency << " %" << endl;
+ 
+     	  if(dvs) {
+     		  cout << "\t\tMAT Height (mm): " ;
+     	     	for (i = 0; i<dvs_levels; i++)
+     	     		cout <<  fr->uca_q[i]->tag_array2->mat_height*1e-3 << "; ";
+     	     	cout << endl;
+     	     } else
+ 				cout << "\t\tMAT Height (mm): " <<
+ 				  fr->tag_array2->mat_height*1e-3 << endl;
+ 
+     	  if(dvs) {
+     		  cout << "\t\tMAT Length (mm): " ;
+     	     	for (i = 0; i<dvs_levels; i++)
+     	     		cout <<  fr->uca_q[i]->tag_array2->mat_length*1e-3 << "; ";
+     	     	cout << endl;
+     	     } else
+ 				cout << "\t\tMAT Length (mm): " <<
+ 				  fr->tag_array2->mat_length*1e-3 << endl;
+ 
+     	  if(dvs) {
+     		  cout << "\t\tSubarray Height (mm): ";
+     	     	for (i = 0; i<dvs_levels; i++)
+     	     		cout <<  fr->uca_q[i]->tag_array2->subarray_height*1e-3 << "; ";
+     		  cout << endl;
+     	     } else
+ 				cout << "\t\tSubarray Height (mm): " <<
+ 				  fr->tag_array2->subarray_height*1e-3 << endl;
+ 
+     	  if(dvs) {
+     		  cout << "\t\tSubarray Length (mm): ";
+     	     	for (i = 0; i<dvs_levels; i++)
+     	     		cout << fr->uca_q[i]->tag_array2->subarray_length*1e-3 << "; ";
+     	     	cout << endl;
+     	     } else
+ 				cout << "\t\tSubarray Length (mm): " <<
+ 				  fr->tag_array2->subarray_length*1e-3 << endl;
+       }
+     }
+ 
+ 
+     //Wire wpr; //TODO: this must change, since this changes the wire value during dvs loop.
+     //Wire::print_wire();//move outside output UCA
+   }
+ }
+ //Divya end
  
  /***** Alireza - BEGIN *****/
  void output_summary_of_results(uca_org_t *fr) {
***************
*** 1539,1546 ****
    cout << "Cache size        : " << cache_size << cache_size_unit << endl; // unit. -Alireza
    cout << "Technology        : " << g_ip->F_sz_nm << "nm" << endl; // changed to nm. -Alireza
    cout << "Transistor type   : " << (g_ip->is_finfet ? "FinFET" : "CMOS" ) << endl; // Alireza
!   cout << "Operating voltage : " << (g_ip->is_near_threshold ? "Near-threshold" : "Super-threshold" ) << endl; // Alireza
!   if (g_ip->sram_cell_design.getType()==std_6T) { // Alireza
      cout << "SRAM cell type    : " << "Standard 6T" << endl;
    } else if (g_ip->sram_cell_design.getType()==std_8T) {
      cout << "SRAM cell type    : " << "Standard 8T" << endl;
--- 2493,2501 ----
    cout << "Cache size        : " << cache_size << cache_size_unit << endl; // unit. -Alireza
    cout << "Technology        : " << g_ip->F_sz_nm << "nm" << endl; // changed to nm. -Alireza
    cout << "Transistor type   : " << (g_ip->is_finfet ? "FinFET" : "CMOS" ) << endl; // Alireza
! //  cout << "Operating voltage : " << (g_ip->is_near_threshold ? "Near-threshold" : "Super-threshold" ) << endl; // Alireza
!   cout << "Operating voltage             : " << g_ip->vdd << endl; // Alireza
!    if (g_ip->sram_cell_design.getType()==std_6T) { // Alireza
      cout << "SRAM cell type    : " << "Standard 6T" << endl;
    } else if (g_ip->sram_cell_design.getType()==std_8T) {
      cout << "SRAM cell type    : " << "Standard 8T" << endl;
diff -crB pcacti_xml/main.cc fncacti/main.cc
*** pcacti_xml/main.cc	2014-07-03 13:17:14.000000000 +0530
--- fncacti/main.cc	2020-11-15 23:14:15.595399000 +0530
***************
*** 134,140 ****
                               atoi(argv[53]),
                               atoi(argv[54]));
    }
!   
  
    return 0;
  }
--- 134,140 ----
                               atoi(argv[53]),
                               atoi(argv[54]));
    }
!   result.cleanup();
  
    return 0;
  }
diff -crB pcacti_xml/mat.cc fncacti/mat.cc
*** pcacti_xml/mat.cc	2014-07-03 13:18:20.000000000 +0530
--- fncacti/mat.cc	2021-08-27 16:48:44.135624706 +0530
***************
*** 302,308 ****
  
    if (!is_fa) 
    {
!     area.h = (num_subarrays_per_mat / num_subarrays_per_row) * subarray.area.get_h() + h_non_cell_area;
      area.w = num_subarrays_per_row * subarray.area.get_w() + w_non_cell_area;
      area.w = (area.h*area.w + area_mat_center_circuitry) / area.h;
      area_efficiency_mat = subarray.area.get_area() * num_subarrays_per_mat * 100.0 / area.get_area();
--- 304,311 ----
  
    if (!is_fa) 
    {
! 
! 	area.h = (num_subarrays_per_mat / num_subarrays_per_row) * subarray.area.get_h() + h_non_cell_area;
      area.w = num_subarrays_per_row * subarray.area.get_w() + w_non_cell_area;
      area.w = (area.h*area.w + area_mat_center_circuitry) / area.h;
      area_efficiency_mat = subarray.area.get_area() * num_subarrays_per_mat * 100.0 / area.get_area();
***************
*** 670,679 ****
      ///double Icell = cmos_Ileak(g_tp.sram.cell_nmos_w, g_tp.sram.cell_pmos_w, false, true);
      ///leak_power_cc_inverters_sram_cell = Icell * g_tp.sram_cell.Vdd;
      ///leak_power_acc_tr_RW_or_WR_port_sram_cell = Iport * g_tp.sram_cell.Vdd;
!     leak_power_cc_inverters_sram_cell = 
!       g_ip->sram_cell_design.getPleakCCInv(g_tp.sram_cell.Vdd, g_tp.sram_cell.H_fin);
      leak_power_acc_tr_RW_or_WR_port_sram_cell = 
!       g_ip->sram_cell_design.getPleakAccTx(g_tp.sram_cell.Vdd, g_tp.sram_cell.H_fin);
      // Alireza - End
      leak_power_RD_port_sram_cell = 
        leak_power_acc_tr_RW_or_WR_port_sram_cell * NAND2_LEAK_STACK_FACTOR;
--- 669,682 ----
      ///double Icell = cmos_Ileak(g_tp.sram.cell_nmos_w, g_tp.sram.cell_pmos_w, false, true);
      ///leak_power_cc_inverters_sram_cell = Icell * g_tp.sram_cell.Vdd;
      ///leak_power_acc_tr_RW_or_WR_port_sram_cell = Iport * g_tp.sram_cell.Vdd;
! 
! 
! 	leak_power_cc_inverters_sram_cell =
!  //     g_ip->sram_cell_design.getPleakCCInv(g_tp.sram_cell.Vdd, g_tp.sram_cell.H_fin);
!   		 g_ip->sram_cell_design.getPleakCCInv(g_tp.sram_cell.Vdd, g_tp.sram_cell.H_fin, g_tp.sram_cell.W_fin); //Divya changing this as W_fin != 2*H_fin and W_fin value is given
      leak_power_acc_tr_RW_or_WR_port_sram_cell = 
!   //    g_ip->sram_cell_design.getPleakAccTx(g_tp.sram_cell.Vdd, g_tp.sram_cell.H_fin);
!         g_ip->sram_cell_design.getPleakAccTx(g_tp.sram_cell.Vdd, g_tp.sram_cell.H_fin, g_tp.sram_cell.W_fin);   //Divya changing this as W_fin != 2*H_fin and W_fin value is given
      // Alireza - End
      leak_power_RD_port_sram_cell = 
        leak_power_acc_tr_RW_or_WR_port_sram_cell * NAND2_LEAK_STACK_FACTOR;
***************
*** 995,1001 ****
    // calculate leakage power
    if (is_fa == false || dp.is_tag == false)
    { // if fully associative cache and tag array, don't add the following components of leakage power
!     power_bitline.readOp.leakage            *= subarray.num_rows * subarray.num_cols * num_subarrays_per_mat;
      power_bl_precharge_eq_drv.readOp.leakage = bl_precharge_eq_drv->power.readOp.leakage * num_subarrays_per_mat;
      power_sa.readOp.leakage                 *= (RWP + ERP);
  
--- 999,1007 ----
    // calculate leakage power
    if (is_fa == false || dp.is_tag == false)
    { // if fully associative cache and tag array, don't add the following components of leakage power
! 
! 
! 	power_bitline.readOp.leakage            *= subarray.num_rows * subarray.num_cols * num_subarrays_per_mat;
      power_bl_precharge_eq_drv.readOp.leakage = bl_precharge_eq_drv->power.readOp.leakage * num_subarrays_per_mat;
      power_sa.readOp.leakage                 *= (RWP + ERP);
  
diff -crB pcacti_xml/parameter.cc fncacti/parameter.cc
*** pcacti_xml/parameter.cc	2014-07-03 13:18:52.000000000 +0530
--- fncacti/parameter.cc	2021-08-27 21:39:27.461039123 +0530
***************
*** 58,66 ****
  {
    string indent_str(indent, ' ');
  
!   cout << indent_str << "C_g_ideal = " << setw(12) << C_g_ideal << " F/um" << endl;
!   cout << indent_str << "C_fringe  = " << setw(12) << C_fringe  << " F/um" << endl;
!   cout << indent_str << "C_overlap = " << setw(12) << C_overlap << " F/um" << endl;
    cout << indent_str << "C_junc    = " << setw(12) << C_junc    << " F/um^2" << endl;
    cout << indent_str << "l_phy     = " << setw(12) << l_phy     << " um" << endl;
    cout << indent_str << "l_elec    = " << setw(12) << l_elec    << " um" << endl;
--- 58,66 ----
  {
    string indent_str(indent, ' ');
  
!   cout << indent_str << "C_g_ideal = " << setw(12) << C_g_ideal << " F" << endl;
!   cout << indent_str << "C_fringe  = " << setw(12) << C_fringe  << " F" << endl;
!   cout << indent_str << "C_overlap = " << setw(12) << C_overlap << " F" << endl;
    cout << indent_str << "C_junc    = " << setw(12) << C_junc    << " F/um^2" << endl;
    cout << indent_str << "l_phy     = " << setw(12) << l_phy     << " um" << endl;
    cout << indent_str << "l_elec    = " << setw(12) << l_elec    << " um" << endl;
***************
*** 68,78 ****
    cout << indent_str << "R_pch_on  = " << setw(12) << R_pch_on  << " ohm-um" << endl;
    cout << indent_str << "Vdd       = " << setw(12) << Vdd       << " V" << endl;
    cout << indent_str << "Vth       = " << setw(12) << Vth       << " V" << endl;
!   cout << indent_str << "I_on_n    = " << setw(12) << I_on_n    << " A/um" << endl;
!   cout << indent_str << "I_on_p    = " << setw(12) << I_on_p    << " A/um" << endl;
!   cout << indent_str << "I_off_n   = " << setw(12) << I_off_n   << " A/um" << endl;
!   cout << indent_str << "I_off_p   = " << setw(12) << I_off_p   << " A/um" << endl;
!   cout << indent_str << "C_ox      = " << setw(12) << C_ox      << " F/um^2" << endl;
    cout << indent_str << "t_ox      = " << setw(12) << t_ox      << " um" << endl;
    cout << indent_str << "n_to_p_eff_curr_drv_ratio = " << n_to_p_eff_curr_drv_ratio << endl;
  }
--- 68,78 ----
    cout << indent_str << "R_pch_on  = " << setw(12) << R_pch_on  << " ohm-um" << endl;
    cout << indent_str << "Vdd       = " << setw(12) << Vdd       << " V" << endl;
    cout << indent_str << "Vth       = " << setw(12) << Vth       << " V" << endl;
!   cout << indent_str << "I_on_n    = " << setw(12) << I_on_n    << " A" << endl;
!   cout << indent_str << "I_on_p    = " << setw(12) << I_on_p    << " A" << endl;
!   cout << indent_str << "I_off_n   = " << setw(12) << I_off_n   << " A" << endl;
!   cout << indent_str << "I_off_p   = " << setw(12) << I_off_p   << " A" << endl;
!   cout << indent_str << "C_ox      = " << setw(12) << C_ox      << " F/um" << endl;
    cout << indent_str << "t_ox      = " << setw(12) << t_ox      << " um" << endl;
    cout << indent_str << "n_to_p_eff_curr_drv_ratio = " << n_to_p_eff_curr_drv_ratio << endl;
  }
***************
*** 238,250 ****
    // is formed out of two horizontal subarrays and two vertical subarrays
    if (fully_assoc == false && (Ndwl < 1 || Ndbl < 1))
    {
      return;
    }
  
    // if data array, let tagbits = 0
    if (is_tag)
    {
!     if (g_ip->specific_tag)
      {
        tagbits = g_ip->tag_w;
      }
--- 237,252 ----
    // is formed out of two horizontal subarrays and two vertical subarrays
    if (fully_assoc == false && (Ndwl < 1 || Ndbl < 1))
    {
+ 	if(is_tag)
+ 	cout << "Ndwl : " << Ndwl << ", Ndbl : " << Ndbl << endl;
+ 
      return;
    }
  
    // if data array, let tagbits = 0
    if (is_tag)
    {
! 	if (g_ip->specific_tag)
      {
        tagbits = g_ip->tag_w;
      }
***************
*** 273,279 ****
              g_ip->block_sz * g_ip->tag_assoc * Ndbl * Nspd) + EPSILON);
        num_c_subarray = (int)((tagbits * g_ip->tag_assoc * Nspd / Ndwl) + EPSILON);
      }
!     //burst_length = 1;
    }
    else
    {
--- 275,281 ----
              g_ip->block_sz * g_ip->tag_assoc * Ndbl * Nspd) + EPSILON);
        num_c_subarray = (int)((tagbits * g_ip->tag_assoc * Nspd / Ndwl) + EPSILON);
      }
! 
    }
    else
    {
***************
*** 288,294 ****
              g_ip->block_sz * g_ip->data_assoc * Ndbl * Nspd) + EPSILON);
        num_c_subarray = (int)((8 * g_ip->block_sz * g_ip->data_assoc * Nspd / Ndwl) + EPSILON);
      }
!     // burst_length = g_ip->block_sz * 8 / g_ip->out_w;
    }    
  
    if ((!fully_assoc)&&(num_r_subarray < MINSUBARRAYROWS)) return;
--- 290,296 ----
              g_ip->block_sz * g_ip->data_assoc * Ndbl * Nspd) + EPSILON);
        num_c_subarray = (int)((8 * g_ip->block_sz * g_ip->data_assoc * Nspd / Ndwl) + EPSILON);
      }
!    // burst_length = g_ip->block_sz * 8 / g_ip->out_w;
    }    
  
    if ((!fully_assoc)&&(num_r_subarray < MINSUBARRAYROWS)) return;
***************
*** 483,489 ****
      return;
    }
  
!   if (num_act_mats_hor_dir > num_mats_h_dir) 
    {
      return;
    }
--- 486,492 ----
      return;
    }
  
!   if (num_act_mats_hor_dir > num_mats_h_dir) //Original
    {
      return;
    }
diff -crB pcacti_xml/parameter.h fncacti/parameter.h
*** pcacti_xml/parameter.h	2014-07-03 13:18:42.000000000 +0530
--- fncacti/parameter.h	2020-12-10 15:48:53.031806000 +0530
***************
*** 58,64 ****
--- 58,66 ----
      double P_fin; // in um, for FinFET devices. -Alireza
      double H_fin; // in um, for FinFET devices. -Alireza
      double T_si;  // in um, for FinFET devices. -Alireza
+     double W_fin;	//Divya added
      double C_g_ideal;
+ 
      double C_fringe;
      double C_overlap;
      double C_junc;  // C_junc_area
***************
*** 77,83 ****
      double t_ox;
      double n_to_p_eff_curr_drv_ratio;
  
!     DeviceType(): P_fin(0), H_fin(0), T_si(0), C_g_ideal(0),
                    C_fringe(0), C_overlap(0), C_junc(0), C_junc_sidewall(0),
                    l_phy(0), l_elec(0), R_nch_on(0), R_pch_on(0), Vdd(0), Vth(0),
                    I_on_n(0), I_on_p(0), I_off_n(0), I_off_p(0),
--- 80,86 ----
      double t_ox;
      double n_to_p_eff_curr_drv_ratio;
  
!     DeviceType(): P_fin(0), H_fin(0), T_si(0), W_fin(0), C_g_ideal(0),
                    C_fringe(0), C_overlap(0), C_junc(0), C_junc_sidewall(0),
                    l_phy(0), l_elec(0), R_nch_on(0), R_pch_on(0), Vdd(0), Vth(0),
                    I_on_n(0), I_on_p(0), I_off_n(0), I_off_p(0),
***************
*** 87,92 ****
--- 90,96 ----
        P_fin     = 0;
        H_fin     = 0;
        T_si      = 0;
+       W_fin 	= 0;	//Divya added
        C_g_ideal = 0;
        C_fringe  = 0;
        C_overlap = 0;
***************
*** 104,110 ****
        C_ox      = 0;
        t_ox      = 0;
        n_to_p_eff_curr_drv_ratio = 0;
!     }
  
      void display(uint32_t indent = 0);
    };
--- 108,114 ----
        C_ox      = 0;
        t_ox      = 0;
        n_to_p_eff_curr_drv_ratio = 0;
!      }
  
      void display(uint32_t indent = 0);
    };
Only in fncacti: pcacti_report.txt
Only in fncacti: .project
Only in fncacti: run.sh
Only in fncacti: .settings
diff -crB pcacti_xml/subarray.cc fncacti/subarray.cc
*** pcacti_xml/subarray.cc	2014-07-03 13:18:34.000000000 +0530
--- fncacti/subarray.cc	2021-08-27 16:51:40.541875723 +0530
***************
*** 162,167 ****
--- 163,169 ----
  
  double Subarray::get_total_cell_area()
  {
+ //	cout << dp.is_tag << ", cell.h :" << cell.h << ", cell.w : " << cell.w << ", cell_area : " << cell.get_area() << endl;
    return cell.get_area() * num_rows * num_cols;
  }
  
***************
*** 194,199 ****
--- 196,212 ----
      C_rwl = (gate_C_pass(g_tp.sram.cell_rd_a_w, 0, false, true) + c_w_metal) * num_cols; // Alireza
      C_wl = (gate_C_pass(g_tp.sram.cell_a_w, (g_tp.sram.b_w-2*g_tp.sram.cell_a_w)/2.0, false, true)*2 + c_w_metal) * num_cols;
      C_b_row_drain_C = drain_C_(g_tp.sram.cell_a_w, NCH, 1, 0, cell.w, false, true) / 2.0;  // due to shared contact
+ 
+     if(ceil(g_tp.sram.cell_rd_a_w/g_tp.min_w_nmos_) > 1)
+     	cout << "Subarray::compute_C():: gate_C_pass : g_tp.sram.cell_rd_a_w : "<< g_tp.sram.cell_rd_a_w << ", g_tp.min_w_nmos_ : "  << g_tp.min_w_nmos_ << endl;
+ 
+     if(ceil(g_tp.sram.cell_a_w/g_tp.min_w_nmos_) > 1)
+         	cout << "Subarray::compute_C():: gate_C_pass : g_tp.sram.cell_a_w : "<< g_tp.sram.cell_a_w << ", g_tp.min_w_nmos_ : "  << g_tp.min_w_nmos_ << endl;
+ 
+     if(ceil(g_tp.sram.cell_a_w/g_tp.min_w_nmos_) > 1)
+         	cout << "Subarray::compute_C():: drain_C_ : g_tp.sram.cell_a_w : "<< g_tp.sram.cell_a_w << ", g_tp.min_w_nmos_ : "  << g_tp.min_w_nmos_ << endl;
+ 
+ 
      C_bl = num_rows * (C_b_row_drain_C + C_b_metal);
    }
  }
diff -crB pcacti_xml/technology.cc fncacti/technology.cc
*** pcacti_xml/technology.cc	2014-07-03 13:19:14.000000000 +0530
--- fncacti/technology.cc	2021-08-27 16:56:05.011014168 +0530
***************
*** 67,73 ****
  }
  
  
! void init_tech_params(double technology, bool is_tag)
  {
  	int    iter, tech, tech_lo, tech_hi;
  	double curr_alpha, curr_vpp;
--- 67,73 ----
  }
  
  
! void init_tech_params(double technology, double wire_technology, bool is_tag) //Divya added wire_technology
  {
  	int    iter, tech, tech_lo, tech_hi;
  	double curr_alpha, curr_vpp;
***************
*** 81,86 ****
--- 81,87 ----
  	//uint32_t peri_global_tech_type = (is_tag) ? g_ip->tag_arr_peri_global_tech_type : g_ip->data_arr_peri_global_tech_type;
  
  	technology  = technology * 1000.0;  // in the unit of nm
+ 	wire_technology = wire_technology * 1000.0;	//in the unit of nm //Divya added
  
  	// initialize parameters
  	g_tp.reset();
***************
*** 148,163 ****
  	double vdd_cell, vdd_peri;
  	double Lphy, Xj, delta_L, Lelec, t_ox;
  	double p_fin, h_fin, t_si;
  	double v_th, Vdsat;
  	double c_junc, c_junc_sidewall, c_junc_sidewall_gate;
! 	double c_ox, c_g_ideal, c_fringe;
  	double I_on_n, I_on_p, I_off_n, I_off_p;
  	double Rnchannelon, Rpchannelon;
  	double n_to_p_eff_curr_drv_ratio;
  	double vbit_sense_min;
  	double mobility_eff, gmp_to_gmn_multiplier;
  	//---------- Majid - END ------------
!   
    
  	for (iter = 0; iter <= 1; ++iter) {
  		// linear interpolation
--- 149,166 ----
  	double vdd_cell, vdd_peri;
  	double Lphy, Xj, delta_L, Lelec, t_ox;
  	double p_fin, h_fin, t_si;
+ 	double w_fin;	//newly added by Divya.
  	double v_th, Vdsat;
  	double c_junc, c_junc_sidewall, c_junc_sidewall_gate;
! 	double c_ox, c_g_ideal, c_fringe, c_gate; //c_gate added newly by Divya
  	double I_on_n, I_on_p, I_off_n, I_off_p;
  	double Rnchannelon, Rpchannelon;
  	double n_to_p_eff_curr_drv_ratio;
  	double vbit_sense_min;
  	double mobility_eff, gmp_to_gmn_multiplier;
+ 	double I_on_n_to_I_on_p_ratio; //newly added by Divya
  	//---------- Majid - END ------------
! 
    
  	for (iter = 0; iter <= 1; ++iter) {
  		// linear interpolation
***************
*** 185,212 ****
      // Source: Shuang Chen, USC.
      if (tech == 14 && !g_ip->is_finfet) {
        Lphy_dram = 0.014;
!       curr_vdd_dram_cell = ((g_ip->is_near_threshold) ? 0.55 : 0.8);
!       c_ox_dram = 3.52e-14;
!       c_fringe_dram = 0.8e-16;
!       c_junc_dram = 0.5e-15;
!       I_on_n_dram = ((g_ip->is_near_threshold) ? 1.155e-04 : 8.367e-04);
!       I_on_p_dram = ((g_ip->is_near_threshold) ? 8.618e-05 : 5.012e-04);
!       I_off_n_dram = ((g_ip->is_near_threshold) ? 3.282e-08 : 9.662e-08);
!       I_off_p_dram = ((g_ip->is_near_threshold) ? 3.460e-08 : 1.095e-07);
      }
      
      // Standard 7nm (gate length) FinFET based on TCAD.
      // Source: Shuang Chen, USC.
!     if (tech == 7 && g_ip->is_finfet) {
!       Lphy_dram = 0.007;
!       curr_vdd_dram_cell = ((g_ip->is_near_threshold) ? 0.3 : 0.45);
!       c_ox_dram = 4.73e-14;
!       c_fringe_dram = 0.8e-16;
!       c_junc_dram = 0.5e-15;
! 		I_on_n_dram = ((g_ip->is_near_threshold) ? 2.845e-04 : 1.716e-03);
!       I_on_p_dram = ((g_ip->is_near_threshold) ? 2.610e-04 : 1.075e-03);
!       I_off_n_dram = ((g_ip->is_near_threshold) ? 6.355e-08 : 6.890e-08);
!       I_off_p_dram = ((g_ip->is_near_threshold) ? 1.027e-07 : 1.040e-07);
      }
      /****** Alireza - END ******/
  	 
--- 188,230 ----
      // Source: Shuang Chen, USC.
      if (tech == 14 && !g_ip->is_finfet) {
        Lphy_dram = 0.014;
!       //     curr_vdd_dram_cell = ((g_ip->is_near_threshold) ? 0.55 : 0.8);
!            curr_vdd_dram_cell = 0.8;	//Divya changed as near threshold or super threshold not valid anymore
!            c_ox_dram = 3.52e-14;
!            c_fringe_dram = 0.8e-16;
!            c_junc_dram = 0.5e-15;
!      /*      I_on_n_dram = ((g_ip->is_near_threshold) ? 1.155e-04 : 8.367e-04);
!            I_on_p_dram = ((g_ip->is_near_threshold) ? 8.618e-05 : 5.012e-04);
!            I_off_n_dram = ((g_ip->is_near_threshold) ? 3.282e-08 : 9.662e-08);
!            I_off_p_dram = ((g_ip->is_near_threshold) ? 3.460e-08 : 1.095e-07);
!       */
!            //Divya changed as near threshold or super threshold not valid anymore
!            I_on_n_dram = 8.367e-04;
!      	   I_on_p_dram = 5.012e-04;
!      	   I_off_n_dram = 9.662e-08;
!      	   I_off_p_dram = 1.095e-07;
      }
      
      // Standard 7nm (gate length) FinFET based on TCAD.
      // Source: Shuang Chen, USC.
!     if (tech == 7 && g_ip->is_finfet)
!     {
!     	Lphy_dram = 0.007;
!     	//     curr_vdd_dram_cell = ((g_ip->is_near_threshold) ? 0.3 : 0.45); //Divya changed as near threshold or super threshold not valid anymore
!     	    	curr_vdd_dram_cell = 0.45;
!     	      c_ox_dram = 4.73e-14;
!     	      c_fringe_dram = 0.8e-16;
!     	      c_junc_dram = 0.5e-15;
!     	/*		I_on_n_dram = ((g_ip->is_near_threshold) ? 2.845e-04 : 1.716e-03);
!     	      I_on_p_dram = ((g_ip->is_near_threshold) ? 2.610e-04 : 1.075e-03);
!     	      I_off_n_dram = ((g_ip->is_near_threshold) ? 6.355e-08 : 6.890e-08);
!     	      I_off_p_dram = ((g_ip->is_near_threshold) ? 1.027e-07 : 1.040e-07);
!     	 */
!     	      //Divya changed as near threshold or super threshold not valid anymore
!     	      I_on_n_dram = 1.716e-03;
!     			I_on_p_dram = 1.075e-03;
!     			I_off_n_dram = 6.890e-08;
!     			I_off_p_dram = 1.040e-07;
      }
      /****** Alireza - END ******/
  	 
***************
*** 241,259 ****
  			} else {
  				p_fin = (2 * lambda_um) + t_si;
  			}
  		}
  		
  		voltages_node = root_node.getChildNode("voltages");
! 		strcpy(temp_var,voltages_node.getChildNode("v_th").getText(0));
  		sscanf(temp_var, "%lf", &(v_th));
! 		if ( g_ip->is_near_threshold ) {
! 			strcpy(temp_var,voltages_node.getChildNode("vdd").getChildNode("near_threshold").getText(0));
! 			sscanf(temp_var, "%lf", &(vdd_cell));
! 		} else {
! 			strcpy(temp_var,voltages_node.getChildNode("vdd").getChildNode("super_threshold").getText(0));
! 			sscanf(temp_var, "%lf", &(vdd_cell));
! 		}
! 		
  		cap_node = root_node.getChildNode("capacitances");
  		strcpy(temp_var,cap_node.getChildNode("c_ox").getText(0));
  		sscanf(temp_var, "%lf", &(c_ox));
--- 259,278 ----
  			} else {
  				p_fin = (2 * lambda_um) + t_si;
  			}
+ 			strcpy(temp_var,geometry_node.getChildNode("FinFET").getChildNode("w_fin").getText(0));
+ 			sscanf(temp_var, "%lf", &(w_fin));
  		}
  		
  		voltages_node = root_node.getChildNode("voltages");
! // Divya Modifying begin : near threshold and super threshold not valid for ncfet--
! 		vdd_cell = g_ip->vdd;
! 		char volt[10];
! 		sprintf(volt,"%.1f",vdd_cell);
! 
! 		strcpy(temp_var,voltages_node.getChildNode("v_th").getChildNodeWithAttribute("volt","val",volt).getText(0)); //Vth(V)
  		sscanf(temp_var, "%lf", &(v_th));
! 		// Divya Modifying end --
! 
  		cap_node = root_node.getChildNode("capacitances");
  		strcpy(temp_var,cap_node.getChildNode("c_ox").getText(0));
  		sscanf(temp_var, "%lf", &(c_ox));
***************
*** 265,343 ****
  		sscanf(temp_var, "%lf", &(c_junc));
  		strcpy(temp_var,cap_node.getChildNode("c_fringe").getText(0));
  		sscanf(temp_var, "%lf", &(c_fringe));
! 		
  		senseAmp_node = root_node.getChildNode("sense_amplifier");
! 		if ( g_ip->is_near_threshold ) {
! 			strcpy(temp_var,senseAmp_node.getChildNode("delay").getChildNode("near_threshold").getText(0));
  			sscanf(temp_var, "%lf", &(SENSE_AMP_D));
! 			strcpy(temp_var,senseAmp_node.getChildNode("energy").getChildNode("near_threshold").getText(0));
  			sscanf(temp_var, "%lf", &(SENSE_AMP_P));
! 		} else {
! 			strcpy(temp_var,senseAmp_node.getChildNode("delay").getChildNode("super_threshold").getText(0));
! 			sscanf(temp_var, "%lf", &(SENSE_AMP_D));
! 			strcpy(temp_var,senseAmp_node.getChildNode("energy").getChildNode("super_threshold").getText(0));
! 			sscanf(temp_var, "%lf", &(SENSE_AMP_P));
! 		}
  
  		char temperature[10];
! 		sprintf(temperature,"%d",g_ip->temp);
! 		NMOS_ONcurrents_node = root_node.getChildNode("currents").getChildNode("ON_current").getChildNode("NMOS");
! 		if ( g_ip->is_near_threshold ) {
! 			strcpy(temp_var,NMOS_ONcurrents_node.getChildNode("near_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 			sscanf(temp_var, "%lf", &(I_on_n));
! 		} else {
! 			strcpy(temp_var,NMOS_ONcurrents_node.getChildNode("super_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
  			sscanf(temp_var, "%lf", &(I_on_n));
- 		}
  
! 		PMOS_ONcurrents_node = root_node.getChildNode("currents").getChildNode("ON_current").getChildNode("PMOS");
! 		if ( g_ip->is_near_threshold ) {
! 			strcpy(temp_var,PMOS_ONcurrents_node.getChildNode("near_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 			sscanf(temp_var, "%lf", &(I_on_p));
! 		} else {
! 			strcpy(temp_var,PMOS_ONcurrents_node.getChildNode("super_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
  			sscanf(temp_var, "%lf", &(I_on_p));
- 		}
  
! 		NMOS_OFFcurrents_node = root_node.getChildNode("currents").getChildNode("OFF_current").getChildNode("NMOS");
! 		if ( g_ip->is_near_threshold ) {
! 			strcpy(temp_var,NMOS_OFFcurrents_node.getChildNode("near_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 			sscanf(temp_var, "%lf", &(I_off_n));
! 		} else {
! 			strcpy(temp_var,NMOS_OFFcurrents_node.getChildNode("super_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
  			sscanf(temp_var, "%lf", &(I_off_n));
- 		}
  
! 		PMOS_OFFcurrents_node = root_node.getChildNode("currents").getChildNode("OFF_current").getChildNode("PMOS");
! 		if ( g_ip->is_near_threshold ) {
! 			strcpy(temp_var,PMOS_OFFcurrents_node.getChildNode("near_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 			sscanf(temp_var, "%lf", &(I_off_p));
! 		} else {
! 			strcpy(temp_var,PMOS_OFFcurrents_node.getChildNode("super_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
  			sscanf(temp_var, "%lf", &(I_off_p));
! 		}
  		//---------- Majid - END ------------
  
  		/***** Alireza - BEGIN *****/
! 		if (g_ip->is_finfet) {
  			vbit_sense_min = 0.04;
  			g_tp.sram_cell.P_fin   += curr_alpha * p_fin;
  			g_tp.sram_cell.H_fin   += curr_alpha * h_fin;
  			g_tp.sram_cell.T_si    += curr_alpha * t_si;
  			// FinFET-based SRAM cell properties:
  			double sram_cell_height, sram_cell_width;
  			sram_cell_height = g_ip->sram_cell_design.calc_height(lambda_um);
  			sram_cell_width = g_ip->sram_cell_design.calc_width(lambda_um, p_fin, t_si);
  			int n[5];
  			g_ip->sram_cell_design.getNfins(n);
! 			curr_Wmemcella_sram      = n[0] * 2 * h_fin;
! 			curr_Wmemcellpmos_sram   = n[1] * 2 * h_fin;
! 			curr_Wmemcellnmos_sram   = n[2] * 2 * h_fin;
! 			curr_Wmemcellrdiso_sram  = n[3] * 2 * h_fin;
! 			curr_Wmemcellrda_sram    = n[4] * 2 * h_fin;
  			curr_area_cell_sram      = sram_cell_height * sram_cell_width;
  			curr_asp_ratio_cell_sram = sram_cell_height / sram_cell_width;
! 		} else {
  			vbit_sense_min = 0.08;
  			// CMOS-based SRAM cell properties:
  			if ( g_ip->sram_cell_design.getType() == std_6T ) {
--- 284,356 ----
  		sscanf(temp_var, "%lf", &(c_junc));
  		strcpy(temp_var,cap_node.getChildNode("c_fringe").getText(0));
  		sscanf(temp_var, "%lf", &(c_fringe));
! 
! 		//Divya : Added c_gate to capture C_g_ideal capacitance given
! 		strcpy(temp_var,cap_node.getChildNode("c_gate").getChildNodeWithAttribute("volt","val",volt).getText(0)); //Cg(V)
! 		sscanf(temp_var, "%lf", &(c_gate));
! 
! 		//Divya : end
! 
  		senseAmp_node = root_node.getChildNode("sense_amplifier");
! // Divya Modifying begin : near threshold and super threshold not valid for ncfet--
! 			strcpy(temp_var,senseAmp_node.getChildNode("delay").getText(0));
  			sscanf(temp_var, "%lf", &(SENSE_AMP_D));
! 			strcpy(temp_var,senseAmp_node.getChildNode("energy").getText(0));
  			sscanf(temp_var, "%lf", &(SENSE_AMP_P));
! // Divya Modifying end --
  
  		char temperature[10];
! //		sprintf(temperature,"%d",g_ip->temp);
! // Divya Modifying begin :	for  ncfet and new finfet data
! 			sprintf(volt,"%.1f",vdd_cell);
! 			NMOS_ONcurrents_node = root_node.getChildNode("currents").getChildNode("ON_current").getChildNode("NMOS");
! 			strcpy(temp_var,NMOS_ONcurrents_node.getChildNodeWithAttribute("volt","val",volt).getText(0));
  			sscanf(temp_var, "%lf", &(I_on_n));
  
! 			PMOS_ONcurrents_node = root_node.getChildNode("currents").getChildNode("ON_current").getChildNode("PMOS");
! 			strcpy(temp_var,PMOS_ONcurrents_node.getChildNodeWithAttribute("volt","val",volt).getText(0));
  			sscanf(temp_var, "%lf", &(I_on_p));
  
! 			NMOS_OFFcurrents_node = root_node.getChildNode("currents").getChildNode("OFF_current").getChildNode("NMOS");
! 			strcpy(temp_var,NMOS_OFFcurrents_node.getChildNodeWithAttribute("volt","val",volt).getText(0));
  			sscanf(temp_var, "%lf", &(I_off_n));
  
! 			PMOS_OFFcurrents_node = root_node.getChildNode("currents").getChildNode("OFF_current").getChildNode("PMOS");
! 			strcpy(temp_var,PMOS_OFFcurrents_node.getChildNodeWithAttribute("volt","val",volt).getText(0));
  			sscanf(temp_var, "%lf", &(I_off_p));
! 
! 			strcpy(temp_var,root_node.getChildNode("currents").getChildNode("I_on_n_to_I_on_p_ratio").getText(0)); //Divya added
! 			sscanf(temp_var, "%lf", &(I_on_n_to_I_on_p_ratio)); //Divya added
! 
! //			cout << " Vdd : " << vdd_cell << ", Inon : " << I_on_n << ", Ipon : " << I_on_p << ", Inoff : " << I_off_n << ", Ipoff : " << I_off_p << ", vth : " << v_th << endl;
! // Divya Modifying end --
  		//---------- Majid - END ------------
  
  		/***** Alireza - BEGIN *****/
! 		if (g_ip->is_finfet) {	//Divya :: check later when parameters are obtained
  			vbit_sense_min = 0.04;
  			g_tp.sram_cell.P_fin   += curr_alpha * p_fin;
  			g_tp.sram_cell.H_fin   += curr_alpha * h_fin;
  			g_tp.sram_cell.T_si    += curr_alpha * t_si;
+ 			g_tp.sram_cell.W_fin   += curr_alpha * w_fin;
  			// FinFET-based SRAM cell properties:
  			double sram_cell_height, sram_cell_width;
  			sram_cell_height = g_ip->sram_cell_design.calc_height(lambda_um);
  			sram_cell_width = g_ip->sram_cell_design.calc_width(lambda_um, p_fin, t_si);
  			int n[5];
  			g_ip->sram_cell_design.getNfins(n);
! 
! //			Divya changing this, as width != 2*h_fin acdng to given new data
! 			//Divya changes begin
! 			curr_Wmemcella_sram      = n[0] * (2*h_fin + w_fin);
! 			curr_Wmemcellpmos_sram   = n[1] * (2*h_fin + w_fin);
! 			curr_Wmemcellnmos_sram   = n[2] * (2*h_fin + w_fin);
! 			curr_Wmemcellrdiso_sram  = n[3] * (2*h_fin + w_fin);
! 			curr_Wmemcellrda_sram    = n[4] * (2*h_fin + w_fin);
! 			//Divya changes end
  			curr_area_cell_sram      = sram_cell_height * sram_cell_width;
  			curr_asp_ratio_cell_sram = sram_cell_height / sram_cell_width;
! 		} else {	//cmos
  			vbit_sense_min = 0.08;
  			// CMOS-based SRAM cell properties:
  			if ( g_ip->sram_cell_design.getType() == std_6T ) {
***************
*** 364,376 ****
  		g_tp.Vbit_sense_min = vbit_sense_min;
  
  		delta_L = (g_ip->is_finfet) ? (2*0.8*Xj) : (0.8*Xj);
! 		c_g_ideal = Lphy * c_ox;
  		Lelec = Lphy - delta_L;
  		if ( Lelec <=0 ) {
  			cout << "ERROR: Lelec (ram_cell) is not a positive value! Please check the Lphy or the Xj value.\n";
  			exit(0);
  		}
! 		n_to_p_eff_curr_drv_ratio = I_on_n / I_on_p;
  		Rnchannelon = vdd_cell / I_on_n;
  		Rpchannelon = vdd_cell / I_on_p;
  		g_tp.sram_cell.Vdd       += curr_alpha * vdd_cell;
--- 377,391 ----
  		g_tp.Vbit_sense_min = vbit_sense_min;
  
  		delta_L = (g_ip->is_finfet) ? (2*0.8*Xj) : (0.8*Xj);
! //		c_g_ideal = Lphy * c_ox;	//Divya :: c_g_ideal changes with voltage for NCFET, this is no longer valid
! 		c_g_ideal = c_gate;	//Divya added this . (in F, not in F/um)
! 
  		Lelec = Lphy - delta_L;
  		if ( Lelec <=0 ) {
  			cout << "ERROR: Lelec (ram_cell) is not a positive value! Please check the Lphy or the Xj value.\n";
  			exit(0);
  		}
! 		n_to_p_eff_curr_drv_ratio = I_on_n_to_I_on_p_ratio; //1.219047619; //Finfet //I_on_n / I_on_p; (original) //Divya replaced this value with Max(I_on_n/I_on_p for all voltages) //1.4642857143 //NCFET
  		Rnchannelon = vdd_cell / I_on_n;
  		Rpchannelon = vdd_cell / I_on_p;
  		g_tp.sram_cell.Vdd       += curr_alpha * vdd_cell;
***************
*** 389,397 ****
  		g_tp.sram_cell.R_pch_on  += curr_alpha * Rpchannelon;
  		g_tp.sram_cell.n_to_p_eff_curr_drv_ratio += curr_alpha * n_to_p_eff_curr_drv_ratio;
  		/****** Alireza - END ******/
- 		//-------------------- cell parameters end ----------------------------
  
  
  		//-------------------- peripheral parameters begin --------------------
  		//---------- Majid - BEGIN ----------
  		if ( is_tag ) {
--- 404,428 ----
  		g_tp.sram_cell.R_pch_on  += curr_alpha * Rpchannelon;
  		g_tp.sram_cell.n_to_p_eff_curr_drv_ratio += curr_alpha * n_to_p_eff_curr_drv_ratio;
  		/****** Alireza - END ******/
  
  
+ 		// Divya begin. To update SRAM cell Ioff when dvs is true
+ 		double Ioffs[5];
+ 
+ 		if(g_ip->is_dvs && g_ip->is_finfet) {
+ 			char v[10];
+ 			sprintf(v,"%.1f",vdd_cell);
+ 			//Considering for 6T SRAM cell only, not for 8T sram cell
+ 			Ioffs[0] = g_tp.sram_cell.I_off_n;	//acc
+ 			Ioffs[1] = g_tp.sram_cell.I_off_p; //pup
+ 			Ioffs[2] = g_tp.sram_cell.I_off_n; //pdn
+ 
+ 			g_ip->sram_cell_design.setTransistorParams(g_ip->Nfins, g_ip->Lphys, Ioffs);
+ 		}
+ 		// Divya end
+ 
+ 		//-------------------- cell parameters end ----------------------------
+ 
  		//-------------------- peripheral parameters begin --------------------
  		//---------- Majid - BEGIN ----------
  		if ( is_tag ) {
***************
*** 418,439 ****
  			} else {
  				p_fin = (2 * lambda_um) + t_si;
  			}
  		}
  
  		voltages_node = root_node.getChildNode("voltages");
! 		strcpy(temp_var,voltages_node.getChildNode("v_th").getText(0));
! 		sscanf(temp_var, "%lf", &(v_th));
! 		if ( g_ip->is_near_threshold ) {
! 			strcpy(temp_var,voltages_node.getChildNode("vdd").getChildNode("near_threshold").getText(0));
! 			sscanf(temp_var, "%lf", &(vdd_peri));
! 			strcpy(temp_var,voltages_node.getChildNode("Vdsat").getChildNode("near_threshold").getText(0));
! 			sscanf(temp_var, "%lf", &(Vdsat));
! 		} else {
! 			strcpy(temp_var,voltages_node.getChildNode("vdd").getChildNode("super_threshold").getText(0));
! 			sscanf(temp_var, "%lf", &(vdd_peri));
! 			strcpy(temp_var,voltages_node.getChildNode("Vdsat").getChildNode("super_threshold").getText(0));
  			sscanf(temp_var, "%lf", &(Vdsat));
! 		}
  
  		cap_node = root_node.getChildNode("capacitances");
  		strcpy(temp_var,cap_node.getChildNode("c_ox").getText(0));
--- 449,470 ----
  			} else {
  				p_fin = (2 * lambda_um) + t_si;
  			}
+ 			strcpy(temp_var,geometry_node.getChildNode("FinFET").getChildNode("w_fin").getText(0));
+ 			sscanf(temp_var, "%lf", &(w_fin));
  		}
  
  		voltages_node = root_node.getChildNode("voltages");
! // Divya Modifying begin : near threshold and super threshold not valid for ncfet--
! 			vdd_peri = g_ip->vdd;
! 			sprintf(volt,"%.1f",vdd_peri);
! 
! 			strcpy(temp_var,voltages_node.getChildNode("v_th").getChildNodeWithAttribute("volt","val",volt).getText(0)); //Vth(V)
! 			sscanf(temp_var, "%lf", &(v_th));
! 
! 			strcpy(temp_var,voltages_node.getChildNode("Vdsat").getChildNodeWithAttribute("volt","val",volt).getText(0)); //vdsat(V)
  			sscanf(temp_var, "%lf", &(Vdsat));
! 
! // Divya Modifying end --
  
  		cap_node = root_node.getChildNode("capacitances");
  		strcpy(temp_var,cap_node.getChildNode("c_ox").getText(0));
***************
*** 447,493 ****
  		strcpy(temp_var,cap_node.getChildNode("c_fringe").getText(0));
  		sscanf(temp_var, "%lf", &(c_fringe));
  
  		strcpy(temp_var,root_node.getChildNode("mobility_eff").getText(0));
  		sscanf(temp_var, "%lf", &(mobility_eff));
  
  		strcpy(temp_var,root_node.getChildNode("gmp_to_gmn_multiplier").getText(0));
  		sscanf(temp_var, "%lf", &(gmp_to_gmn_multiplier));
  
! 		NMOS_ONcurrents_node = root_node.getChildNode("currents").getChildNode("ON_current").getChildNode("NMOS");
! 		if ( g_ip->is_near_threshold ) {
! 			strcpy(temp_var,NMOS_ONcurrents_node.getChildNode("near_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
  			sscanf(temp_var, "%lf", &(I_on_n));
- 		} else {
- 			strcpy(temp_var,NMOS_ONcurrents_node.getChildNode("super_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
- 			sscanf(temp_var, "%lf", &(I_on_n));
- 		}
  
! 		PMOS_ONcurrents_node = root_node.getChildNode("currents").getChildNode("ON_current").getChildNode("PMOS");
! 		if ( g_ip->is_near_threshold ) {
! 			strcpy(temp_var,PMOS_ONcurrents_node.getChildNode("near_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
  			sscanf(temp_var, "%lf", &(I_on_p));
- 		} else {
- 			strcpy(temp_var,PMOS_ONcurrents_node.getChildNode("super_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
- 			sscanf(temp_var, "%lf", &(I_on_p));
- 		}
  
! 		NMOS_OFFcurrents_node = root_node.getChildNode("currents").getChildNode("OFF_current").getChildNode("NMOS");
! 		if ( g_ip->is_near_threshold ) {
! 			strcpy(temp_var,NMOS_OFFcurrents_node.getChildNode("near_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
  			sscanf(temp_var, "%lf", &(I_off_n));
- 		} else {
- 			strcpy(temp_var,NMOS_OFFcurrents_node.getChildNode("super_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
- 			sscanf(temp_var, "%lf", &(I_off_n));
- 		}
  
! 		PMOS_OFFcurrents_node = root_node.getChildNode("currents").getChildNode("OFF_current").getChildNode("PMOS");
! 		if ( g_ip->is_near_threshold ) {
! 			strcpy(temp_var,PMOS_OFFcurrents_node.getChildNode("near_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
  			sscanf(temp_var, "%lf", &(I_off_p));
! 		} else {
! 			strcpy(temp_var,PMOS_OFFcurrents_node.getChildNode("super_threshold").getChildNodeWithAttribute("temp","val",temperature).getText(0));
! 			sscanf(temp_var, "%lf", &(I_off_p));
! 		}
  		//---------- Majid - END ------------
  
  		/***** Alireza - BEGIN *****/
--- 478,514 ----
  		strcpy(temp_var,cap_node.getChildNode("c_fringe").getText(0));
  		sscanf(temp_var, "%lf", &(c_fringe));
  
+ 		sprintf(volt,"%.1f",vdd_peri);
+ 		strcpy(temp_var,cap_node.getChildNode("c_gate").getChildNodeWithAttribute("volt","val",volt).getText(0)); //Cg(V)
+ 		sscanf(temp_var, "%lf", &(c_gate));
+ 
  		strcpy(temp_var,root_node.getChildNode("mobility_eff").getText(0));
  		sscanf(temp_var, "%lf", &(mobility_eff));
  
  		strcpy(temp_var,root_node.getChildNode("gmp_to_gmn_multiplier").getText(0));
  		sscanf(temp_var, "%lf", &(gmp_to_gmn_multiplier));
  
! 		// Divya Modifying begin :	for  cmos and finfet
! 			sprintf(volt,"%.1f",vdd_peri);
! 			NMOS_ONcurrents_node = root_node.getChildNode("currents").getChildNode("ON_current").getChildNode("NMOS");
! 			strcpy(temp_var,NMOS_ONcurrents_node.getChildNodeWithAttribute("volt","val",volt).getText(0));
  			sscanf(temp_var, "%lf", &(I_on_n));
  
! 			PMOS_ONcurrents_node = root_node.getChildNode("currents").getChildNode("ON_current").getChildNode("PMOS");
! 			strcpy(temp_var,PMOS_ONcurrents_node.getChildNodeWithAttribute("volt","val",volt).getText(0));
  			sscanf(temp_var, "%lf", &(I_on_p));
  
! 			NMOS_OFFcurrents_node = root_node.getChildNode("currents").getChildNode("OFF_current").getChildNode("NMOS");
! 			strcpy(temp_var,NMOS_OFFcurrents_node.getChildNodeWithAttribute("volt","val",volt).getText(0));
  			sscanf(temp_var, "%lf", &(I_off_n));
  
! 			PMOS_OFFcurrents_node = root_node.getChildNode("currents").getChildNode("OFF_current").getChildNode("PMOS");
! 			strcpy(temp_var,PMOS_OFFcurrents_node.getChildNodeWithAttribute("volt","val",volt).getText(0));
  			sscanf(temp_var, "%lf", &(I_off_p));
! 
! 			strcpy(temp_var,root_node.getChildNode("currents").getChildNode("I_on_n_to_I_on_p_ratio").getText(0)); //Divya added
! 			sscanf(temp_var, "%lf", &(I_on_n_to_I_on_p_ratio)); //Divya added
! // Divya Modifying end --
  		//---------- Majid - END ------------
  
  		/***** Alireza - BEGIN *****/
***************
*** 495,510 ****
  			g_tp.peri_global.P_fin += curr_alpha * p_fin;
  			g_tp.peri_global.H_fin += curr_alpha * h_fin;
  			g_tp.peri_global.T_si  += curr_alpha * t_si;
  		}
  
  		delta_L = (g_ip->is_finfet) ? (2*0.8*Xj) : (0.8*Xj);
! 		c_g_ideal = Lphy * c_ox;
  		Lelec = Lphy - delta_L;
  		if ( Lelec <= 0 ) {
  			cout << "ERROR: Lelec (peri_global) is not a positive value! Please check the Lphy or the Xj value.\n";
  			exit(0);
  		}
! 		n_to_p_eff_curr_drv_ratio = I_on_n / I_on_p;
  		Rnchannelon = vdd_peri / I_on_n;
  		Rpchannelon = vdd_peri / I_on_p;
  		g_tp.peri_global.Vdd       += curr_alpha * vdd_peri;
--- 516,534 ----
  			g_tp.peri_global.P_fin += curr_alpha * p_fin;
  			g_tp.peri_global.H_fin += curr_alpha * h_fin;
  			g_tp.peri_global.T_si  += curr_alpha * t_si;
+ 			g_tp.peri_global.W_fin += curr_alpha * w_fin;
  		}
  
  		delta_L = (g_ip->is_finfet) ? (2*0.8*Xj) : (0.8*Xj);
! //		c_g_ideal = Lphy * c_ox;	//Divya : c_g_ideal changes with voltage for ncfets. This dependency is no longer valid
! 		c_g_ideal = c_gate;	// Divya modified this to include data given (in F, not in F/um)
! 
  		Lelec = Lphy - delta_L;
  		if ( Lelec <= 0 ) {
  			cout << "ERROR: Lelec (peri_global) is not a positive value! Please check the Lphy or the Xj value.\n";
  			exit(0);
  		}
! 		n_to_p_eff_curr_drv_ratio = I_on_n_to_I_on_p_ratio; //Divya added; //1.219047619; //Finfet //I_on_n / I_on_p; (original) //Divya replaced this value with Max(I_on_n/I_on_p for all voltages) //1.4642857143 //NCFET
  		Rnchannelon = vdd_peri / I_on_n;
  		Rpchannelon = vdd_peri / I_on_p;
  		g_tp.peri_global.Vdd       += curr_alpha * vdd_peri;
***************
*** 524,532 ****
  		g_tp.peri_global.R_pch_on  += curr_alpha * Rpchannelon;
  		g_tp.peri_global.n_to_p_eff_curr_drv_ratio += curr_alpha * n_to_p_eff_curr_drv_ratio;
  		gmp_to_gmn_multiplier_periph_global += curr_alpha * gmp_to_gmn_multiplier;
- 		/****** Alireza - END ******/
- 		//-------------------- peripheral parameters end ----------------------
  
  
  
  		// TO DO: Update This!
--- 548,555 ----
  		g_tp.peri_global.R_pch_on  += curr_alpha * Rpchannelon;
  		g_tp.peri_global.n_to_p_eff_curr_drv_ratio += curr_alpha * n_to_p_eff_curr_drv_ratio;
  		gmp_to_gmn_multiplier_periph_global += curr_alpha * gmp_to_gmn_multiplier;
  
+ 		//-------------------- peripheral parameters end ----------------------
  
  
  		// TO DO: Update This!
***************
*** 586,592 ****
  		mobility_eff_periph_global += curr_alpha * mobility_eff; 
  		Vdsat_periph_global        += curr_alpha * Vdsat;
  	}
! 
  	
  	// TO DO: Update transistor sizes for FinFETs
  	// Alireza: for CMOS we have "N * g_ip->F_sz_um", but this should be changed for FinFETs
--- 609,615 ----
  		mobility_eff_periph_global += curr_alpha * mobility_eff; 
  		Vdsat_periph_global        += curr_alpha * Vdsat;
  	}
! //	cout << "curr_area_cell_sram : " << curr_area_cell_sram << "\n area_cell_area : " << area_cell_sram << endl;
  	
  	// TO DO: Update transistor sizes for FinFETs
  	// Alireza: for CMOS we have "N * g_ip->F_sz_um", but this should be changed for FinFETs
***************
*** 612,626 ****
  	g_tp.ram_wl_stitching_overhead_ = 7.5 * g_ip->F_sz_um;
  	
  	/***** Alireza - BEGIN *****/
  	if ( g_ip->is_finfet ) {
! 		g_tp.min_w_nmos_ = 2 * g_tp.peri_global.H_fin;
  		// transistor sizing of the finfet-based sense amplifier
! 		g_tp.w_iso       = 1 * 2 * h_fin; // 1 fin
! 		g_tp.w_sense_n   = 1 * 2 * h_fin; // 1 fin
! 		g_tp.w_sense_p   = 1 * 2 * h_fin; // 1 fin
! 		g_tp.w_sense_en  = 1 * 2 * h_fin; // 1 fin
! 		//g_tp.NAND2_LEAK_STACK_FACTOR = 
! 	} else {
  		g_tp.min_w_nmos_ = 3 * g_ip->F_sz_um / 2;
  		// transistor sizing of the cmos-based sense amplifier
  		g_tp.w_iso       = 12.5 * g_ip->F_sz_um; // was 10 micron for the 0.8 micron process
--- 635,653 ----
  	g_tp.ram_wl_stitching_overhead_ = 7.5 * g_ip->F_sz_um;
  	
  	/***** Alireza - BEGIN *****/
+ 
+ //Divya changing this, as width != 2*h_fin acdng to given new data
+ //Divya changes begin
  	if ( g_ip->is_finfet ) {
! 		g_tp.min_w_nmos_ = 2 * g_tp.peri_global.H_fin + g_tp.peri_global.W_fin; //g_tp.peri_global.W_fin;
  		// transistor sizing of the finfet-based sense amplifier
! 		g_tp.w_iso       = 1 * (2 * h_fin + w_fin);  // 1 fin
! 		g_tp.w_sense_n   = 1 * (2 * h_fin + w_fin);  // 1 fin
! 		g_tp.w_sense_p   = 1 * (2 * h_fin + w_fin);  // 1 fin
! 		g_tp.w_sense_en  = 1 * (2 * h_fin + w_fin);  // 1 fin
! 		//g_tp.NAND2_LEAK_STACK_FACTOR =
! 	} //Divya changes end
! 	else {
  		g_tp.min_w_nmos_ = 3 * g_ip->F_sz_um / 2;
  		// transistor sizing of the cmos-based sense amplifier
  		g_tp.w_iso       = 12.5 * g_ip->F_sz_um; // was 10 micron for the 0.8 micron process
***************
*** 641,656 ****
  		g_tp.max_w_nmos_dec = g_tp.max_w_nmos_;
  		g_tp.h_dec          = 4;  // in the unit of memory cell height
  	}
  
- 	g_tp.peri_global.C_overlap = 0.2 * g_tp.peri_global.C_g_ideal;
- 	g_tp.sram_cell.C_overlap   = 0.2 * g_tp.sram_cell.C_g_ideal;
- 
- 	g_tp.dram_acc.C_overlap = 0.2 * g_tp.dram_acc.C_g_ideal;
  	g_tp.dram_acc.R_nch_on = g_tp.dram_cell_Vdd / g_tp.dram_acc.I_on_n;
  	//g_tp.dram_acc.R_pch_on = g_tp.dram_cell_Vdd / g_tp.dram_acc.I_on_p;
  
- 	g_tp.dram_wl.C_overlap = 0.2 * g_tp.dram_wl.C_g_ideal;
- 
  	double gmn_sense_amp_latch = (mobility_eff_periph_global / 2) * g_tp.peri_global.C_ox * (g_tp.w_sense_n / g_tp.peri_global.l_elec) * Vdsat_periph_global;
  	double gmp_sense_amp_latch = gmp_to_gmn_multiplier_periph_global * gmn_sense_amp_latch;
  	g_tp.gm_sense_amp_latch = gmn_sense_amp_latch + gmp_sense_amp_latch;
--- 668,683 ----
  		g_tp.max_w_nmos_dec = g_tp.max_w_nmos_;
  		g_tp.h_dec          = 4;  // in the unit of memory cell height
  	}
+ //Divya Modifications Start
+ 	g_tp.peri_global.C_overlap = 0;
+ 	g_tp.sram_cell.C_overlap   = 0;
+ 	g_tp.dram_acc.C_overlap = 0;
+ 	g_tp.dram_wl.C_overlap = 0;
+ //Divya Modificatons END
  
  	g_tp.dram_acc.R_nch_on = g_tp.dram_cell_Vdd / g_tp.dram_acc.I_on_n;
  	//g_tp.dram_acc.R_pch_on = g_tp.dram_cell_Vdd / g_tp.dram_acc.I_on_p;
  
  	double gmn_sense_amp_latch = (mobility_eff_periph_global / 2) * g_tp.peri_global.C_ox * (g_tp.w_sense_n / g_tp.peri_global.l_elec) * Vdsat_periph_global;
  	double gmp_sense_amp_latch = gmp_to_gmn_multiplier_periph_global * gmn_sense_amp_latch;
  	g_tp.gm_sense_amp_latch = gmn_sense_amp_latch + gmp_sense_amp_latch;
***************
*** 666,672 ****
  	g_tp.w_pmos_bl_precharge = 6 * pmos_to_nmos_sizing_r * g_tp.min_w_nmos_;
  	g_tp.w_pmos_bl_eq = pmos_to_nmos_sizing_r * g_tp.min_w_nmos_;
  
- 	 
  	//-------------------- interconnect (wire) parameters begin --------------------------
      double wire_pitch       [NUMBER_INTERCONNECT_PROJECTION_TYPES][NUMBER_WIRE_TYPES],
             wire_r_per_micron[NUMBER_INTERCONNECT_PROJECTION_TYPES][NUMBER_WIRE_TYPES],
--- 693,698 ----
***************
*** 680,699 ****
          if (tech_lo == tech_hi) {
            curr_alpha = 1;
          } else {
!           curr_alpha = (technology - tech_hi)/(tech_lo - tech_hi);
          }
        } else {
          tech = tech_hi;
          if (tech_lo == tech_hi) {
            break;  
          } else {
!           curr_alpha = (tech_lo - technology)/(tech_lo - tech_hi);
          }
        }
  
        if (tech == 90) {
          //Aggressive projections
!         wire_pitch[0][0] = 2.5 * g_ip->F_sz_um;//micron
          aspect_ratio = 2.4;
          wire_width = wire_pitch[0][0] / 2; //micron
          wire_thickness = aspect_ratio * wire_width;//micron
--- 706,725 ----
          if (tech_lo == tech_hi) {
            curr_alpha = 1;
          } else {
!           curr_alpha = (wire_technology - tech_hi)/(tech_lo - tech_hi);
          }
        } else {
          tech = tech_hi;
          if (tech_lo == tech_hi) {
            break;  
          } else {
!           curr_alpha = (tech_lo - wire_technology)/(tech_lo - tech_hi);
          }
        }
  
        if (tech == 90) {
          //Aggressive projections
!         wire_pitch[0][0] = 2.5 * g_ip->wire_F_sz_um;//micron
          aspect_ratio = 2.4;
          wire_width = wire_pitch[0][0] / 2; //micron
          wire_thickness = aspect_ratio * wire_width;//micron
***************
*** 712,718 ****
              ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);//F/micron.
  
!         wire_pitch[0][1] = 4 * g_ip->F_sz_um;
          wire_width = wire_pitch[0][1] / 2;
          wire_thickness = aspect_ratio * wire_width;
          wire_spacing = wire_pitch[0][1] - wire_width;
--- 738,744 ----
              ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);//F/micron.
  
!         wire_pitch[0][1] = 4 * g_ip->wire_F_sz_um;
          wire_width = wire_pitch[0][1] / 2;
          wire_thickness = aspect_ratio * wire_width;
          wire_spacing = wire_pitch[0][1] - wire_width;
***************
*** 722,728 ****
              ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);
  
!         wire_pitch[0][2] = 8 * g_ip->F_sz_um;
          aspect_ratio = 2.7;
          wire_width = wire_pitch[0][2] / 2;
          wire_thickness = aspect_ratio * wire_width;
--- 748,754 ----
              ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);
  
!         wire_pitch[0][2] = 8 * g_ip->wire_F_sz_um;
          aspect_ratio = 2.7;
          wire_width = wire_pitch[0][2] / 2;
          wire_thickness = aspect_ratio * wire_width;
***************
*** 735,741 ****
              fringe_cap);
  
          //Conservative projections
!         wire_pitch[1][0] = 2.5 * g_ip->F_sz_um;
          aspect_ratio = 2.0;
          wire_width = wire_pitch[1][0] / 2;
          wire_thickness = aspect_ratio * wire_width;
--- 761,767 ----
              fringe_cap);
  
          //Conservative projections
!         wire_pitch[1][0] = 2.5 * g_ip->wire_F_sz_um;
          aspect_ratio = 2.0;
          wire_width = wire_pitch[1][0] / 2;
          wire_thickness = aspect_ratio * wire_width;
***************
*** 754,760 ****
              ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);
  
!         wire_pitch[1][1] = 4 * g_ip->F_sz_um;
          wire_width = wire_pitch[1][1] / 2;
          aspect_ratio = 2.0;
          wire_thickness = aspect_ratio * wire_width;
--- 780,786 ----
              ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);
  
!         wire_pitch[1][1] = 4 * g_ip->wire_F_sz_um;
          wire_width = wire_pitch[1][1] / 2;
          aspect_ratio = 2.0;
          wire_thickness = aspect_ratio * wire_width;
***************
*** 765,771 ****
              ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);
  
!         wire_pitch[1][2] = 8 * g_ip->F_sz_um;
          aspect_ratio = 2.2;
          wire_width = wire_pitch[1][2] / 2;
          wire_thickness = aspect_ratio * wire_width;
--- 791,797 ----
              ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);
  
!         wire_pitch[1][2] = 8 * g_ip->wire_F_sz_um;
          aspect_ratio = 2.2;
          wire_width = wire_pitch[1][2] / 2;
          wire_thickness = aspect_ratio * wire_width;
***************
*** 784,790 ****
        }
        else if (tech == 65) {
          //Aggressive projections
!         wire_pitch[0][0] = 2.5 * g_ip->F_sz_um;
          aspect_ratio = 2.7;
          wire_width = wire_pitch[0][0] / 2;
          wire_thickness = aspect_ratio * wire_width;
--- 810,816 ----
        }
        else if (tech == 65) {
          //Aggressive projections
!         wire_pitch[0][0] = 2.5 * g_ip->wire_F_sz_um;
          aspect_ratio = 2.7;
          wire_width = wire_pitch[0][0] / 2;
          wire_thickness = aspect_ratio * wire_width;
***************
*** 803,809 ****
              ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);
  
!         wire_pitch[0][1] = 4 * g_ip->F_sz_um;
          wire_width = wire_pitch[0][1] / 2;
          wire_thickness = aspect_ratio * wire_width;
          wire_spacing = wire_pitch[0][1] - wire_width;
--- 829,835 ----
              ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);
  
!         wire_pitch[0][1] = 4 * g_ip->wire_F_sz_um;
          wire_width = wire_pitch[0][1] / 2;
          wire_thickness = aspect_ratio * wire_width;
          wire_spacing = wire_pitch[0][1] - wire_width;
***************
*** 813,819 ****
              ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);
  
!         wire_pitch[0][2] = 8 * g_ip->F_sz_um;
          aspect_ratio = 2.8;
          wire_width = wire_pitch[0][2] / 2;
          wire_thickness = aspect_ratio * wire_width;
--- 839,845 ----
              ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);
  
!         wire_pitch[0][2] = 8 * g_ip->wire_F_sz_um;
          aspect_ratio = 2.8;
          wire_width = wire_pitch[0][2] / 2;
          wire_thickness = aspect_ratio * wire_width;
***************
*** 826,832 ****
              fringe_cap);
  
          //Conservative projections
!         wire_pitch[1][0] = 2.5 * g_ip->F_sz_um;
          aspect_ratio = 2.0;
          wire_width = wire_pitch[1][0] / 2;
          wire_thickness = aspect_ratio * wire_width;
--- 852,858 ----
              fringe_cap);
  
          //Conservative projections
!         wire_pitch[1][0] = 2.5 * g_ip->wire_F_sz_um;
          aspect_ratio = 2.0;
          wire_width = wire_pitch[1][0] / 2;
          wire_thickness = aspect_ratio * wire_width;
***************
*** 845,851 ****
              ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);
  
!         wire_pitch[1][1] = 4 * g_ip->F_sz_um;
          wire_width = wire_pitch[1][1] / 2;
          wire_thickness = aspect_ratio * wire_width;
          wire_spacing = wire_pitch[1][1] - wire_width;
--- 871,877 ----
              ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);
  
!         wire_pitch[1][1] = 4 * g_ip->wire_F_sz_um;
          wire_width = wire_pitch[1][1] / 2;
          wire_thickness = aspect_ratio * wire_width;
          wire_spacing = wire_pitch[1][1] - wire_width;
***************
*** 855,861 ****
              ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);
  
!         wire_pitch[1][2] = 8 * g_ip->F_sz_um;
          aspect_ratio = 2.2;
          wire_width = wire_pitch[1][2] / 2;
          wire_thickness = aspect_ratio * wire_width;
--- 881,887 ----
              ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);
  
!         wire_pitch[1][2] = 8 * g_ip->wire_F_sz_um;
          aspect_ratio = 2.2;
          wire_width = wire_pitch[1][2] / 2;
          wire_thickness = aspect_ratio * wire_width;
***************
*** 874,880 ****
        }
        else if (tech == 45) {
          //Aggressive projections.
!         wire_pitch[0][0] = 2.5 * g_ip->F_sz_um;
          aspect_ratio = 3.0;
          wire_width = wire_pitch[0][0] / 2;
          wire_thickness = aspect_ratio * wire_width;
--- 900,906 ----
        }
        else if (tech == 45) {
          //Aggressive projections.
!         wire_pitch[0][0] = 2.5 * g_ip->wire_F_sz_um;
          aspect_ratio = 3.0;
          wire_width = wire_pitch[0][0] / 2;
          wire_thickness = aspect_ratio * wire_width;
***************
*** 893,899 ****
              ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);
  
!         wire_pitch[0][1] = 4 * g_ip->F_sz_um;
          wire_width = wire_pitch[0][1] / 2;
          wire_thickness = aspect_ratio * wire_width;
          wire_spacing = wire_pitch[0][1] - wire_width;
--- 919,925 ----
              ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);
  
!         wire_pitch[0][1] = 4 * g_ip->wire_F_sz_um;
          wire_width = wire_pitch[0][1] / 2;
          wire_thickness = aspect_ratio * wire_width;
          wire_spacing = wire_pitch[0][1] - wire_width;
***************
*** 903,909 ****
              ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);
  
!         wire_pitch[0][2] = 8 * g_ip->F_sz_um;
          aspect_ratio = 3.0;
          wire_width = wire_pitch[0][2] / 2;
          wire_thickness = aspect_ratio * wire_width;
--- 929,935 ----
              ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);
  
!         wire_pitch[0][2] = 8 * g_ip->wire_F_sz_um;
          aspect_ratio = 3.0;
          wire_width = wire_pitch[0][2] / 2;
          wire_thickness = aspect_ratio * wire_width;
***************
*** 916,922 ****
              fringe_cap);
  
          //Conservative projections
!         wire_pitch[1][0] = 2.5 * g_ip->F_sz_um;
          aspect_ratio = 2.0;
          wire_width = wire_pitch[1][0] / 2;
          wire_thickness = aspect_ratio * wire_width;
--- 942,948 ----
              fringe_cap);
  
          //Conservative projections
!         wire_pitch[1][0] = 2.5 * g_ip->wire_F_sz_um;
          aspect_ratio = 2.0;
          wire_width = wire_pitch[1][0] / 2;
          wire_thickness = aspect_ratio * wire_width;
***************
*** 935,941 ****
              ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);
  
!         wire_pitch[1][1] = 4 * g_ip->F_sz_um;
          wire_width = wire_pitch[1][1] / 2;
          wire_thickness = aspect_ratio * wire_width;
          wire_spacing = wire_pitch[1][1] - wire_width;
--- 961,967 ----
              ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);
  
!         wire_pitch[1][1] = 4 * g_ip->wire_F_sz_um;
          wire_width = wire_pitch[1][1] / 2;
          wire_thickness = aspect_ratio * wire_width;
          wire_spacing = wire_pitch[1][1] - wire_width;
***************
*** 945,951 ****
              ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);
  
!         wire_pitch[1][2] = 8 * g_ip->F_sz_um;
          aspect_ratio = 2.2;
          wire_width = wire_pitch[1][2] / 2;
          wire_thickness = aspect_ratio * wire_width;
--- 971,977 ----
              ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);
  
!         wire_pitch[1][2] = 8 * g_ip->wire_F_sz_um;
          aspect_ratio = 2.2;
          wire_width = wire_pitch[1][2] / 2;
          wire_thickness = aspect_ratio * wire_width;
***************
*** 965,971 ****
        else if (tech == 32) {
          if ( !g_ip->is_itrs2012 ) { // wire data from Ron Ho's PhD Thesis, Stanford, 2003.
            //Aggressive projections.
!           wire_pitch[0][0] = 2.5 * g_ip->F_sz_um;
            aspect_ratio = 3.0;
            wire_width = wire_pitch[0][0] / 2;
            wire_thickness = aspect_ratio * wire_width;
--- 991,997 ----
        else if (tech == 32) {
          if ( !g_ip->is_itrs2012 ) { // wire data from Ron Ho's PhD Thesis, Stanford, 2003.
            //Aggressive projections.
!           wire_pitch[0][0] = 2.5 * g_ip->wire_F_sz_um;
            aspect_ratio = 3.0;
            wire_width = wire_pitch[0][0] / 2;
            wire_thickness = aspect_ratio * wire_width;
***************
*** 984,990 ****
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[0][1] = 4 * g_ip->F_sz_um;
            wire_width = wire_pitch[0][1] / 2;
            wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[0][1] - wire_width;
--- 1010,1016 ----
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[0][1] = 4 * g_ip->wire_F_sz_um;
            wire_width = wire_pitch[0][1] / 2;
            wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[0][1] - wire_width;
***************
*** 994,1000 ****
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[0][2] = 8 * g_ip->F_sz_um;
            aspect_ratio = 3.0;
            wire_width = wire_pitch[0][2] / 2;
            wire_thickness = aspect_ratio * wire_width;
--- 1020,1026 ----
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[0][2] = 8 * g_ip->wire_F_sz_um;
            aspect_ratio = 3.0;
            wire_width = wire_pitch[0][2] / 2;
            wire_thickness = aspect_ratio * wire_width;
***************
*** 1007,1013 ****
                fringe_cap);
            
            //Conservative projections
!           wire_pitch[1][0] = 2.5 * g_ip->F_sz_um;
            aspect_ratio = 2.0;
            wire_width = wire_pitch[1][0] / 2;
            wire_thickness = aspect_ratio * wire_width;
--- 1033,1039 ----
                fringe_cap);
            
            //Conservative projections
!           wire_pitch[1][0] = 2.5 * g_ip->wire_F_sz_um;
            aspect_ratio = 2.0;
            wire_width = wire_pitch[1][0] / 2;
            wire_thickness = aspect_ratio * wire_width;
***************
*** 1026,1032 ****
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[1][1] = 4 * g_ip->F_sz_um;
            wire_width = wire_pitch[1][1] / 2;
            wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[1][1] - wire_width;
--- 1052,1058 ----
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[1][1] = 4 * g_ip->wire_F_sz_um;
            wire_width = wire_pitch[1][1] / 2;
            wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[1][1] - wire_width;
***************
*** 1036,1042 ****
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[1][2] = 8 * g_ip->F_sz_um;
            aspect_ratio = 2.2;
            wire_width = wire_pitch[1][2] / 2;
            wire_thickness = aspect_ratio * wire_width;
--- 1062,1068 ----
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[1][2] = 8 * g_ip->wire_F_sz_um;
            aspect_ratio = 2.2;
            wire_width = wire_pitch[1][2] / 2;
            wire_thickness = aspect_ratio * wire_width;
***************
*** 1075,1081 ****
        else if (tech == 22) {
          if ( !g_ip->is_itrs2012 ) { // wire data from Ron Ho's PhD Thesis, Stanford, 2003.
            //Aggressive projections.
!           wire_pitch[0][0] = 2.5 * g_ip->F_sz_um;//local
            aspect_ratio = 3.0;
            wire_width = wire_pitch[0][0] / 2;
            wire_thickness = aspect_ratio * wire_width;
--- 1101,1107 ----
        else if (tech == 22) {
          if ( !g_ip->is_itrs2012 ) { // wire data from Ron Ho's PhD Thesis, Stanford, 2003.
            //Aggressive projections.
!           wire_pitch[0][0] = 2.5 * g_ip->wire_F_sz_um;//local
            aspect_ratio = 3.0;
            wire_width = wire_pitch[0][0] / 2;
            wire_thickness = aspect_ratio * wire_width;
***************
*** 1094,1100 ****
              ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);
            
!           wire_pitch[0][1] = 4 * g_ip->F_sz_um;//semi-global
            wire_width = wire_pitch[0][1] / 2;
            aspect_ratio = 3.0;
            wire_thickness = aspect_ratio * wire_width;
--- 1120,1126 ----
              ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);
            
!           wire_pitch[0][1] = 4 * g_ip->wire_F_sz_um;//semi-global
            wire_width = wire_pitch[0][1] / 2;
            aspect_ratio = 3.0;
            wire_thickness = aspect_ratio * wire_width;
***************
*** 1109,1115 ****
              ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);
            
!           wire_pitch[0][2] = 8 * g_ip->F_sz_um;//global
            aspect_ratio = 3.0;
            wire_width = wire_pitch[0][2] / 2;
            wire_thickness = aspect_ratio * wire_width;
--- 1135,1141 ----
              ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);
            
!           wire_pitch[0][2] = 8 * g_ip->wire_F_sz_um;//global
            aspect_ratio = 3.0;
            wire_width = wire_pitch[0][2] / 2;
            wire_thickness = aspect_ratio * wire_width;
***************
*** 1125,1131 ****
            	  fringe_cap);
            
            //Conservative projections
!           wire_pitch[1][0] = 2.5 * g_ip->F_sz_um;
            aspect_ratio = 2.0;
            wire_width = wire_pitch[1][0] / 2;
            wire_thickness = aspect_ratio * wire_width;
--- 1151,1157 ----
            	  fringe_cap);
            
            //Conservative projections
!           wire_pitch[1][0] = 2.5 * g_ip->wire_F_sz_um;
            aspect_ratio = 2.0;
            wire_width = wire_pitch[1][0] / 2;
            wire_thickness = aspect_ratio * wire_width;
***************
*** 1143,1150 ****
            wire_c_per_micron[1][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
              ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);
!           
!           wire_pitch[1][1] = 4 * g_ip->F_sz_um;
            wire_width = wire_pitch[1][1] / 2;
            aspect_ratio = 2.0;
            wire_thickness = aspect_ratio * wire_width;
--- 1169,1176 ----
            wire_c_per_micron[1][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
              ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);
! 
!           wire_pitch[1][1] = 4 * g_ip->wire_F_sz_um;
            wire_width = wire_pitch[1][1] / 2;
            aspect_ratio = 2.0;
            wire_thickness = aspect_ratio * wire_width;
***************
*** 1158,1165 ****
            wire_c_per_micron[1][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
              ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);
!           
!           wire_pitch[1][2] = 8 * g_ip->F_sz_um;
            aspect_ratio = 2.2;
            wire_width = wire_pitch[1][2] / 2;
            wire_thickness = aspect_ratio * wire_width;
--- 1184,1191 ----
            wire_c_per_micron[1][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing,
              ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
              fringe_cap);
! 
!           wire_pitch[1][2] = 8 * g_ip->wire_F_sz_um;
            aspect_ratio = 2.2;
            wire_width = wire_pitch[1][2] / 2;
            wire_thickness = aspect_ratio * wire_width;
***************
*** 1201,1207 ****
        else if (tech == 16 || tech == 14) { // Alireza2
          if ( !g_ip->is_itrs2012 ) { // wire data from Ron Ho's PhD Thesis, Stanford, 2003.
            //Aggressive projections.
!           wire_pitch[0][0] = 2.5 * g_ip->F_sz_um;
            aspect_ratio = 3.0;
            wire_width = wire_pitch[0][0] / 2;
            wire_thickness = aspect_ratio * wire_width;
--- 1227,1233 ----
        else if (tech == 16 || tech == 14) { // Alireza2
          if ( !g_ip->is_itrs2012 ) { // wire data from Ron Ho's PhD Thesis, Stanford, 2003.
            //Aggressive projections.
!           wire_pitch[0][0] = 2.5 * g_ip->wire_F_sz_um;
            aspect_ratio = 3.0;
            wire_width = wire_pitch[0][0] / 2;
            wire_thickness = aspect_ratio * wire_width;
***************
*** 1220,1226 ****
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[0][1] = 4 * g_ip->F_sz_um;
            wire_width = wire_pitch[0][1] / 2;
            wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[0][1] - wire_width;
--- 1246,1252 ----
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[0][1] = 4 * g_ip->wire_F_sz_um;
            wire_width = wire_pitch[0][1] / 2;
            wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[0][1] - wire_width;
***************
*** 1230,1236 ****
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[0][2] = 8 * g_ip->F_sz_um;
            aspect_ratio = 3.0;
            wire_width = wire_pitch[0][2] / 2;
            wire_thickness = aspect_ratio * wire_width;
--- 1256,1262 ----
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[0][2] = 8 * g_ip->wire_F_sz_um;
            aspect_ratio = 3.0;
            wire_width = wire_pitch[0][2] / 2;
            wire_thickness = aspect_ratio * wire_width;
***************
*** 1243,1249 ****
                fringe_cap);
            
            //Conservative projections
!           wire_pitch[1][0] = 2.5 * g_ip->F_sz_um;
            aspect_ratio = 2.0;
            wire_width = wire_pitch[1][0] / 2;
            wire_thickness = aspect_ratio * wire_width;
--- 1269,1275 ----
                fringe_cap);
            
            //Conservative projections
!           wire_pitch[1][0] = 2.5 * g_ip->wire_F_sz_um;
            aspect_ratio = 2.0;
            wire_width = wire_pitch[1][0] / 2;
            wire_thickness = aspect_ratio * wire_width;
***************
*** 1262,1268 ****
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[1][1] = 4 * g_ip->F_sz_um;
            wire_width = wire_pitch[1][1] / 2;
            wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[1][1] - wire_width;
--- 1288,1294 ----
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[1][1] = 4 * g_ip->wire_F_sz_um;
            wire_width = wire_pitch[1][1] / 2;
            wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[1][1] - wire_width;
***************
*** 1272,1278 ****
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[1][2] = 8 * g_ip->F_sz_um;
            aspect_ratio = 2.2;
            wire_width = wire_pitch[1][2] / 2;
            wire_thickness = aspect_ratio * wire_width;
--- 1298,1304 ----
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[1][2] = 8 * g_ip->wire_F_sz_um;
            aspect_ratio = 2.2;
            wire_width = wire_pitch[1][2] / 2;
            wire_thickness = aspect_ratio * wire_width;
***************
*** 1311,1317 ****
        else if (tech == 10) { // Alireza
          if ( !g_ip->is_itrs2012 ) { // wire data from Ron Ho's PhD Thesis, Stanford, 2003.
            //Aggressive projections.
!           wire_pitch[0][0] = 2.5 * g_ip->F_sz_um;
            aspect_ratio = 3.0;
            wire_width = wire_pitch[0][0] / 2;
            wire_thickness = aspect_ratio * wire_width;
--- 1337,1343 ----
        else if (tech == 10) { // Alireza
          if ( !g_ip->is_itrs2012 ) { // wire data from Ron Ho's PhD Thesis, Stanford, 2003.
            //Aggressive projections.
!           wire_pitch[0][0] = 2.5 * g_ip->wire_F_sz_um;
            aspect_ratio = 3.0;
            wire_width = wire_pitch[0][0] / 2;
            wire_thickness = aspect_ratio * wire_width;
***************
*** 1330,1336 ****
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[0][1] = 4 * g_ip->F_sz_um;
            wire_width = wire_pitch[0][1] / 2;
            wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[0][1] - wire_width;
--- 1356,1362 ----
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[0][1] = 4 * g_ip->wire_F_sz_um;
            wire_width = wire_pitch[0][1] / 2;
            wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[0][1] - wire_width;
***************
*** 1340,1346 ****
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[0][2] = 8 * g_ip->F_sz_um;
            aspect_ratio = 3.0;
            wire_width = wire_pitch[0][2] / 2;
            wire_thickness = aspect_ratio * wire_width;
--- 1366,1372 ----
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[0][2] = 8 * g_ip->wire_F_sz_um;
            aspect_ratio = 3.0;
            wire_width = wire_pitch[0][2] / 2;
            wire_thickness = aspect_ratio * wire_width;
***************
*** 1353,1359 ****
                fringe_cap);
            
            //Conservative projections
!           wire_pitch[1][0] = 2.5 * g_ip->F_sz_um;
            aspect_ratio = 2.0;
            wire_width = wire_pitch[1][0] / 2;
            wire_thickness = aspect_ratio * wire_width;
--- 1379,1385 ----
                fringe_cap);
            
            //Conservative projections
!           wire_pitch[1][0] = 2.5 * g_ip->wire_F_sz_um;
            aspect_ratio = 2.0;
            wire_width = wire_pitch[1][0] / 2;
            wire_thickness = aspect_ratio * wire_width;
***************
*** 1372,1378 ****
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[1][1] = 4 * g_ip->F_sz_um;
            wire_width = wire_pitch[1][1] / 2;
            wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[1][1] - wire_width;
--- 1398,1404 ----
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[1][1] = 4 * g_ip->wire_F_sz_um;
            wire_width = wire_pitch[1][1] / 2;
            wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[1][1] - wire_width;
***************
*** 1382,1388 ****
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[1][2] = 8 * g_ip->F_sz_um;
            aspect_ratio = 2.2;
            wire_width = wire_pitch[1][2] / 2;
            wire_thickness = aspect_ratio * wire_width;
--- 1408,1414 ----
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[1][2] = 8 * g_ip->wire_F_sz_um;
            aspect_ratio = 2.2;
            wire_width = wire_pitch[1][2] / 2;
            wire_thickness = aspect_ratio * wire_width;
***************
*** 1421,1431 ****
        else if (tech == 7) {
          if ( !g_ip->is_itrs2012 ) { // wire data from Ron Ho's PhD Thesis, Stanford, 2003.
            //Aggressive projections.
!           wire_pitch[0][0] = 2.5 * g_ip->F_sz_um;
!           aspect_ratio = 3.0;
!           wire_width = wire_pitch[0][0] / 2;
!           wire_thickness = aspect_ratio * wire_width;
!           wire_spacing = wire_pitch[0][0] - wire_width;
            barrier_thickness = 0;
            dishing_thickness = 0;
            alpha_scatter = 1;
--- 1447,1468 ----
        else if (tech == 7) {
          if ( !g_ip->is_itrs2012 ) { // wire data from Ron Ho's PhD Thesis, Stanford, 2003.
            //Aggressive projections.
!         	//Divya adding for ASAP7 wire data. If itrs_2012 = false and asap7 = true . *** ONLY FOR AGGRESSIVE PROJECTIONS ***
!         	if(g_ip->is_asap7) { //Local wires
!         		wire_pitch[0][0] = 0.036;	//Local wires
!         		wire_width = 0.018;
! 			    wire_spacing = 0.018;
! 			    wire_thickness = 0.036;
!         		aspect_ratio = 2.0;
!         	}
!         	else { //Rohno 2003 PhD
! 			  wire_pitch[0][0] = 2.5 * g_ip->wire_F_sz_um;
! 			  aspect_ratio = 3.0;
! 			  wire_width = wire_pitch[0][0] / 2;
! 			  wire_thickness = aspect_ratio * wire_width;
! 			  wire_spacing = wire_pitch[0][0] - wire_width;
!         	}
!         	//divya end
            barrier_thickness = 0;
            dishing_thickness = 0;
            alpha_scatter = 1;
***************
*** 1440,1460 ****
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[0][1] = 4 * g_ip->F_sz_um;
            wire_width = wire_pitch[0][1] / 2;
            wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[0][1] - wire_width;
            wire_r_per_micron[0][1] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
            wire_c_per_micron[0][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[0][2] = 8 * g_ip->F_sz_um;
!           aspect_ratio = 3.0;
!           wire_width = wire_pitch[0][2] / 2;
!           wire_thickness = aspect_ratio * wire_width;
!           wire_spacing = wire_pitch[0][2] - wire_width;
            wire_r_per_micron[0][2] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
            ild_thickness = 0.130;
--- 1477,1517 ----
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           //Divya adding for ASAP7 wire data. If itrs_2012 = false and asap7 = true
!           if(g_ip->is_asap7) { //semi-global wires
!         	  wire_pitch[0][1] = 0.048;	//semi-global wires
! 			  wire_width = 0.024;
! 			  wire_spacing = 0.024;
! 			  wire_thickness = 0.048;
! 			  aspect_ratio = 2.0;
!           } else {
!           wire_pitch[0][1] = 4 * g_ip->wire_F_sz_um;
            wire_width = wire_pitch[0][1] / 2;
            wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[0][1] - wire_width;
+           }
+           //divya end
            wire_r_per_micron[0][1] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
            wire_c_per_micron[0][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           //Divya adding for ASAP7 wire data. If itrs_2012 = false and asap7 = true
! 		   if(g_ip->is_asap7) { //Global wires
! 			  wire_pitch[0][2] = 0.08;	//global wires
! 			  wire_width = 0.04;
! 			  wire_spacing = 0.032;
! 			  wire_thickness = 0.08;
! 			  aspect_ratio = 2.0;
! 		   } else {
! 			  wire_pitch[0][2] = 8 * g_ip->wire_F_sz_um;
! 			  aspect_ratio = 3.0;
! 			  wire_width = wire_pitch[0][2] / 2;
! 			  wire_thickness = aspect_ratio * wire_width;
! 			  wire_spacing = wire_pitch[0][2] - wire_width;
!            }
! 		   //divya end
            wire_r_per_micron[0][2] = wire_resistance(BULK_CU_RESISTIVITY, wire_width,
                wire_thickness, barrier_thickness, dishing_thickness, alpha_scatter);
            ild_thickness = 0.130;
***************
*** 1463,1469 ****
                fringe_cap);
            
            //Conservative projections
!           wire_pitch[1][0] = 2.5 * g_ip->F_sz_um;
            aspect_ratio = 2.0;
            wire_width = wire_pitch[1][0] / 2;
            wire_thickness = aspect_ratio * wire_width;
--- 1520,1526 ----
                fringe_cap);
            
            //Conservative projections
!           wire_pitch[1][0] = 2.5 * g_ip->wire_F_sz_um;
            aspect_ratio = 2.0;
            wire_width = wire_pitch[1][0] / 2;
            wire_thickness = aspect_ratio * wire_width;
***************
*** 1481,1488 ****
            wire_c_per_micron[1][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
!           
!           wire_pitch[1][1] = 4 * g_ip->F_sz_um;
            wire_width = wire_pitch[1][1] / 2;
            wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[1][1] - wire_width;
--- 1538,1545 ----
            wire_c_per_micron[1][0] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
! 
!           wire_pitch[1][1] = 4 * g_ip->wire_F_sz_um;
            wire_width = wire_pitch[1][1] / 2;
            wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[1][1] - wire_width;
***************
*** 1491,1498 ****
            wire_c_per_micron[1][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
!           
!           wire_pitch[1][2] = 8 * g_ip->F_sz_um;
            aspect_ratio = 2.2;
            wire_width = wire_pitch[1][2] / 2;
            wire_thickness = aspect_ratio * wire_width;
--- 1548,1556 ----
            wire_c_per_micron[1][1] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
! 
! 
!           wire_pitch[1][2] = 8 * g_ip->wire_F_sz_um;
            aspect_ratio = 2.2;
            wire_width = wire_pitch[1][2] / 2;
            wire_thickness = aspect_ratio * wire_width;
***************
*** 1504,1510 ****
--- 1562,1570 ----
            wire_c_per_micron[1][2] = wire_capacitance(wire_width, wire_thickness, wire_spacing, 
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
+ 
          }
+ 
          else { // wire data from ITRS 2012 reports, by Woojoo Lee, USC.
            wire_pitch[0][0]        = 0.034;
            wire_pitch[0][1]        = 0.034;
***************
*** 1531,1537 ****
        else if (tech == 5) {
          if ( !g_ip->is_itrs2012 ) { // wire data from Ron Ho's PhD Thesis, Stanford, 2003.
            //Aggressive projections.
!           wire_pitch[0][0] = 2.5 * g_ip->F_sz_um;
            aspect_ratio = 3.0;
            wire_width = wire_pitch[0][0] / 2;
            wire_thickness = aspect_ratio * wire_width;
--- 1591,1597 ----
        else if (tech == 5) {
          if ( !g_ip->is_itrs2012 ) { // wire data from Ron Ho's PhD Thesis, Stanford, 2003.
            //Aggressive projections.
!           wire_pitch[0][0] = 2.5 * g_ip->wire_F_sz_um;
            aspect_ratio = 3.0;
            wire_width = wire_pitch[0][0] / 2;
            wire_thickness = aspect_ratio * wire_width;
***************
*** 1550,1556 ****
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[0][1] = 4 * g_ip->F_sz_um;
            wire_width = wire_pitch[0][1] / 2;
            wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[0][1] - wire_width;
--- 1610,1616 ----
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[0][1] = 4 * g_ip->wire_F_sz_um;
            wire_width = wire_pitch[0][1] / 2;
            wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[0][1] - wire_width;
***************
*** 1560,1566 ****
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[0][2] = 8 * g_ip->F_sz_um;
            aspect_ratio = 3.0;
            wire_width = wire_pitch[0][2] / 2;
            wire_thickness = aspect_ratio * wire_width;
--- 1620,1626 ----
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[0][2] = 8 * g_ip->wire_F_sz_um;
            aspect_ratio = 3.0;
            wire_width = wire_pitch[0][2] / 2;
            wire_thickness = aspect_ratio * wire_width;
***************
*** 1573,1579 ****
                fringe_cap);
            
            //Conservative projections
!           wire_pitch[1][0] = 2.5 * g_ip->F_sz_um;
            aspect_ratio = 2.0;
            wire_width = wire_pitch[1][0] / 2;
            wire_thickness = aspect_ratio * wire_width;
--- 1633,1639 ----
                fringe_cap);
            
            //Conservative projections
!           wire_pitch[1][0] = 2.5 * g_ip->wire_F_sz_um;
            aspect_ratio = 2.0;
            wire_width = wire_pitch[1][0] / 2;
            wire_thickness = aspect_ratio * wire_width;
***************
*** 1592,1598 ****
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[1][1] = 4 * g_ip->F_sz_um;
            wire_width = wire_pitch[1][1] / 2;
            wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[1][1] - wire_width;
--- 1652,1658 ----
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[1][1] = 4 * g_ip->wire_F_sz_um;
            wire_width = wire_pitch[1][1] / 2;
            wire_thickness = aspect_ratio * wire_width;
            wire_spacing = wire_pitch[1][1] - wire_width;
***************
*** 1602,1608 ****
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[1][2] = 8 * g_ip->F_sz_um;
            aspect_ratio = 2.2;
            wire_width = wire_pitch[1][2] / 2;
            wire_thickness = aspect_ratio * wire_width;
--- 1662,1668 ----
                ild_thickness, miller_value, horiz_dielectric_constant, vert_dielectric_constant,
                fringe_cap);
            
!           wire_pitch[1][2] = 8 * g_ip->wire_F_sz_um;
            aspect_ratio = 2.2;
            wire_width = wire_pitch[1][2] / 2;
            wire_thickness = aspect_ratio * wire_width;
diff -crB pcacti_xml/uca.cc fncacti/uca.cc
*** pcacti_xml/uca.cc	2014-07-03 13:20:06.000000000 +0530
--- fncacti/uca.cc	2021-08-27 16:56:52.923894214 +0530
***************
*** 214,220 ****
    power_routing_to_bank.writeOp.dynamic = htree_in_add->power.readOp.dynamic + htree_in_data->power.readOp.dynamic;
    power_routing_to_bank.readOp.leakage += htree_in_add->power.readOp.leakage +
                                            htree_in_data->power.readOp.leakage +
!                                           htree_out_data->power.readOp.leakage;
  
    power.readOp.dynamic += power_routing_to_bank.readOp.dynamic;
    power.readOp.leakage += power_routing_to_bank.readOp.leakage;
--- 213,219 ----
    power_routing_to_bank.writeOp.dynamic = htree_in_add->power.readOp.dynamic + htree_in_data->power.readOp.dynamic;
    power_routing_to_bank.readOp.leakage += htree_in_add->power.readOp.leakage +
                                            htree_in_data->power.readOp.leakage +
! 										  htree_out_data->power.readOp.leakage;
  
    power.readOp.dynamic += power_routing_to_bank.readOp.dynamic;
    power.readOp.leakage += power_routing_to_bank.readOp.leakage;
diff -crB pcacti_xml/Ucache.cc fncacti/Ucache.cc
*** pcacti_xml/Ucache.cc	2014-07-03 13:17:06.000000000 +0530
--- fncacti/Ucache.cc	2021-08-27 17:04:24.327213262 +0530
***************
*** 130,136 ****
  
    bool is_valid_partition;
    int wt_min, wt_max;
! 
    if (g_ip->force_wiretype) {
      if (g_ip->wt == 0) {
        wt_min = Low_swing;
--- 130,136 ----
  
    bool is_valid_partition;
    int wt_min, wt_max;
! /*
    if (g_ip->force_wiretype) {
      if (g_ip->wt == 0) {
        wt_min = Low_swing;
***************
*** 145,150 ****
--- 145,161 ----
      wt_min = Global;
      wt_max = Low_swing;
    }
+ */
+ 
+   //Divya adding this
+   if (!g_ip->force_wiretype) {
+ 	  wt_min = Global;
+ 	  wt_max = Low_swing;
+   }
+   else  { //force_wiretype == true
+ 	  wt_min = g_ip->wt;
+ 	  wt_max = g_ip->wt;
+   }
  
    for (double Nspd = Nspd_min; Nspd <= MAXDATASPD; Nspd *= 2)
    {
***************
*** 161,179 ****
            for(unsigned int Ndsam_lev_2 = 1; Ndsam_lev_2 <= MAX_COL_MUX; Ndsam_lev_2 *= 2)
            {
              //for debuging
!             if (g_ip->force_cache_config && is_tag == false)
              {
!               wr   = g_ip->wt;
!               Ndwl = g_ip->ndwl;
!               Ndbl = g_ip->ndbl;
!               Ndcm = g_ip->ndcm;
!               if(g_ip->nspd != 0) {
!                 Nspd = g_ip->nspd;
!               }
!               if(g_ip->ndsam1 != 0) {
!                 Ndsam_lev_1 = g_ip->ndsam1;
!                 Ndsam_lev_2 = g_ip->ndsam2;
!               }
              }
  
              if (is_tag == true)
--- 172,210 ----
            for(unsigned int Ndsam_lev_2 = 1; Ndsam_lev_2 <= MAX_COL_MUX; Ndsam_lev_2 *= 2)
            {
              //for debuging
!         	  //Divya changing this so that Tag array parameters also take same value as data array parameters in force_onfig is true
!             if (g_ip->force_cache_config)// && is_tag == false) //divya
              {
!        		  wr   = g_ip->wt;
!        		  if(is_tag == false) { //divya added this line
! 				  Ndwl = g_ip->ndwl;
! 				  Ndbl = g_ip->ndbl;
! 				  Ndcm = g_ip->ndcm;
! 				  if(g_ip->nspd != 0) {
! 					Nspd = g_ip->nspd;
! 				  }
! 				  if(g_ip->ndsam1 != 0) {
! 					Ndsam_lev_1 = g_ip->ndsam1;
! 					Ndsam_lev_2 = g_ip->ndsam2;
! 				  }
!        		  }
!        		  //Divya adding tag params
!        		  else { //is_tag == true
!        			 Ndwl = g_ip->ntwl;
! 				  Ndbl = g_ip->ntbl;
! 				  Ndcm = g_ip->ntcm;
! 				  if(g_ip->ntspd != 0) {
! 					Nspd = g_ip->ntspd;
! 				  }
! 				  if(g_ip->ntsam1 != 0) {
! 					Ndsam_lev_1 = g_ip->ntsam1;
! 					Ndsam_lev_2 = g_ip->ntsam2;
! 				  }
!        		  }//divya added end
!             }
!             // Divya adding to propagate wire signalling effect when force_cache_config is false
!             else {
!             	g_ip->wt = (enum Wire_type) wr;
              }
  
              if (is_tag == true)
***************
*** 209,215 ****
                }
              }
  
!             if (g_ip->force_cache_config && is_tag == false)
              {
                wr   = wt_max;
                iter = niter;
--- 242,249 ----
                }
              }
  
!             //Divya changing this so that Tag array parameters also take same value as data array parameters in force_onfig is true
!             if (g_ip->force_cache_config) // && is_tag == false) //if (g_ip->force_cache_config && is_tag == false) //original.
              {
                wr   = wt_max;
                iter = niter;
***************
*** 266,362 ****
    }
    else
    {
!     ptr_array->Ndwl = Ndwl;
!     ptr_array->Ndbl = Ndbl;
!     ptr_array->Nspd = Nspd;
!     ptr_array->deg_bl_muxing = dyn_p.deg_bl_muxing;
!     ptr_array->Ndsam_lev_1 = Ndsam_lev_1;
!     ptr_array->Ndsam_lev_2 = Ndsam_lev_2;
!     ptr_array->access_time = uca->access_time;
!     ptr_array->cycle_time = uca->cycle_time;
!     ptr_array->multisubbank_interleave_cycle_time = uca->multisubbank_interleave_cycle_time;
!     ptr_array->area_ram_cells = uca->area_all_dataramcells;
!     ptr_array->area   = uca->area.get_area();
!     ptr_array->height = uca->area.h;
!     ptr_array->width  = uca->area.w;
!     ptr_array->mat_height = uca->bank.mat.area.h;
!     ptr_array->mat_length = uca->bank.mat.area.w;
!     ptr_array->subarray_height = uca->bank.mat.subarray.area.h;
!     ptr_array->subarray_length = uca->bank.mat.subarray.area.w;
!     ptr_array->power  = uca->power;
!     ptr_array->delay_senseamp_mux_decoder =
!       MAX(uca->delay_array_to_sa_mux_lev_1_decoder,
!           uca->delay_array_to_sa_mux_lev_2_decoder);
!     ptr_array->delay_before_subarray_output_driver         = uca->delay_before_subarray_output_driver;
!     ptr_array->delay_from_subarray_output_driver_to_output = uca->delay_from_subarray_out_drv_to_out;
! 
!     ptr_array->delay_route_to_bank          = uca->htree_in_add->delay;
!     ptr_array->delay_input_htree            = uca->bank.htree_in_add->delay;
!     ptr_array->delay_row_predecode_driver_and_block = uca->bank.mat.r_predec->delay;
!     ptr_array->delay_row_decoder            = uca->bank.mat.row_dec->delay;
!     ptr_array->delay_bitlines               = uca->bank.mat.delay_bitline;
!     ptr_array->delay_sense_amp              = uca->bank.mat.delay_sa;
!     ptr_array->delay_subarray_output_driver = uca->bank.mat.delay_subarray_out_drv_htree;
!     ptr_array->delay_dout_htree             = uca->bank.htree_out_data->delay;
!     ptr_array->delay_comparator             = uca->bank.mat.delay_comparator;
! 
!     ptr_array->all_banks_height = uca->area.h;
!     ptr_array->all_banks_width  = uca->area.w;    
!     ptr_array->area_efficiency = uca->area_all_dataramcells * 100 / (uca->area.get_area());
! 
!     ptr_array->power_routing_to_bank = uca->power_routing_to_bank;
!     ptr_array->power_addr_input_htree = uca->bank.htree_in_add->power;
!     ptr_array->power_data_input_htree = uca->bank.htree_in_data->power;
!     ptr_array->power_data_output_htree = uca->bank.htree_out_data->power;
! 
!     ptr_array->power_row_predecoder_drivers.readOp.dynamic = uca->bank.mat.r_predec->driver_power.readOp.dynamic * dyn_p.num_act_mats_hor_dir;
!     ptr_array->power_row_predecoder_blocks.readOp.dynamic = uca->bank.mat.r_predec->block_power.readOp.dynamic * dyn_p.num_act_mats_hor_dir;
! 
!     ptr_array->power_row_decoders.readOp.dynamic = uca->bank.mat.power_row_decoders.readOp.dynamic * dyn_p.num_act_mats_hor_dir;
! 
!     ptr_array->power_bit_mux_predecoder_drivers.readOp.dynamic = uca->bank.mat.b_mux_predec->driver_power.readOp.dynamic * dyn_p.num_act_mats_hor_dir;
!     ptr_array->power_bit_mux_predecoder_blocks.readOp.dynamic  = uca->bank.mat.b_mux_predec->block_power.readOp.dynamic * dyn_p.num_act_mats_hor_dir;
!     ptr_array->power_bit_mux_decoders.readOp.dynamic = uca->bank.mat.power_bit_mux_decoders.readOp.dynamic * dyn_p.num_act_mats_hor_dir;
!     ptr_array->power_senseamp_mux_lev_1_predecoder_drivers.readOp.dynamic = uca->bank.mat.sa_mux_lev_1_predec->driver_power.readOp.dynamic * dyn_p.num_act_mats_hor_dir;
!     ptr_array->power_senseamp_mux_lev_1_predecoder_blocks.readOp.dynamic = uca->bank.mat.sa_mux_lev_1_predec->block_power.readOp.dynamic * dyn_p.num_act_mats_hor_dir;
!     ptr_array->power_senseamp_mux_lev_1_decoders.readOp.dynamic = uca->bank.mat.power_sa_mux_lev_1_decoders.readOp.dynamic * dyn_p.num_act_mats_hor_dir;
!     ptr_array->power_senseamp_mux_lev_2_predecoder_drivers.readOp.dynamic = uca->bank.mat.sa_mux_lev_2_predec->driver_power.readOp.dynamic * dyn_p.num_act_mats_hor_dir;
!     ptr_array->power_senseamp_mux_lev_2_predecoder_blocks.readOp.dynamic = uca->bank.mat.sa_mux_lev_2_predec->block_power.readOp.dynamic * dyn_p.num_act_mats_hor_dir;
!     ptr_array->power_senseamp_mux_lev_2_decoders.readOp.dynamic = uca->bank.mat.power_sa_mux_lev_2_decoders.readOp.dynamic * dyn_p.num_act_mats_hor_dir;
!     ptr_array->power_bitlines.readOp.dynamic = uca->bank.mat.power_bitline.readOp.dynamic * dyn_p.num_act_mats_hor_dir;
!     ptr_array->power_sense_amps.readOp.dynamic = uca->bank.mat.power_sa.readOp.dynamic * dyn_p.num_act_mats_hor_dir;
!     ptr_array->power_prechg_eq_drivers.readOp.dynamic = uca->bank.mat.power_bl_precharge_eq_drv.readOp.dynamic * dyn_p.num_act_mats_hor_dir;
!     ptr_array->power_output_drivers_at_subarray.readOp.dynamic = uca->bank.mat.power_subarray_out_drv.readOp.dynamic * dyn_p.num_act_mats_hor_dir;
!     ptr_array->power_comparators.readOp.dynamic = uca->bank.mat.power_comparator.readOp.dynamic * dyn_p.num_act_mats_hor_dir;
! 
!     ptr_array->activate_energy = uca->activate_energy;
!     ptr_array->read_energy = uca->read_energy;
!     ptr_array->write_energy = uca->write_energy;
!     ptr_array->precharge_energy = uca->precharge_energy;
!     ptr_array->refresh_power = uca->refresh_power;
!     ptr_array->leak_power_subbank_closed_page = uca->leak_power_subbank_closed_page;
!     ptr_array->leak_power_subbank_open_page = uca->leak_power_subbank_open_page;
!     ptr_array->leak_power_request_and_reply_networks = uca->leak_power_request_and_reply_networks;
! 
!     ptr_array->precharge_delay = uca->precharge_delay;
! 	 
!   // Alireza - Begin
!     ptr_array->leak_power_bank = uca->bank.power.readOp.leakage;
!     ptr_array->leak_power_mat = uca->bank.mat.power.readOp.leakage;
!     ptr_array->leak_power_sram_cell = uca->bank.mat.leak_power_sram_cell;
!     ptr_array->leak_power_mem_array = uca->bank.mat.power_bitline.readOp.leakage;
! 	 
!     ptr_array->subarray_num_rows = uca->bank.mat.subarray.num_rows;
!     ptr_array->subarray_num_cols = uca->bank.mat.subarray.num_cols;
!     ptr_array->num_subarrays_per_mat = uca->bank.mat.num_subarrays_per_mat;
!   // Alireza - End
    }
  
    delete uca;
    return true;
  }
  
  
  
  bool check_uca_org(uca_org_t & u, min_values_t *minval) 
  {
--- 300,414 ----
    }
    else
    {
! 	  collect_uca_results(Nspd, Ndwl, Ndbl, Ndcm, Ndsam_lev_1, Ndsam_lev_2, uca, ptr_array, is_main_mem);
! 
    }
  
    delete uca;
    return true;
  }
  
+ //Divya added
+ void collect_uca_results(
+     double Nspd,
+     unsigned int Ndwl,
+     unsigned int Ndbl,
+     unsigned int Ndcm,
+     unsigned int Ndsam_lev_1,
+     unsigned int Ndsam_lev_2,
+     UCA const * const uca,
+     mem_array * const ptr_array,
+     bool is_main_mem)
+ {
+ 	int num_act_mats_hor_dir = uca->bank.dp.num_act_mats_hor_dir;
+ //	int num_mats = uca->bank.dp.num_mats;
  
+ 	   ptr_array->Ndwl = Ndwl;
+ 	    ptr_array->Ndbl = Ndbl;
+ 	    ptr_array->Nspd = Nspd;
+ 	    ptr_array->deg_bl_muxing = uca->bank.dp.deg_bl_muxing;
+ 	    ptr_array->Ndsam_lev_1 = Ndsam_lev_1;
+ 	    ptr_array->Ndsam_lev_2 = Ndsam_lev_2;
+ 	    ptr_array->access_time = uca->access_time;
+ 	    ptr_array->cycle_time = uca->cycle_time;
+ 	    ptr_array->multisubbank_interleave_cycle_time = uca->multisubbank_interleave_cycle_time;
+ 	    ptr_array->area_ram_cells = uca->area_all_dataramcells;
+ 	    ptr_array->area   = uca->area.get_area();
+ 	    ptr_array->height = uca->area.h;
+ 	    ptr_array->width  = uca->area.w;
+ 	    ptr_array->mat_height = uca->bank.mat.area.h;
+ 	    ptr_array->mat_length = uca->bank.mat.area.w;
+ 	    ptr_array->subarray_height = uca->bank.mat.subarray.area.h;
+ 	    ptr_array->subarray_length = uca->bank.mat.subarray.area.w;
+ 	    ptr_array->power  = uca->power;
+ 	    ptr_array->delay_senseamp_mux_decoder =
+ 	      MAX(uca->delay_array_to_sa_mux_lev_1_decoder,
+ 	          uca->delay_array_to_sa_mux_lev_2_decoder);
+ 	    ptr_array->delay_before_subarray_output_driver         = uca->delay_before_subarray_output_driver;
+ 	    ptr_array->delay_from_subarray_output_driver_to_output = uca->delay_from_subarray_out_drv_to_out;
+ 
+ 	    ptr_array->delay_route_to_bank          = uca->htree_in_add->delay;
+ 	    ptr_array->delay_input_htree            = uca->bank.htree_in_add->delay;
+ 	    ptr_array->delay_row_predecode_driver_and_block = uca->bank.mat.r_predec->delay;
+ 	    ptr_array->delay_row_decoder            = uca->bank.mat.row_dec->delay;
+ 	    ptr_array->delay_bitlines               = uca->bank.mat.delay_bitline;
+ 	    ptr_array->delay_sense_amp              = uca->bank.mat.delay_sa;
+ 	    ptr_array->delay_subarray_output_driver = uca->bank.mat.delay_subarray_out_drv_htree;
+ 	    ptr_array->delay_dout_htree             = uca->bank.htree_out_data->delay;
+ 	    ptr_array->delay_comparator             = uca->bank.mat.delay_comparator;
+ 
+ 	    ptr_array->all_banks_height = uca->area.h;
+ 	    ptr_array->all_banks_width  = uca->area.w;
+ 	    ptr_array->area_efficiency = uca->area_all_dataramcells * 100 / (uca->area.get_area());
+ 
+ 	    ptr_array->power_routing_to_bank = uca->power_routing_to_bank;
+ 	    ptr_array->power_addr_input_htree = uca->bank.htree_in_add->power;
+ 	    ptr_array->power_data_input_htree = uca->bank.htree_in_data->power;
+ 	    ptr_array->power_data_output_htree = uca->bank.htree_out_data->power;
+ 
+ 	    ptr_array->power_row_predecoder_drivers.readOp.dynamic = uca->bank.mat.r_predec->driver_power.readOp.dynamic * num_act_mats_hor_dir;
+ 	    ptr_array->power_row_predecoder_blocks.readOp.dynamic = uca->bank.mat.r_predec->block_power.readOp.dynamic * num_act_mats_hor_dir;
+ 
+ 	    ptr_array->power_row_decoders.readOp.dynamic = uca->bank.mat.power_row_decoders.readOp.dynamic * num_act_mats_hor_dir;
+ 
+ 	    ptr_array->power_bit_mux_predecoder_drivers.readOp.dynamic = uca->bank.mat.b_mux_predec->driver_power.readOp.dynamic * num_act_mats_hor_dir;
+ 	    ptr_array->power_bit_mux_predecoder_blocks.readOp.dynamic  = uca->bank.mat.b_mux_predec->block_power.readOp.dynamic * num_act_mats_hor_dir;
+ 	    ptr_array->power_bit_mux_decoders.readOp.dynamic = uca->bank.mat.power_bit_mux_decoders.readOp.dynamic * num_act_mats_hor_dir;
+ 	    ptr_array->power_senseamp_mux_lev_1_predecoder_drivers.readOp.dynamic = uca->bank.mat.sa_mux_lev_1_predec->driver_power.readOp.dynamic * num_act_mats_hor_dir;
+ 	    ptr_array->power_senseamp_mux_lev_1_predecoder_blocks.readOp.dynamic = uca->bank.mat.sa_mux_lev_1_predec->block_power.readOp.dynamic * num_act_mats_hor_dir;
+ 	    ptr_array->power_senseamp_mux_lev_1_decoders.readOp.dynamic = uca->bank.mat.power_sa_mux_lev_1_decoders.readOp.dynamic * num_act_mats_hor_dir;
+ 	    ptr_array->power_senseamp_mux_lev_2_predecoder_drivers.readOp.dynamic = uca->bank.mat.sa_mux_lev_2_predec->driver_power.readOp.dynamic * num_act_mats_hor_dir;
+ 	    ptr_array->power_senseamp_mux_lev_2_predecoder_blocks.readOp.dynamic = uca->bank.mat.sa_mux_lev_2_predec->block_power.readOp.dynamic * num_act_mats_hor_dir;
+ 	    ptr_array->power_senseamp_mux_lev_2_decoders.readOp.dynamic = uca->bank.mat.power_sa_mux_lev_2_decoders.readOp.dynamic * num_act_mats_hor_dir;
+ 	    ptr_array->power_bitlines.readOp.dynamic = uca->bank.mat.power_bitline.readOp.dynamic * num_act_mats_hor_dir;
+ 	    ptr_array->power_sense_amps.readOp.dynamic = uca->bank.mat.power_sa.readOp.dynamic * num_act_mats_hor_dir;
+ 	    ptr_array->power_prechg_eq_drivers.readOp.dynamic = uca->bank.mat.power_bl_precharge_eq_drv.readOp.dynamic * num_act_mats_hor_dir;
+ 	    ptr_array->power_output_drivers_at_subarray.readOp.dynamic = uca->bank.mat.power_subarray_out_drv.readOp.dynamic * num_act_mats_hor_dir;
+ 	    ptr_array->power_comparators.readOp.dynamic = uca->bank.mat.power_comparator.readOp.dynamic * num_act_mats_hor_dir;
+ 
+ 	    ptr_array->activate_energy = uca->activate_energy;
+ 	    ptr_array->read_energy = uca->read_energy;
+ 	    ptr_array->write_energy = uca->write_energy;
+ 	    ptr_array->precharge_energy = uca->precharge_energy;
+ 	    ptr_array->refresh_power = uca->refresh_power;
+ 	    ptr_array->leak_power_subbank_closed_page = uca->leak_power_subbank_closed_page;
+ 	    ptr_array->leak_power_subbank_open_page = uca->leak_power_subbank_open_page;
+ 	    ptr_array->leak_power_request_and_reply_networks = uca->leak_power_request_and_reply_networks;
+ 
+ 	    ptr_array->precharge_delay = uca->precharge_delay;
+ 
+ 	  // Alireza - Begin
+ 	    ptr_array->leak_power_bank = uca->bank.power.readOp.leakage;
+ 	    ptr_array->leak_power_mat = uca->bank.mat.power.readOp.leakage;
+ 	    ptr_array->leak_power_sram_cell = uca->bank.mat.leak_power_sram_cell;
+ 	    ptr_array->leak_power_mem_array = uca->bank.mat.power_bitline.readOp.leakage;
+ 
+ 	    ptr_array->subarray_num_rows = uca->bank.mat.subarray.num_rows;
+ 	    ptr_array->subarray_num_cols = uca->bank.mat.subarray.num_cols;
+ 	    ptr_array->num_subarrays_per_mat = uca->bank.mat.num_subarrays_per_mat;
+ 	  // Alireza - End
+ }
+ //Divye end
  
  bool check_uca_org(uca_org_t & u, min_values_t *minval) 
  {
***************
*** 414,420 ****
    double cost = 0;
    double min_cost = BIGNUM;
    float d, a, dp, lp, c;
! 
    dp = g_ip->dynamic_power_wt;
    lp = g_ip->leakage_power_wt;
    a  = g_ip->area_wt;
--- 464,470 ----
    double cost = 0;
    double min_cost = BIGNUM;
    float d, a, dp, lp, c;
! //  int count = 0; 	//divya
    dp = g_ip->dynamic_power_wt;
    lp = g_ip->leakage_power_wt;
    a  = g_ip->area_wt;
***************
*** 500,506 ****
  
    if (list.empty() == true)
    {
!     cout << "ERROR: no valid tag organizations found" << endl;
      exit(1);
    }
  
--- 550,556 ----
  
    if (list.empty() == true)
    {
!     cout << "ERROR: no valid tag organizations found: empty list" << endl;
      exit(1);
    }
  
***************
*** 537,543 ****
    }
    if(!res) 
    {
!     cout << "ERROR: no valid tag organizations found" << endl; 
      exit(0);
    }
  
--- 587,593 ----
    }
    if(!res) 
    {
!     cout << "ERROR: no valid tag organizations found: result NULL" << endl;
      exit(0);
    }
  
***************
*** 592,599 ****
    int    pure_ram = (!g_ip->is_cache || g_ip->is_main_mem);
  
  
!   init_tech_params(g_ip->F_sz_um, false);
! 
  
    list<mem_array *> tag_arr (0);
    list<mem_array *> data_arr(0);
--- 642,649 ----
    int    pure_ram = (!g_ip->is_cache || g_ip->is_main_mem);
  
  
! //  init_tech_params(g_ip->F_sz_um, false);
!   init_tech_params(g_ip->F_sz_um, g_ip->F_sz_um, false); //divya added wire technology
  
    list<mem_array *> tag_arr (0);
    list<mem_array *> data_arr(0);
***************
*** 630,636 ****
      is_tag              = true;
      ram_cell_tech_type  = g_ip->tag_arr_ram_cell_tech_type;
      is_dram             = ((ram_cell_tech_type == lp_dram) || (ram_cell_tech_type == comm_dram));
!     init_tech_params(g_ip->F_sz_um, is_tag);
  
      for (uint32_t t = 0; t < nthreads; t++)
      {
--- 680,687 ----
      is_tag              = true;
      ram_cell_tech_type  = g_ip->tag_arr_ram_cell_tech_type;
      is_dram             = ((ram_cell_tech_type == lp_dram) || (ram_cell_tech_type == comm_dram));
! //    init_tech_params(g_ip->F_sz_um, is_tag);
!     init_tech_params(g_ip->F_sz_um, g_ip->F_sz_um, false); //divya added wire technology
  
      for (uint32_t t = 0; t < nthreads; t++)
      {
***************
*** 661,667 ****
      is_tag              = false;
      ram_cell_tech_type  = g_ip->data_arr_ram_cell_tech_type;
      is_dram             = ((ram_cell_tech_type == lp_dram) || (ram_cell_tech_type == comm_dram));
!     init_tech_params(g_ip->F_sz_um, is_tag);
  
      for (uint32_t t = 0; t < nthreads; t++)
      {
--- 712,719 ----
      is_tag              = false;
      ram_cell_tech_type  = g_ip->data_arr_ram_cell_tech_type;
      is_dram             = ((ram_cell_tech_type == lp_dram) || (ram_cell_tech_type == comm_dram));
! //    init_tech_params(g_ip->F_sz_um, is_tag);
!     init_tech_params(g_ip->F_sz_um, g_ip->F_sz_um, false); //divya added wire technology
  
      for (uint32_t t = 0; t < nthreads; t++)
      {
***************
*** 782,784 ****
--- 834,901 ----
    delete t_min;
  }
  
+ void update_dvs(uca_org_t *fin_res)
+ {
+ 	double dvs_voltage = g_ip->dvs_start; //initial voltage
+ 	double dvs_volt_step = 0.1; //Voltage should be raised in steps of 0.1V
+ 	int num_dvs_voltages = (g_ip->dvs_end - g_ip->dvs_start)/dvs_volt_step;
+ 
+ 	int pure_ram = (!g_ip->is_cache || g_ip->is_main_mem);
+ 
+ 	if(fin_res->tag_array2 || fin_res->data_array2)
+ 	{
+ //		Wire::print_wire();
+ 		Wire winit;//init before changing dvs
+ 		for (unsigned int i=0; i< num_dvs_voltages+1; i++) //For voltages from 0.2V-0.8V in steps of 0.1 . Total 7 voltages
+ 		{
+ 			fin_res->uca_q.push_back(new uca_org_t());
+ 
+ 			g_ip->vdd = dvs_voltage;
+ 
+ 			init_tech_params(g_ip->F_sz_um, g_ip->wire_F_sz_um ,true);
+ 			winit.wire_dvs_update();//Wire::wire_dvs_update();//Wire winit (1,1, false);
+ //			winit.print_wire();
+ 
+ 			if(fin_res->tag_array2)
+ 			{
+ 				DynamicParameter tag_arr_dyn_p(true, pure_ram, fin_res->tag_array2->Nspd, fin_res->tag_array2->Ndwl, fin_res->tag_array2->Ndbl, fin_res->tag_array2->deg_bl_muxing, fin_res->tag_array2->Ndsam_lev_1, fin_res->tag_array2->Ndsam_lev_2, g_ip->is_main_mem);
+ 				if(tag_arr_dyn_p.is_valid)
+ 				{
+ 					UCA * tag_arr = new UCA(tag_arr_dyn_p);
+ 					fin_res->uca_q[i]->tag_array2 = new mem_array();
+ 
+ 					collect_uca_results(fin_res->tag_array2->Nspd, fin_res->tag_array2->Ndwl, fin_res->tag_array2->Ndbl, fin_res->tag_array2->deg_bl_muxing, fin_res->tag_array2->Ndsam_lev_1, fin_res->tag_array2->Ndsam_lev_2, tag_arr, fin_res->uca_q[i]->tag_array2, g_ip->is_main_mem);
+ 					delete tag_arr;
+ 				}
+ 
+ 			}
+ 			DynamicParameter data_arr_dyn_p(false, pure_ram, fin_res->data_array2->Nspd, fin_res->data_array2->Ndwl, fin_res->data_array2->Ndbl, fin_res->data_array2->deg_bl_muxing, fin_res->data_array2->Ndsam_lev_1, fin_res->data_array2->Ndsam_lev_2, g_ip->is_main_mem);
+ 			if(data_arr_dyn_p.is_valid)
+ 			{
+ 				UCA * data_arr = new UCA(data_arr_dyn_p);
+ 				fin_res->uca_q[i]->data_array2 = new mem_array();
+ 				collect_uca_results(fin_res->data_array2->Nspd, fin_res->data_array2->Ndwl, fin_res->data_array2->Ndbl, fin_res->data_array2->deg_bl_muxing, fin_res->data_array2->Ndsam_lev_1, fin_res->data_array2->Ndsam_lev_2, data_arr, fin_res->uca_q[i]->data_array2, g_ip->is_main_mem);
+ 				delete data_arr;
+ 			}
+ 
+ 			fin_res->uca_q[i]->find_delay();
+ 			fin_res->uca_q[i]->find_energy();
+ 			fin_res->uca_q[i]->find_area();
+ 			fin_res->uca_q[i]->find_cyc();
+ 
+ //            output_UCA(fin_res->uca_q[i]);
+ //            Wire::print_wire();
+ 
+ 			dvs_voltage = dvs_voltage + dvs_volt_step;
+ 		}
+ 		//reset input to original values in *.cfg file
+ 
+ 	//	init_tech_params(g_ip->F_sz_um, g_ip->wire_F_sz_um, true);
+ 	}
+ 	else
+ 	{
+ 		cout << "ERROR: Cannot retrieve array structure for tag and data array" << endl;
+ 		exit(1);
+ 	}
+ }
+ 
diff -crB pcacti_xml/Ucache.h fncacti/Ucache.h
*** pcacti_xml/Ucache.h	2014-07-03 13:18:30.000000000 +0530
--- fncacti/Ucache.h	2021-08-27 16:58:23.111702134 +0530
***************
*** 46,52 ****
  #include "area.h"
  #include "router.h"
  #include "nuca.h"
! 
   
  class min_values_t
  {
--- 46,52 ----
  #include "area.h"
  #include "router.h"
  #include "nuca.h"
! #include "uca.h"
   
  class min_values_t
  {
***************
*** 97,105 ****
      uca_org_t *ptr_fin_res,
      bool is_main_mem);
  
  
  void solve(uca_org_t *fin_res);
! void init_tech_params(double tech, bool is_tag);
  
  
  struct calc_time_mt_wrapper_struct
--- 95,118 ----
      uca_org_t *ptr_fin_res,
      bool is_main_mem);
  
+ //Divya added
+ void collect_uca_results(
+     double Nspd,
+     unsigned int Ndwl,
+     unsigned int Ndbl,
+     unsigned int Ndcm,
+     unsigned int Ndsam_lev_1,
+     unsigned int Ndsam_lev_2,
+     UCA const * const uca,
+     mem_array * const ptr_array,
+     bool is_main_mem);
+ 
+ void update_dvs(uca_org_t *fin_res);
+ //Divya end
  
  void solve(uca_org_t *fin_res);
! //void init_tech_params(double tech, bool is_tag);
! void init_tech_params(double tech, double wire_tech, bool is_tag); //divya added wire technology
  
  
  struct calc_time_mt_wrapper_struct
diff -crB pcacti_xml/wire.cc fncacti/wire.cc
*** pcacti_xml/wire.cc	2014-07-03 13:17:30.000000000 +0530
--- fncacti/wire.cc	2021-08-27 17:02:09.219940325 +0530
***************
*** 58,70 ****
    min_w_pmos     = deviceType->n_to_p_eff_curr_drv_ratio*g_tp.min_w_nmos_;
    in_rise_time   = 0;
    out_rise_time  = 0;
    calculate_wire_stats();
    // change everything back to seconds, microns, and Joules
    repeater_spacing *= 1e6;
    wire_length      *= 1e6;
    wire_width       *= 1e6;
    wire_spacing     *= 1e6;
! 
    assert(power.readOp.dynamic > 0);
    assert(power.readOp.leakage > 0);
  }
--- 58,77 ----
    min_w_pmos     = deviceType->n_to_p_eff_curr_drv_ratio*g_tp.min_w_nmos_;
    in_rise_time   = 0;
    out_rise_time  = 0;
+ 
+   //Divya added
+   if (initialized != 1) {
+     cout << "Wire not initialized. Initializing it with default values\n";
+     Wire winit;
+   }
+   //Divya end
    calculate_wire_stats();
    // change everything back to seconds, microns, and Joules
    repeater_spacing *= 1e6;
    wire_length      *= 1e6;
    wire_width       *= 1e6;
    wire_spacing     *= 1e6;
!   assert(wire_length > 0);
    assert(power.readOp.dynamic > 0);
    assert(power.readOp.leakage > 0);
  }
***************
*** 83,88 ****
--- 90,101 ----
  double Wire::wire_width_init;
  double Wire::wire_spacing_init;
  
+ //Divya added
+ int Wire::initialized;
+ double Wire::repeater_size_init; // value used in initialization should not be reused in final output
+ double Wire::repeater_spacing_init;
+ //Divya end
+ 
  Wire::Wire(double w_s, double s_s, enum Wire_placement wp, double resis, TechnologyParameter::DeviceType *dt)
  {
    w_scale        = w_s;
***************
*** 106,111 ****
--- 119,125 ----
    wire_width   *= (w_scale * 1e-6/2) /* (m) */;
    wire_spacing *= (s_scale * 1e-6/2) /* (m) */;
  
+   initialized = 1; //Divya added
    init_wire();
  
    wire_width_init = wire_width;
***************
*** 142,153 ****
    wire_width   *= (w_scale * 1e-6/2) /* (m) */;
    wire_spacing *= (s_scale * 1e-6/2) /* (m) */;
  
- 
    if (wt != Low_swing) { 
  
!     delay_optimal_wire();
! 
!     if (wt == Global_5) {
        delay = global_5.delay * wire_length;
        power.readOp.dynamic = global_5.power.readOp.dynamic * wire_length;
        power.readOp.leakage = global_5.power.readOp.leakage * wire_length;
--- 156,176 ----
    wire_width   *= (w_scale * 1e-6/2) /* (m) */;
    wire_spacing *= (s_scale * 1e-6/2) /* (m) */;
  
    if (wt != Low_swing) { 
  
! //Divya added
! 	  if (wt == Global) {
! 		  delay = global.delay * wire_length;
! 		  power.readOp.dynamic = global.power.readOp.dynamic * wire_length;
! 		  power.readOp.leakage = global.power.readOp.leakage * wire_length;
! 		  repeater_spacing = global.area.w;
! 		  repeater_size = global.area.h;
! 		  area.set_area((wire_length/repeater_spacing) *
! 				  compute_gate_area(INV, 1, min_w_pmos * repeater_size,
! 						  g_tp.min_w_nmos_ * repeater_size, g_tp.cell_h_def));
! 	  }
! //Divya end
! 	  else if (wt == Global_5) {
        delay = global_5.delay * wire_length;
        power.readOp.dynamic = global_5.power.readOp.dynamic * wire_length;
        power.readOp.leakage = global_5.power.readOp.leakage * wire_length;
***************
*** 473,488 ****
    double switching = 0;  // switching energy
    double short_ckt = 0;  // short-circuit energy
    double tc        = 0;  // time constant
!   // input cap of min sized driver 
!   double input_cap = gate_C(g_tp.min_w_nmos_ + min_w_pmos, 0);
  
     // output parasitic capacitance of
     // the min. sized driver
    double out_cap = drain_C_(min_w_pmos, PCH, 1, 1, g_tp.cell_h_def) +
      drain_C_(g_tp.min_w_nmos_, NCH, 1, 1, g_tp.cell_h_def);
!   // drive resistance 
    double out_res = (tr_R_on(g_tp.min_w_nmos_, NCH, 1) +
        tr_R_on(min_w_pmos, PCH, 1))/2;
    double wr = wire_res(len); //ohm
  
    // wire cap /m 
--- 496,512 ----
    double switching = 0;  // switching energy
    double short_ckt = 0;  // short-circuit energy
    double tc        = 0;  // time constant
! 
!   double input_cap = gate_C(g_tp.min_w_nmos_ + min_w_pmos, 0); //original
  
     // output parasitic capacitance of
     // the min. sized driver
    double out_cap = drain_C_(min_w_pmos, PCH, 1, 1, g_tp.cell_h_def) +
      drain_C_(g_tp.min_w_nmos_, NCH, 1, 1, g_tp.cell_h_def);
! 
    double out_res = (tr_R_on(g_tp.min_w_nmos_, NCH, 1) +
        tr_R_on(min_w_pmos, PCH, 1))/2;
+ 
    double wr = wire_res(len); //ohm
  
    // wire cap /m 
***************
*** 492,524 ****
    double repeater_scaling = sqrt(out_res*wc/(wr*input_cap)); // len will cancel
     
     // calc the optimum spacing between the repeaters (m)
!    
!   repeater_spacing = sqrt(2 * out_res * (out_cap + input_cap)/
!       ((wr/len)*(wc/len)));
!   repeater_size = repeater_scaling;
! 
!   switching = (repeater_scaling * (input_cap + out_cap) +
!       repeater_spacing * (wc/len)) * deviceType->Vdd * deviceType->Vdd;
  
-   tc = out_res * (input_cap + out_cap) +
-     out_res * wc/len * repeater_spacing/repeater_scaling +
-     wr/len * repeater_spacing * input_cap * repeater_scaling +
-     0.5 * (wr/len) * (wc/len)* repeater_spacing * repeater_spacing;
  
!   delay = 0.693 * tc * len/repeater_spacing;
  
! #define Ishort_ckt 65e-6 /* across all tech Ref:Banerjee et al. {IEEE TED} */
!   short_ckt = deviceType->Vdd * g_tp.min_w_nmos_ * Ishort_ckt * 1.0986 *
!     repeater_scaling * tc;
  
-   area.set_area((len/repeater_spacing) *
-                 compute_gate_area(INV, 1, min_w_pmos * repeater_scaling,
-                                           g_tp.min_w_nmos_ * repeater_scaling, g_tp.cell_h_def));
-   power.readOp.dynamic = ((len/repeater_spacing)*(switching + short_ckt));
-   power.readOp.leakage = ((len/repeater_spacing)*
-       (1+beta)/2*deviceType->Vdd*
-       deviceType->I_off_n*
-       g_tp.min_w_nmos_*repeater_scaling);
  }
  
  
--- 516,549 ----
    double repeater_scaling = sqrt(out_res*wc/(wr*input_cap)); // len will cancel
     
     // calc the optimum spacing between the repeaters (m)
!   repeater_spacing_init = sqrt(2 * out_res * (out_cap + input_cap)/
!   			  ((wr/len)*(wc/len)));
!   repeater_size_init = repeater_scaling;
  
  
!   switching = (repeater_scaling * (input_cap + out_cap) +
!        repeater_spacing_init * (wc/len)) * deviceType->Vdd * deviceType->Vdd;
  
!    tc = out_res * (input_cap + out_cap) +
!      out_res * wc/len * repeater_spacing_init/repeater_scaling +
!      wr/len * repeater_spacing_init * input_cap * repeater_scaling +
!      0.5 * (wr/len) * (wc/len)* repeater_spacing_init * repeater_spacing_init;
! 
!    delay = 0.693 * tc * len/repeater_spacing_init;
! 
!    #define Ishort_ckt 65e-6 // across all tech Ref:Banerjee et al. {IEEE TED}
!    short_ckt = deviceType->Vdd * g_tp.min_w_nmos_ * Ishort_ckt * 1.0986 *
!      repeater_scaling * tc;
! 
!    area.set_area((len/repeater_spacing_init) *
!                  compute_gate_area(INV, 1, min_w_pmos * repeater_scaling,
!                                            g_tp.min_w_nmos_ * repeater_scaling, g_tp.cell_h_def));
!    power.readOp.dynamic = ((len/repeater_spacing_init)*(switching + short_ckt));
!    power.readOp.leakage = ((len/repeater_spacing_init)*
!        (1+beta)/2*deviceType->Vdd*
!        deviceType->I_off_n*
!        g_tp.min_w_nmos_*repeater_scaling);
  
  }
  
  
***************
*** 530,537 ****
--- 555,568 ----
    delay_optimal_wire();
      double sp, si;
    powerDef pow;
+ /*//Original
    si = repeater_size;
    sp = repeater_spacing;
+ */
+   //Divya added
+   si = repeater_size_init ;
+   sp = repeater_spacing_init ;
+    //Divya end
    sp *= 1e6; // in microns
  
    double i, j, del;
***************
*** 545,555 ****
          global.area.h = si;
          global.area.w = sp*1e-6; // m
        }
! //      cout << "Repeater size - "<< i <<
! //        " Repeater spacing - " << j <<
! //        " Delay - " << del << 
! //        " PowerD - " << pow.readOp.dynamic <<
! //        " PowerL - " << pow.readOp.leakage <<endl;
        repeated_wire.back().delay = del;
        repeated_wire.back().power.readOp = pow.readOp;
        repeated_wire.back().area.w = j*1e-6; //m
--- 576,582 ----
          global.area.h = si;
          global.area.w = sp*1e-6; // m
        }
! 
        repeated_wire.back().delay = del;
        repeated_wire.back().power.readOp = pow.readOp;
        repeated_wire.back().area.w = j*1e-6; //m
***************
*** 620,625 ****
--- 647,655 ----
      }
      i--;
    }
+   citer = repeated_wire.begin();
+     while (!repeated_wire.empty()) //TODO: code optimize
+         {citer=repeated_wire.erase(citer);}
  }
  
  
***************
*** 682,736 ****
  {
  
    cout << "\nWire Properties:\n\n";
!   cout << "  Delay Optimal\n\tRepeater size - "<< global.area.h <<
!     " \n\tRepeater spacing - " << global.area.w*1e3 << " (mm)"
!     " \n\tDelay - " << global.delay*1e6 <<  " (ns/mm)" 
!     " \n\tPowerD - " << global.power.readOp.dynamic *1e6<< " (nJ/mm)"
!     " \n\tPowerL - " << global.power.readOp.leakage << " (mW/mm)\n";
!   cout << "\tWire width - " <<wire_width_init*1e6 << " microns\n";
!   cout << "\tWire spacing - " <<wire_spacing_init*1e6 << " microns\n";
    cout <<endl;
  
!   cout << "  5% Overhead\n\tRepeater size - "<< global_5.area.h <<
!     " \n\tRepeater spacing - " << global_5.area.w*1e3 << " (mm)"
!     " \n\tDelay - " << global_5.delay *1e6<<  " (ns/mm)" 
!     " \n\tPowerD - " << global_5.power.readOp.dynamic *1e6<< " (nJ/mm)"
!     " \n\tPowerL - " << global_5.power.readOp.leakage << " (mW/mm)\n"; 
!   cout << "\tWire width - " <<wire_width_init*1e6 << " microns\n";
!   cout << "\tWire spacing - " <<wire_spacing_init*1e6 << " microns\n";
    cout <<endl;
!   cout << "  10% Overhead\n\tRepeater size - "<< global_10.area.h <<
!     " \n\tRepeater spacing - " << global_10.area.w*1e3 << " (mm)"
!     " \n\tDelay - " << global_10.delay *1e6<<  " (ns/mm)" 
!     " \n\tPowerD - " << global_10.power.readOp.dynamic *1e6<< " (nJ/mm)"
!     " \n\tPowerL - " << global_10.power.readOp.leakage << " (mW/mm)\n"; 
!   cout << "\tWire width - " <<wire_width_init*1e6 << " microns\n";
!   cout << "\tWire spacing - " <<wire_spacing_init*1e6 << " microns\n";
    cout <<endl;
!   cout << "  20% Overhead\n\tRepeater size - "<< global_20.area.h <<
!     " \n\tRepeater spacing - " << global_20.area.w*1e3 << " (mm)"
!     " \n\tDelay - " << global_20.delay *1e6<<  " (ns/mm)" 
!     " \n\tPowerD - " << global_20.power.readOp.dynamic *1e6<< " (nJ/mm)"
!     " \n\tPowerL - " << global_20.power.readOp.leakage << " (mW/mm)\n"; 
!   cout << "\tWire width - " <<wire_width_init*1e6 << " microns\n";
!   cout << "\tWire spacing - " <<wire_spacing_init*1e6 << " microns\n";
    cout <<endl;
!   cout << "  30% Overhead\n\tRepeater size - "<< global_30.area.h <<
!     " \n\tRepeater spacing - " << global_30.area.w*1e3 << " (mm)"
!     " \n\tDelay - " << global_30.delay *1e6<<  " (ns/mm)" 
!     " \n\tPowerD - " << global_30.power.readOp.dynamic *1e6<< " (nJ/mm)"
!     " \n\tPowerL - " << global_30.power.readOp.leakage << " (mW/mm)\n"; 
!   cout << "\tWire width - " <<wire_width_init*1e6 << " microns\n";
!   cout << "\tWire spacing - " <<wire_spacing_init*1e6 << " microns\n";
    cout <<endl;
    cout << "  Low-swing wire (1 mm) - Note: Unlike repeated wires, \n\tdelay and power "
            "values of low-swing wires do not\n\thave a linear relationship with length." <<
!     " \n\tdelay - " << low_swing.delay *1e9<<  " (ns)" 
!     " \n\tpowerD - " << low_swing.power.readOp.dynamic *1e9<< " (nJ)"
!     " \n\tPowerL - " << low_swing.power.readOp.leakage << " (mW)\n"; 
!   cout << "\tWire width - " <<wire_width_init * 2 /* differential */<< " microns\n";
!   cout << "\tWire spacing - " <<wire_spacing_init * 2 /* differential */<< " microns\n";
    cout <<endl;
    cout <<endl;
  }
  
--- 712,794 ----
  {
  
    cout << "\nWire Properties:\n\n";
!   cout << "  Delay Optimal\n\tRepeater size : "<< global.area.h <<
!     " \n\tRepeater spacing : " << global.area.w*1e3 << " (mm)"
!     " \n\tDelay : " << global.delay*1e6 <<  " (ns/mm)"
!     " \n\tPowerD : " << global.power.readOp.dynamic *1e6<< " (nJ/mm)"
!     " \n\tPowerL : " << global.power.readOp.leakage << " (mW/mm)\n";
!   cout << "\tWire width : " <<wire_width_init*1e6 << " microns\n";
!   cout << "\tWire spacing : " <<wire_spacing_init*1e6 << " microns\n";
    cout <<endl;
  
!   cout << "  5% Overhead\n\tRepeater size : "<< global_5.area.h <<
!     " \n\tRepeater spacing : " << global_5.area.w*1e3 << " (mm)"
!     " \n\tDelay : " << global_5.delay *1e6<<  " (ns/mm)"
!     " \n\tPowerD : " << global_5.power.readOp.dynamic *1e6<< " (nJ/mm)"
!     " \n\tPowerL : " << global_5.power.readOp.leakage << " (mW/mm)\n";
!   cout << "\tWire width : " <<wire_width_init*1e6 << " microns\n";
!   cout << "\tWire spacing : " <<wire_spacing_init*1e6 << " microns\n";
    cout <<endl;
!   cout << "  10% Overhead\n\tRepeater size : "<< global_10.area.h <<
!     " \n\tRepeater spacing : " << global_10.area.w*1e3 << " (mm)"
!     " \n\tDelay : " << global_10.delay *1e6<<  " (ns/mm)"
!     " \n\tPowerD : " << global_10.power.readOp.dynamic *1e6<< " (nJ/mm)"
!     " \n\tPowerL : " << global_10.power.readOp.leakage << " (mW/mm)\n";
!   cout << "\tWire width : " <<wire_width_init*1e6 << " microns\n";
!   cout << "\tWire spacing : " <<wire_spacing_init*1e6 << " microns\n";
    cout <<endl;
!   cout << "  20% Overhead\n\tRepeater size : "<< global_20.area.h <<
!     " \n\tRepeater spacing : " << global_20.area.w*1e3 << " (mm)"
!     " \n\tDelay : " << global_20.delay *1e6<<  " (ns/mm)"
!     " \n\tPowerD : " << global_20.power.readOp.dynamic *1e6<< " (nJ/mm)"
!     " \n\tPowerL : " << global_20.power.readOp.leakage << " (mW/mm)\n";
!   cout << "\tWire width : " <<wire_width_init*1e6 << " microns\n";
!   cout << "\tWire spacing : " <<wire_spacing_init*1e6 << " microns\n";
    cout <<endl;
!   cout << "  30% Overhead\n\tRepeater size : "<< global_30.area.h <<
!     " \n\tRepeater spacing : " << global_30.area.w*1e3 << " (mm)"
!     " \n\tDelay : " << global_30.delay *1e6<<  " (ns/mm)"
!     " \n\tPowerD : " << global_30.power.readOp.dynamic *1e6<< " (nJ/mm)"
!     " \n\tPowerL : " << global_30.power.readOp.leakage << " (mW/mm)\n";
!   cout << "\tWire width : " <<wire_width_init*1e6 << " microns\n";
!   cout << "\tWire spacing : " <<wire_spacing_init*1e6 << " microns\n";
    cout <<endl;
    cout << "  Low-swing wire (1 mm) - Note: Unlike repeated wires, \n\tdelay and power "
            "values of low-swing wires do not\n\thave a linear relationship with length." <<
!     " \n\tdelay : " << low_swing.delay *1e9<<  " (ns)"
!     " \n\tpowerD : " << low_swing.power.readOp.dynamic *1e9<< " (nJ)"
!     " \n\tPowerL : " << low_swing.power.readOp.leakage << " (mW)\n";
!   cout << "\tWire width : " <<wire_width_init * 2 /* differential */<< " microns\n";
!   cout << "\tWire spacing : " <<wire_spacing_init * 2 /* differential */<< " microns\n";
    cout <<endl;
    cout <<endl;
  }
  
+ void
+ Wire::wire_dvs_update()
+ {
+ 
+ 	double i, j, del;
+ 	powerDef pow;
+ 	pow = wire_model(global.area.w, global.area.h, &del);
+ 	global.delay = del;
+ 	global.power = pow;
+ 	pow = wire_model(global_5.area.w, global_5.area.h, &del);
+ 	global_5.delay = del;
+ 	global_5.power = pow;
+ 	pow = wire_model(global_10.area.w, global_10.area.h, &del);
+ 	global_10.delay = del;
+ 	global_10.power = pow;
+ 	pow = wire_model(global_20.area.w, global_20.area.h, &del);
+ 	global_20.delay = del;
+ 	global_20.power = pow;
+ 	pow = wire_model(global_30.area.w, global_30.area.h, &del);
+ 	global_30.delay = del;
+ 	global_30.power = pow;
+ 
+ 	Wire *l_wire = new Wire(Low_swing, 0.001/* 1 mm*/, 1);
+ 	low_swing.delay = l_wire->delay;
+ 	low_swing.power = l_wire->power;
+ 	delete l_wire;
+ 
+ }
diff -crB pcacti_xml/wire.h fncacti/wire.h
*** pcacti_xml/wire.h	2014-07-03 13:20:26.000000000 +0530
--- fncacti/wire.h	2021-08-27 17:10:39.586537080 +0530
***************
*** 85,90 ****
--- 85,94 ----
      enum Wire_placement wire_placement;
      double repeater_size;
      double repeater_spacing;
+ //Divya added
+     static double repeater_size_init; // value used in initialization should not be reused in final output
+      static double repeater_spacing_init;
+ //Divya end
      double wire_length;
      double in_rise_time, out_rise_time;
  
***************
*** 101,106 ****
--- 105,111 ----
      static double wire_width_init;
      static double wire_spacing_init;
      void print_wire();
+     void wire_dvs_update(); //Divya added
  
    private:
  
***************
*** 115,120 ****
--- 120,126 ----
      list <Component> repeated_wire;
      void update_fullswing();
  
+     static int initialized; //Divya added
  
      //low-swing
      Component transmitter;
Only in pcacti_xml/xmls: cache_config_cmos.xml
Only in pcacti_xml/xmls: cache_config_finfet.xml
Only in fncacti/xmls: config_finfet.xml
Only in fncacti/xmls: config_ncfet.xml
Only in fncacti/xmls/devices: ncfet_std.xml
Only in fncacti/xmls/devices: new_finfet_std.xml
diff -crB pcacti_xml/xmls/sram_cells/finfet_sram_6T1.xml fncacti/xmls/sram_cells/finfet_sram_6T1.xml
*** pcacti_xml/xmls/sram_cells/finfet_sram_6T1.xml	2014-07-03 13:21:34.000000000 +0530
--- fncacti/xmls/sram_cells/finfet_sram_6T1.xml	2020-10-13 19:25:51.869703000 +0530
***************
*** 9,15 ****
  <sram_cell>
  	<type>6T</type>
  	<dual_gate_control>false</dual_gate_control>
! 	<device_type>xmls/devices/finfet_7nm_std.xml</device_type>
  	<leakage_power>
  		<bitline></bitline>
  		<cc_inverters></cc_inverters>
--- 9,15 ----
  <sram_cell>
  	<type>6T</type>
  	<dual_gate_control>false</dual_gate_control>
! 	<device_type>xmls/devices/new_finfet_std.xml</device_type>
  	<leakage_power>
  		<bitline></bitline>
  		<cc_inverters></cc_inverters>
***************
*** 17,31 ****
  	<transistor_parameters>
  		<acc> <!-- access transistors -->
  			<num_of_fins>1</num_of_fins>
! 			<device_type>xmls/devices/finfet_7nm_std.xml</device_type>
  		</acc>
  		<pup> <!-- pull up transistors -->
  			<num_of_fins>1</num_of_fins>
! 			<device_type>xmls/devices/finfet_7nm_std.xml</device_type>
  		</pup>
  		<pdn> <!-- pull down transistors -->
  			<num_of_fins>1</num_of_fins>
! 			<device_type>xmls/devices/finfet_7nm_std.xml</device_type>
  		</pdn>
  	</transistor_parameters>
  </sram_cell>
--- 17,31 ----
  	<transistor_parameters>
  		<acc> <!-- access transistors -->
  			<num_of_fins>1</num_of_fins>
! 			<device_type>xmls/devices/new_finfet_std.xml</device_type>
  		</acc>
  		<pup> <!-- pull up transistors -->
  			<num_of_fins>1</num_of_fins>
! 			<device_type>xmls/devices/new_finfet_std.xml</device_type>
  		</pup>
  		<pdn> <!-- pull down transistors -->
  			<num_of_fins>1</num_of_fins>
! 			<device_type>xmls/devices/new_finfet_std.xml</device_type>
  		</pdn>
  	</transistor_parameters>
  </sram_cell>
Only in fncacti/xmls/sram_cells: ncfet_sram_6T1.xml
